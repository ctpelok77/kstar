!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABORT	utils/system.h	23;"	d
ABSTRACT_TASK_H	abstract_task.h	2;"	d
ALGORITHMS_DYNAMIC_BITSET_H	algorithms/dynamic_bitset.h	2;"	d
ALGORITHMS_EQUIVALENCE_RELATION_H	algorithms/equivalence_relation.h	2;"	d
ALGORITHMS_INT_PACKER_H	algorithms/int_packer.h	2;"	d
ALGORITHMS_MAX_CLIQUES_H	algorithms/max_cliques.h	2;"	d
ALGORITHMS_ORDERED_SET_H	algorithms/ordered_set.h	2;"	d
ALGORITHMS_PRIORITY_QUEUES_H	algorithms/priority_queues.h	2;"	d
ALGORITHMS_SEGMENTED_VECTOR_H	algorithms/segmented_vector.h	2;"	d
ALL_STATES	potentials/single_potential_heuristics.cc	/^    ALL_STATES,$/;"	m	class:potentials::OptimizeFor	file:
ALL_TRANSITION_SYSTEMS	merge_and_shrink/label_reduction.h	/^        ALL_TRANSITION_SYSTEMS,$/;"	e	enum:merge_and_shrink::LabelReduction::LabelReductionMethod
ALL_TRANSITION_SYSTEMS_WITH_FIXPOINT	merge_and_shrink/label_reduction.h	/^        ALL_TRANSITION_SYSTEMS_WITH_FIXPOINT$/;"	e	enum:merge_and_shrink::LabelReduction::LabelReductionMethod
AXIOMS_H	axioms.h	2;"	d
AbstractGraph	bliss/graph.cc	/^AbstractGraph::AbstractGraph()$/;"	f	class:bliss::AbstractGraph
AbstractGraph	bliss/graph.h	/^class AbstractGraph$/;"	c	namespace:bliss
AbstractOperator	pdbs/pattern_database.cc	/^AbstractOperator::AbstractOperator(const vector<FactPair> &prev_pairs,$/;"	f	class:pdbs::AbstractOperator
AbstractOperator	pdbs/pattern_database.h	/^class AbstractOperator {$/;"	c	namespace:pdbs
AbstractQueue	algorithms/priority_queues.h	/^    AbstractQueue() {}$/;"	f	class:priority_queues::AbstractQueue
AbstractQueue	algorithms/priority_queues.h	/^class AbstractQueue {$/;"	c	namespace:priority_queues
AbstractSearch	cegar/abstract_search.cc	/^AbstractSearch::AbstractSearch($/;"	f	class:cegar::AbstractSearch
AbstractSearch	cegar/abstract_search.h	/^class AbstractSearch {$/;"	c	namespace:cegar
AbstractSearchInfo	cegar/abstract_state.h	/^    AbstractSearchInfo()$/;"	f	class:cegar::AbstractSearchInfo
AbstractSearchInfo	cegar/abstract_state.h	/^class AbstractSearchInfo {$/;"	c	namespace:cegar
AbstractState	cegar/abstract_state.cc	/^AbstractState::AbstractState(AbstractState &&other)$/;"	f	class:cegar::AbstractState
AbstractState	cegar/abstract_state.cc	/^AbstractState::AbstractState(const Domains &domains, Node *node)$/;"	f	class:cegar::AbstractState
AbstractState	cegar/abstract_state.h	/^class AbstractState {$/;"	c	namespace:cegar
AbstractTask	abstract_task.h	/^class AbstractTask {$/;"	c
Abstraction	cegar/abstraction.cc	/^Abstraction::Abstraction($/;"	f	class:cegar::Abstraction
Abstraction	cegar/abstraction.h	/^class Abstraction {$/;"	c	namespace:cegar
AdaptiveQueue	algorithms/priority_queues.h	/^    AdaptiveQueue() : wrapped_queue(new BucketQueue<Value>) {$/;"	f	class:priority_queues::AdaptiveQueue
AdaptiveQueue	algorithms/priority_queues.h	/^class AdaptiveQueue {$/;"	c	namespace:priority_queues
AdditiveCartesianHeuristic	cegar/additive_cartesian_heuristic.cc	/^AdditiveCartesianHeuristic::AdditiveCartesianHeuristic($/;"	f	class:cegar::AdditiveCartesianHeuristic
AdditiveCartesianHeuristic	cegar/additive_cartesian_heuristic.h	/^class AdditiveCartesianHeuristic : public Heuristic {$/;"	c	namespace:cegar
AdditiveHeuristic	heuristics/additive_heuristic.cc	/^AdditiveHeuristic::AdditiveHeuristic(const Options &opts)$/;"	f	class:additive_heuristic::AdditiveHeuristic
AdditiveHeuristic	heuristics/additive_heuristic.h	/^class AdditiveHeuristic : public relaxation_heuristic::RelaxationHeuristic {$/;"	c	namespace:additive_heuristic
AlternationOpenList	open_lists/alternation_open_list.cc	/^AlternationOpenList<Entry>::AlternationOpenList(const Options &opts)$/;"	f	class:AlternationOpenList
AlternationOpenList	open_lists/alternation_open_list.cc	/^class AlternationOpenList : public OpenList<Entry> {$/;"	c	file:
AlternationOpenListFactory	open_lists/alternation_open_list.cc	/^AlternationOpenListFactory::AlternationOpenListFactory(const Options &options)$/;"	f	class:AlternationOpenListFactory
AlternationOpenListFactory	open_lists/alternation_open_list.h	/^class AlternationOpenListFactory : public OpenListFactory {$/;"	c
Any	options/any.h	/^    Any() : content(nullptr) {$/;"	f	class:options::Any
Any	options/any.h	/^    Any(const Any &other)$/;"	f	class:options::Any
Any	options/any.h	/^    Any(const ValueType &value)$/;"	f	class:options::Any
Any	options/any.h	/^class Any {$/;"	c	namespace:options
ArgError	options/errors.cc	/^ArgError::ArgError(string msg)$/;"	f	class:options::ArgError
ArgError	options/errors.h	/^struct ArgError {$/;"	s	namespace:options
ArgumentInfo	options/doc_store.h	/^    ArgumentInfo($/;"	f	struct:options::ArgumentInfo
ArgumentInfo	options/doc_store.h	/^struct ArgumentInfo {$/;"	s	namespace:options
AtLimit	merge_and_shrink/shrink_bisimulation.h	/^    enum AtLimit {$/;"	g	class:merge_and_shrink::ShrinkBisimulation
AtomicTSOrder	merge_and_shrink/merge_scoring_function_total_order.h	/^    enum class AtomicTSOrder {$/;"	c	class:merge_and_shrink::MergeScoringFunctionTotalOrder
AxiomEvaluator	axioms.cc	/^AxiomEvaluator::AxiomEvaluator(const TaskProxy &task_proxy) {$/;"	f	class:AxiomEvaluator
AxiomEvaluator	axioms.h	/^class AxiomEvaluator {$/;"	c
AxiomLiteral	axioms.h	/^    struct AxiomLiteral {$/;"	s	class:AxiomEvaluator
AxiomRule	axioms.h	/^        AxiomRule(int cond_count, int eff_var, int eff_val, AxiomLiteral *eff_literal)$/;"	f	struct:AxiomEvaluator::AxiomRule
AxiomRule	axioms.h	/^    struct AxiomRule {$/;"	s	class:AxiomEvaluator
AxiomsProxy	task_proxy.h	/^    explicit AxiomsProxy(const AbstractTask &task)$/;"	f	class:AxiomsProxy
AxiomsProxy	task_proxy.h	/^class AxiomsProxy {$/;"	c
BEFORE_GOAL_ZONE	heuristics/lm_cut_landmarks.h	/^    BEFORE_GOAL_ZONE = 3$/;"	e	enum:lm_cut_heuristic::PropositionStatus
BITS_PER_BIN	algorithms/int_packer.cc	/^static const int BITS_PER_BIN = sizeof(IntPacker::Bin) * 8;$/;"	m	namespace:int_packer	file:
BLISS_BIGNUM_HH	bliss/bignum.h	2;"	d
BLISS_CONSISTENCY_CHECKS	bliss/defs.h	66;"	d
BLISS_DEFS_HH	bliss/defs.h	2;"	d
BLISS_EXPENSIVE_CONSISTENCY_CHECKS	bliss/defs.h	67;"	d
BLISS_GRAPH_HH	bliss/graph.h	2;"	d
BLISS_HEAP_HH	bliss/heap.h	2;"	d
BLISS_KQUEUE_HH	bliss/kqueue.h	2;"	d
BLISS_KSTACK_H	bliss/kstack.h	2;"	d
BLISS_ORBIT_HH	bliss/orbit.h	2;"	d
BLISS_PARTITION_HH	bliss/partition.h	2;"	d
BLISS_TIMER_HH	bliss/timer.h	2;"	d
BLISS_UINTSEQHASH_HH	bliss/uintseqhash.h	2;"	d
BLISS_UTILS_HH	bliss/utils.h	2;"	d
BLISS_VERIFY_AUTOMORPHISMS	bliss/defs.h	73;"	d
BLISS_VERIFY_EQUITABLEDNESS	bliss/defs.h	79;"	d
BacktrackInfo	bliss/partition.h	/^  class BacktrackInfo {$/;"	c	class:bliss::Partition
BacktrackPoint	bliss/partition.h	/^  typedef unsigned int BacktrackPoint;$/;"	t	class:bliss::Partition
BadAnyCast	options/any.h	/^class BadAnyCast : public std::bad_cast {$/;"	c	namespace:options
BigNum	bliss/bignum.h	/^  BigNum() {mpz_init(v); }$/;"	f	class:bliss::BigNum
BigNum	bliss/bignum.h	/^class BigNum$/;"	c	namespace:bliss
Bin	algorithms/int_packer.h	/^    typedef unsigned int Bin;$/;"	t	class:int_packer::IntPacker
BlindSearchHeuristic	heuristics/blind_search_heuristic.cc	/^BlindSearchHeuristic::BlindSearchHeuristic(const Options &opts)$/;"	f	class:blind_search_heuristic::BlindSearchHeuristic
BlindSearchHeuristic	heuristics/blind_search_heuristic.h	/^class BlindSearchHeuristic : public Heuristic {$/;"	c	namespace:blind_search_heuristic
BlissException	bliss/defs.h	/^struct BlissException : public std::exception {$/;"	s	namespace:bliss
BlissMemoryOut	bliss/defs.h	/^struct BlissMemoryOut : public BlissException, public std::bad_alloc {$/;"	s	namespace:bliss
BlissTimeOut	bliss/defs.h	/^struct BlissTimeOut : public BlissException {$/;"	s	namespace:bliss
Block	algorithms/equivalence_relation.h	/^class Block {$/;"	c	namespace:equivalence_relation
BlockListConstIter	algorithms/equivalence_relation.h	/^typedef std::list<Block>::const_iterator BlockListConstIter;$/;"	t	namespace:equivalence_relation
BlockListIter	algorithms/equivalence_relation.h	/^typedef std::list<Block>::iterator BlockListIter;$/;"	t	namespace:equivalence_relation
Bounds	options/bounds.h	/^    Bounds(std::string min, std::string max)$/;"	f	struct:options::Bounds
Bounds	options/bounds.h	/^struct Bounds {$/;"	s	namespace:options
Bucket	algorithms/priority_queues.h	/^    typedef std::vector<Value> Bucket;$/;"	t	class:priority_queues::BucketQueue
Bucket	merge_and_shrink/shrink_bucket_based.h	/^    typedef std::vector<int> Bucket;$/;"	t	class:merge_and_shrink::ShrinkBucketBased
Bucket	open_lists/pareto_open_list.cc	/^    typedef deque<Entry> Bucket;$/;"	t	class:ParetoOpenList	file:
Bucket	open_lists/standard_scalar_open_list.cc	/^    typedef deque<Entry> Bucket;$/;"	t	class:StandardScalarOpenList	file:
BucketMap	open_lists/pareto_open_list.cc	/^    typedef unordered_map<KeyType, Bucket> BucketMap;$/;"	t	class:ParetoOpenList	file:
BucketQueue	algorithms/priority_queues.h	/^    BucketQueue() : current_bucket_no(0), num_entries(0), num_pushes(0) {$/;"	f	class:priority_queues::BucketQueue
BucketQueue	algorithms/priority_queues.h	/^class BucketQueue : public AbstractQueue<Value> {$/;"	c	namespace:priority_queues
CAUSAL_GRAPH_H	causal_graph.h	2;"	d
CEGAR_ABSTRACTION_H	cegar/abstraction.h	2;"	d
CEGAR_ABSTRACT_SEARCH_H	cegar/abstract_search.h	2;"	d
CEGAR_ABSTRACT_STATE_H	cegar/abstract_state.h	2;"	d
CEGAR_ADDITIVE_CARTESIAN_HEURISTIC_H	cegar/additive_cartesian_heuristic.h	2;"	d
CEGAR_CARTESIAN_HEURISTIC_FUNCTION_H	cegar/cartesian_heuristic_function.h	2;"	d
CEGAR_COST_SATURATION_H	cegar/cost_saturation.h	2;"	d
CEGAR_DOMAINS_H	cegar/domains.h	2;"	d
CEGAR_REFINEMENT_HIERARCHY_H	cegar/refinement_hierarchy.h	2;"	d
CEGAR_SPLIT_SELECTOR_H	cegar/split_selector.h	2;"	d
CEGAR_SUBTASK_GENERATORS_H	cegar/subtask_generators.h	2;"	d
CEGAR_TRANSITION_H	cegar/transition.h	2;"	d
CEGAR_TRANSITION_UPDATER_H	cegar/transition_updater.h	2;"	d
CEGAR_UTILS_H	cegar/utils.h	2;"	d
CEGAR_UTILS_LANDMARKS_H	cegar/utils_landmarks.h	2;"	d
CERT_EDGE	bliss/graph.h	/^  static const unsigned int CERT_EDGE  = 1; \/\/UINT_MAX-1;$/;"	m	class:bliss::AbstractGraph
CERT_SPLIT	bliss/graph.h	/^  static const unsigned int CERT_SPLIT = 0; \/\/UINT_MAX;$/;"	m	class:bliss::AbstractGraph
CGCache	heuristics/cg_cache.cc	/^CGCache::CGCache(TaskProxy &task_proxy) : task_proxy(task_proxy) {$/;"	f	class:cg_heuristic::CGCache
CGCache	heuristics/cg_cache.h	/^class CGCache {$/;"	c	namespace:cg_heuristic
CGHeuristic	heuristics/cg_heuristic.cc	/^CGHeuristic::CGHeuristic(const Options &opts)$/;"	f	class:cg_heuristic::CGHeuristic
CGHeuristic	heuristics/cg_heuristic.h	/^class CGHeuristic : public Heuristic {$/;"	c	namespace:cg_heuristic
CG_GOAL_LEVEL	variable_order_finder.h	/^    CG_GOAL_LEVEL,$/;"	e	enum:VariableOrderType
CG_GOAL_RANDOM	variable_order_finder.h	/^    CG_GOAL_RANDOM,$/;"	e	enum:VariableOrderType
CLOSED	search_node_info.h	/^    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};$/;"	e	enum:SearchNodeInfo::NodeStatus
CLP	lp/lp_solver.h	/^    CLP, CPLEX, GUROBI$/;"	m	class:lp::LPSolverType
CONDITIONAL_DELETE_EFFECT_VERTEX	structural_symmetries/graph_creator.cc	/^              CONDITIONAL_DELETE_EFFECT_VERTEX, MAX_VALUE};$/;"	e	enum:color_t	file:
CONDITIONAL_EFFECT_VERTEX	structural_symmetries/graph_creator.cc	/^              GOAL_VERTEX, INIT_VERTEX, CONDITIONAL_EFFECT_VERTEX,$/;"	e	enum:color_t	file:
CPLEX	lp/lp_solver.h	/^    CLP, CPLEX, GUROBI$/;"	m	class:lp::LPSolverType
CPLEX_ERROR_OOM	lp/lp_internals.cc	/^static const string CPLEX_ERROR_OOM = "CPX0000  CPLEX Error  1001: Out of memory.";$/;"	m	namespace:lp	file:
CPLEX_ERROR_OOM_DEVEX	lp/lp_internals.cc	/^static const string CPLEX_ERROR_OOM_DEVEX = "CPX0000  Not enough memory for devex.";$/;"	m	namespace:lp	file:
CPLEX_ERROR_OOM_PRE	lp/lp_internals.cc	/^static const string CPLEX_ERROR_OOM_PRE = "CPX0000  Insufficient memory for presolve.";$/;"	m	namespace:lp	file:
CPLEX_WARNING_COMPRESS	lp/lp_internals.cc	/^static const string CPLEX_WARNING_COMPRESS = "CPX0000  Compressing row and column files.";$/;"	m	namespace:lp	file:
CPLEX_WARNING_WRITE_MPS_COLUMNS	lp/lp_internals.cc	/^static const string CPLEX_WARNING_WRITE_MPS_COLUMNS = "CPX0000  Default column names x1, x2 ... being created.";$/;"	m	namespace:lp	file:
CPLEX_WARNING_WRITE_MPS_ROWS	lp/lp_internals.cc	/^static const string CPLEX_WARNING_WRITE_MPS_ROWS = "CPX0000  Default row    names c1, c2 ... being created.";$/;"	m	namespace:lp	file:
CRCell	bliss/partition.h	/^  class CRCell {$/;"	c	class:bliss::Partition
CRITICAL_ERROR	utils/system.h	/^    CRITICAL_ERROR = 1,$/;"	m	class:utils::ExitCode
CR_BTInfo	bliss/partition.h	/^  class CR_BTInfo {$/;"	c	class:bliss::Partition
CR_CEP	bliss/graph.h	/^  class CR_CEP {$/;"	c	class:bliss::AbstractGraph
CanonicalPDBs	pdbs/canonical_pdbs.cc	/^CanonicalPDBs::CanonicalPDBs($/;"	f	class:pdbs::CanonicalPDBs
CanonicalPDBs	pdbs/canonical_pdbs.h	/^class CanonicalPDBs {$/;"	c	namespace:pdbs
CanonicalPDBsHeuristic	pdbs/canonical_pdbs_heuristic.cc	/^CanonicalPDBsHeuristic::CanonicalPDBsHeuristic(const Options &opts)$/;"	f	class:pdbs::CanonicalPDBsHeuristic
CanonicalPDBsHeuristic	pdbs/canonical_pdbs_heuristic.h	/^class CanonicalPDBsHeuristic : public Heuristic {$/;"	c	namespace:pdbs
CartesianHeuristicFunction	cegar/cartesian_heuristic_function.cc	/^CartesianHeuristicFunction::CartesianHeuristicFunction($/;"	f	class:cegar::CartesianHeuristicFunction
CartesianHeuristicFunction	cegar/cartesian_heuristic_function.h	/^    CartesianHeuristicFunction(CartesianHeuristicFunction &&other)$/;"	f	class:cegar::CartesianHeuristicFunction
CartesianHeuristicFunction	cegar/cartesian_heuristic_function.h	/^class CartesianHeuristicFunction {$/;"	c	namespace:cegar
CausalGraph	causal_graph.cc	/^CausalGraph::CausalGraph(const TaskProxy &task_proxy) {$/;"	f	class:CausalGraph
CausalGraph	causal_graph.h	/^class CausalGraph {$/;"	c
CausalGraphBuilder	causal_graph.cc	/^    explicit CausalGraphBuilder(int var_count)$/;"	f	struct:CausalGraphBuilder
CausalGraphBuilder	causal_graph.cc	/^struct CausalGraphBuilder {$/;"	s	file:
Cell	bliss/partition.h	/^  class Cell$/;"	c	class:bliss::Partition
CombiningEvaluator	evaluators/combining_evaluator.cc	/^CombiningEvaluator::CombiningEvaluator($/;"	f	class:combining_evaluator::CombiningEvaluator
CombiningEvaluator	evaluators/combining_evaluator.h	/^class CombiningEvaluator : public ScalarEvaluator {$/;"	c	namespace:combining_evaluator
Condition	successor_generator.h	/^    typedef std::vector<FactProxy> Condition;$/;"	t	class:SuccessorGenerator
ConditionsProxy	task_proxy.h	/^    explicit ConditionsProxy(const AbstractTask &task)$/;"	f	class:ConditionsProxy
ConditionsProxy	task_proxy.h	/^class ConditionsProxy {$/;"	c
ConstEvaluator	evaluators/const_evaluator.cc	/^ConstEvaluator::ConstEvaluator(const Options &opts)$/;"	f	class:const_evaluator::ConstEvaluator
ConstEvaluator	evaluators/const_evaluator.h	/^class ConstEvaluator : public Heuristic {$/;"	c	namespace:const_evaluator
ConstraintGenerator	operator_counting/constraint_generator.h	/^class ConstraintGenerator {$/;"	c	namespace:operator_counting
ContextEnhancedAdditiveHeuristic	heuristics/cea_heuristic.cc	/^ContextEnhancedAdditiveHeuristic::ContextEnhancedAdditiveHeuristic($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
ContextEnhancedAdditiveHeuristic	heuristics/cea_heuristic.h	/^class ContextEnhancedAdditiveHeuristic : public Heuristic {$/;"	c	namespace:cea_heuristic
CostAdaptedTask	tasks/cost_adapted_task.cc	/^CostAdaptedTask::CostAdaptedTask(const Options &opts)$/;"	f	class:tasks::CostAdaptedTask
CostAdaptedTask	tasks/cost_adapted_task.h	/^class CostAdaptedTask : public DelegatingTask {$/;"	c	namespace:tasks
CostSaturation	cegar/cost_saturation.cc	/^CostSaturation::CostSaturation($/;"	f	class:cegar::CostSaturation
CostSaturation	cegar/cost_saturation.h	/^class CostSaturation {$/;"	c	namespace:cegar
CountdownTimer	utils/countdown_timer.cc	/^CountdownTimer::CountdownTimer(double max_time)$/;"	f	class:utils::CountdownTimer
CountdownTimer	utils/countdown_timer.h	/^class CountdownTimer {$/;"	c	namespace:utils
DEAD_END	heuristic.h	/^    enum {DEAD_END = -1, NO_VALUE = -2};$/;"	e	enum:Heuristic::__anon4
DEAD_END	search_node_info.h	/^    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};$/;"	e	enum:SearchNodeInfo::NodeStatus
DEFAULT_LAZY_BOOST	search_engines/lazy_search.cc	/^static const int DEFAULT_LAZY_BOOST = 1000;$/;"	m	namespace:lazy_search	file:
DISTANCE_UNKNOWN	merge_and_shrink/distances.cc	/^const int Distances::DISTANCE_UNKNOWN;$/;"	m	class:merge_and_shrink::Distances	file:
DISTANCE_UNKNOWN	merge_and_shrink/distances.h	/^    static const int DISTANCE_UNKNOWN = -1;$/;"	m	class:merge_and_shrink::Distances
DOMAIN_TRANSITION_GRAPH_H	domain_transition_graph.h	2;"	d
DTGFactory	domain_transition_graph.cc	/^DTGFactory::DTGFactory(const TaskProxy &task_proxy,$/;"	f	class:DTGFactory
DTGFactory	domain_transition_graph.h	/^class DTGFactory {$/;"	c
DelegatingTask	tasks/delegating_task.cc	/^DelegatingTask::DelegatingTask(const shared_ptr<AbstractTask> &parent)$/;"	f	class:tasks::DelegatingTask
DelegatingTask	tasks/delegating_task.h	/^class DelegatingTask : public AbstractTask {$/;"	c	namespace:tasks
Digraph	bliss/graph.cc	/^Digraph::Digraph(const unsigned int nof_vertices)$/;"	f	class:bliss::Digraph
Digraph	bliss/graph.h	/^class Digraph : public AbstractGraph$/;"	c	namespace:bliss
Distances	merge_and_shrink/distances.cc	/^Distances::Distances(const TransitionSystem &transition_system)$/;"	f	class:merge_and_shrink::Distances
Distances	merge_and_shrink/distances.h	/^class Distances {$/;"	c	namespace:merge_and_shrink
DiversePotentialHeuristics	potentials/diverse_potential_heuristics.cc	/^DiversePotentialHeuristics::DiversePotentialHeuristics(const Options &opts)$/;"	f	class:potentials::DiversePotentialHeuristics
DiversePotentialHeuristics	potentials/diverse_potential_heuristics.h	/^class DiversePotentialHeuristics {$/;"	c	namespace:potentials
DocPrinter	options/doc_printer.cc	/^DocPrinter::DocPrinter(ostream &out)$/;"	f	class:options::DocPrinter
DocPrinter	options/doc_printer.h	/^class DocPrinter {$/;"	c	namespace:options
DocStore	options/doc_store.h	/^class DocStore {$/;"	c	namespace:options
DocStruct	options/doc_store.h	/^struct DocStruct {$/;"	s	namespace:options
DomainAbstractedTask	tasks/domain_abstracted_task.cc	/^DomainAbstractedTask::DomainAbstractedTask($/;"	f	class:extra_tasks::DomainAbstractedTask
DomainAbstractedTask	tasks/domain_abstracted_task.h	/^class DomainAbstractedTask : public tasks::DelegatingTask {$/;"	c	namespace:extra_tasks
DomainAbstractedTaskFactory	tasks/domain_abstracted_task_factory.cc	/^DomainAbstractedTaskFactory::DomainAbstractedTaskFactory($/;"	f	class:extra_tasks::DomainAbstractedTaskFactory
DomainAbstractedTaskFactory	tasks/domain_abstracted_task_factory.cc	/^class DomainAbstractedTaskFactory {$/;"	c	namespace:extra_tasks	file:
DomainTransitionGraph	domain_transition_graph.cc	/^DomainTransitionGraph::DomainTransitionGraph(int var_index, int node_count) {$/;"	f	class:DomainTransitionGraph
DomainTransitionGraph	domain_transition_graph.h	/^class DomainTransitionGraph {$/;"	c
Domains	cegar/domains.cc	/^Domains::Domains(const vector<int> &domain_sizes) {$/;"	f	class:cegar::Domains
Domains	cegar/domains.h	/^class Domains {$/;"	c	namespace:cegar
DynamicBitset	algorithms/dynamic_bitset.h	/^    explicit DynamicBitset(std::size_t num_bits)$/;"	f	class:dynamic_bitset::DynamicBitset
DynamicBitset	algorithms/dynamic_bitset.h	/^class DynamicBitset {$/;"	c	namespace:dynamic_bitset
EFFECT_VERTEX	structural_symmetries/graph_creator.cc	/^enum color_t {PREDICATE_VERTEX, VALUE_VERTEX, PRECOND_VERTEX, EFFECT_VERTEX,$/;"	e	enum:color_t	file:
EVALUATION_CONTEXT_H	evaluation_context.h	2;"	d
EVALUATION_RESULT_H	evaluation_result.h	2;"	d
EVALUATORS_COMBINING_EVALUATOR_H	evaluators/combining_evaluator.h	2;"	d
EVALUATORS_CONST_EVALUATOR_H	evaluators/const_evaluator.h	2;"	d
EVALUATORS_G_EVALUATOR_H	evaluators/g_evaluator.h	2;"	d
EVALUATORS_MAX_EVALUATOR_H	evaluators/max_evaluator.h	2;"	d
EVALUATORS_PREF_EVALUATOR_H	evaluators/pref_evaluator.h	2;"	d
EVALUATORS_SUM_EVALUATOR_H	evaluators/sum_evaluator.h	2;"	d
EVALUATORS_WEIGHTED_EVALUATOR_H	evaluators/weighted_evaluator.h	2;"	d
EagerSearch	search_engines/eager_search.cc	/^EagerSearch::EagerSearch(const Options &opts)$/;"	f	class:eager_search::EagerSearch
EagerSearch	search_engines/eager_search.h	/^class EagerSearch : public SearchEngine {$/;"	c	namespace:eager_search
EdgeType	landmarks/landmark_graph.h	/^enum class EdgeType {$/;"	c	namespace:landmarks
EffectConditionsProxy	task_proxy.h	/^    EffectConditionsProxy($/;"	f	class:EffectConditionsProxy
EffectConditionsProxy	task_proxy.h	/^class EffectConditionsProxy : public ConditionsProxy {$/;"	c
EffectProxy	task_proxy.h	/^    EffectProxy(const AbstractTask &task, int op_index, int eff_index, bool is_axiom)$/;"	f	class:EffectProxy
EffectProxy	task_proxy.h	/^class EffectProxy {$/;"	c
EffectsProxy	task_proxy.h	/^    EffectsProxy(const AbstractTask &task, int op_index, bool is_axiom)$/;"	f	class:EffectsProxy
EffectsProxy	task_proxy.h	/^class EffectsProxy {$/;"	c
ElementAllocator	algorithms/segmented_vector.h	/^    typedef typename Allocator::template rebind<Element>::other ElementAllocator;$/;"	t	class:segmented_vector::SegmentedArrayVector
ElementListConstIter	algorithms/equivalence_relation.h	/^typedef std::list<int>::const_iterator ElementListConstIter;$/;"	t	namespace:equivalence_relation
ElementListIter	algorithms/equivalence_relation.h	/^typedef std::list<int>::iterator ElementListIter;$/;"	t	namespace:equivalence_relation
ElementPosition	algorithms/equivalence_relation.h	/^    typedef std::pair<BlockListIter, ElementListIter> ElementPosition;$/;"	t	class:equivalence_relation::EquivalenceRelation
ElementPositionMap	algorithms/equivalence_relation.h	/^    typedef std::unordered_map<int, ElementPosition> ElementPositionMap;$/;"	t	class:equivalence_relation::EquivalenceRelation
EnforcedHillClimbingSearch	search_engines/enforced_hill_climbing_search.cc	/^EnforcedHillClimbingSearch::EnforcedHillClimbingSearch($/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
EnforcedHillClimbingSearch	search_engines/enforced_hill_climbing_search.h	/^class EnforcedHillClimbingSearch : public SearchEngine {$/;"	c	namespace:enforced_hill_climbing_search
Entry	algorithms/priority_queues.h	/^    typedef std::pair<int, Value> Entry;$/;"	t	class:priority_queues::AbstractQueue
Entry	algorithms/priority_queues.h	/^    typedef std::pair<int, Value> Entry;$/;"	t	class:priority_queues::AdaptiveQueue
Entry	algorithms/priority_queues.h	/^    typedef typename AbstractQueue<Value>::Entry Entry;$/;"	t	class:priority_queues::BucketQueue
Entry	algorithms/priority_queues.h	/^    typedef typename AbstractQueue<Value>::Entry Entry;$/;"	t	class:priority_queues::HeapQueue
EntryAllocator	algorithms/segmented_vector.h	/^    typedef typename Allocator::template rebind<Entry>::other EntryAllocator;$/;"	t	class:segmented_vector::SegmentedVector
EntryVectorMap	per_state_information.h	/^                               segmented_vector::SegmentedVector<Entry> * > EntryVectorMap;$/;"	t	class:PerStateInformation
EpsilonGreedyOpenList	open_lists/epsilon_greedy_open_list.cc	/^EpsilonGreedyOpenList<Entry>::EpsilonGreedyOpenList(const Options &opts)$/;"	f	class:EpsilonGreedyOpenList
EpsilonGreedyOpenList	open_lists/epsilon_greedy_open_list.cc	/^class EpsilonGreedyOpenList : public OpenList<Entry> {$/;"	c	file:
EpsilonGreedyOpenListFactory	open_lists/epsilon_greedy_open_list.cc	/^EpsilonGreedyOpenListFactory::EpsilonGreedyOpenListFactory($/;"	f	class:EpsilonGreedyOpenListFactory
EpsilonGreedyOpenListFactory	open_lists/epsilon_greedy_open_list.h	/^class EpsilonGreedyOpenListFactory : public OpenListFactory {$/;"	c
EquivalenceRelation	algorithms/equivalence_relation.cc	/^EquivalenceRelation::EquivalenceRelation(int n)$/;"	f	class:equivalence_relation::EquivalenceRelation
EquivalenceRelation	algorithms/equivalence_relation.cc	/^EquivalenceRelation::EquivalenceRelation(int n, const list<Block> &blocks_)$/;"	f	class:equivalence_relation::EquivalenceRelation
EquivalenceRelation	algorithms/equivalence_relation.h	/^class EquivalenceRelation {$/;"	c	namespace:equivalence_relation
ErrorCatchingCoinMessageHandler	lp/lp_internals.cc	/^    ErrorCatchingCoinMessageHandler()$/;"	f	class:lp::ErrorCatchingCoinMessageHandler
ErrorCatchingCoinMessageHandler	lp/lp_internals.cc	/^class ErrorCatchingCoinMessageHandler : public CoinMessageHandler {$/;"	c	namespace:lp	file:
EvaluationContext	evaluation_context.cc	/^EvaluationContext::EvaluationContext($/;"	f	class:EvaluationContext
EvaluationContext	evaluation_context.h	/^class EvaluationContext {$/;"	c
EvaluationResult	evaluation_result.cc	/^EvaluationResult::EvaluationResult() : h_value(UNINITIALIZED) {$/;"	f	class:EvaluationResult
EvaluationResult	evaluation_result.h	/^class EvaluationResult {$/;"	c
ExProposition	landmarks/exploration.h	/^    ExProposition()$/;"	f	struct:landmarks::ExProposition
ExProposition	landmarks/exploration.h	/^struct ExProposition {$/;"	s	namespace:landmarks
ExUnaryOperator	landmarks/exploration.h	/^    ExUnaryOperator(const std::vector<ExProposition *> &pre, ExProposition *eff,$/;"	f	struct:landmarks::ExUnaryOperator
ExUnaryOperator	landmarks/exploration.h	/^struct ExUnaryOperator {$/;"	s	namespace:landmarks
ExitCode	utils/system.h	/^enum class ExitCode {$/;"	c	namespace:utils
Exploration	landmarks/exploration.cc	/^Exploration::Exploration(const options::Options &opts)$/;"	f	class:landmarks::Exploration
Exploration	landmarks/exploration.h	/^class Exploration : public Heuristic {$/;"	c	namespace:landmarks
FAILED	search_engine.h	/^enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED, INTERRUPTED};$/;"	e	enum:SearchStatus
FFHeuristic	heuristics/ff_heuristic.cc	/^FFHeuristic::FFHeuristic(const Options &opts)$/;"	f	class:ff_heuristic::FFHeuristic
FFHeuristic	heuristics/ff_heuristic.h	/^class FFHeuristic : public additive_heuristic::AdditiveHeuristic {$/;"	c	namespace:ff_heuristic
FFSlaveHeuristic	landmarks/lama_ff_synergy.cc	/^    explicit FFSlaveHeuristic(LamaFFSynergy *synergy,$/;"	f	class:landmarks::FFSlaveHeuristic
FFSlaveHeuristic	landmarks/lama_ff_synergy.cc	/^class FFSlaveHeuristic : public Heuristic {$/;"	c	namespace:landmarks	file:
FTSConstIterator	merge_and_shrink/factored_transition_system.cc	/^FTSConstIterator::FTSConstIterator($/;"	f	class:merge_and_shrink::FTSConstIterator
FTSConstIterator	merge_and_shrink/factored_transition_system.h	/^class FTSConstIterator {$/;"	c	namespace:merge_and_shrink
FTSFactory	merge_and_shrink/fts_factory.cc	/^FTSFactory::FTSFactory(const TaskProxy &task_proxy)$/;"	f	class:merge_and_shrink::FTSFactory
FTSFactory	merge_and_shrink/fts_factory.cc	/^class FTSFactory {$/;"	c	namespace:merge_and_shrink	file:
FactOrder	cegar/subtask_generators.h	/^enum class FactOrder {$/;"	c	namespace:cegar
FactPair	abstract_task.h	/^    FactPair(int var, int value)$/;"	f	struct:FactPair
FactPair	abstract_task.h	/^struct FactPair {$/;"	s
FactProxy	task_proxy.h	/^class FactProxy {$/;"	c
FactProxy	task_proxy.h	/^inline FactProxy::FactProxy(const AbstractTask &task, const FactPair &fact)$/;"	f	class:FactProxy
FactProxy	task_proxy.h	/^inline FactProxy::FactProxy(const AbstractTask &task, int var_id, int value)$/;"	f	class:FactProxy
FactoredTransitionSystem	merge_and_shrink/factored_transition_system.cc	/^FactoredTransitionSystem::FactoredTransitionSystem($/;"	f	class:merge_and_shrink::FactoredTransitionSystem
FactoredTransitionSystem	merge_and_shrink/factored_transition_system.cc	/^FactoredTransitionSystem::FactoredTransitionSystem(FactoredTransitionSystem &&other)$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
FactoredTransitionSystem	merge_and_shrink/factored_transition_system.h	/^class FactoredTransitionSystem {$/;"	c	namespace:merge_and_shrink
Factory	options/registries.h	/^    typedef T (*Factory)(OptionParser &);$/;"	t	class:options::Registry
FactsProxy	task_proxy.h	/^    explicit FactsProxy(const AbstractTask &task)$/;"	f	class:FactsProxy
FactsProxy	task_proxy.h	/^class FactsProxy {$/;"	c
FactsProxyIterator	task_proxy.h	/^    FactsProxyIterator(const AbstractTask &task, int var_id, int value)$/;"	f	class:FactsProxyIterator
FactsProxyIterator	task_proxy.h	/^class FactsProxyIterator {$/;"	c
Flaw	cegar/abstraction.cc	/^    Flaw($/;"	f	struct:cegar::Flaw
Flaw	cegar/abstraction.cc	/^struct Flaw {$/;"	s	namespace:cegar	file:
FluentSetComparer	landmarks/landmark_factory_h_m.h	/^struct FluentSetComparer {$/;"	s	namespace:landmarks
GEvaluator	evaluators/g_evaluator.h	/^class GEvaluator : public ScalarEvaluator {$/;"	c	namespace:g_evaluator
GLOBALS_H	globals.h	2;"	d
GLOBAL_OPERATOR_H	global_operator.h	2;"	d
GLOBAL_STATE_H	global_state.h	2;"	d
GOAL_CG_LEVEL	variable_order_finder.h	/^    GOAL_CG_LEVEL,$/;"	e	enum:VariableOrderType
GOAL_VERTEX	structural_symmetries/graph_creator.cc	/^              GOAL_VERTEX, INIT_VERTEX, CONDITIONAL_EFFECT_VERTEX,$/;"	e	enum:color_t	file:
GOAL_ZONE	heuristics/lm_cut_landmarks.h	/^    GOAL_ZONE = 2,$/;"	e	enum:lm_cut_heuristic::PropositionStatus
GeneratorBase	successor_generator.cc	/^class GeneratorBase {$/;"	c	file:
GeneratorEmpty	successor_generator.cc	/^class GeneratorEmpty : public GeneratorBase {$/;"	c	file:
GeneratorLeaf	successor_generator.cc	/^GeneratorLeaf::GeneratorLeaf(list<OperatorProxy> &&applicable_operators)$/;"	f	class:GeneratorLeaf
GeneratorLeaf	successor_generator.cc	/^class GeneratorLeaf : public GeneratorBase {$/;"	c	file:
GeneratorSwitch	successor_generator.cc	/^GeneratorSwitch::GeneratorSwitch($/;"	f	class:GeneratorSwitch
GeneratorSwitch	successor_generator.cc	/^class GeneratorSwitch : public GeneratorBase {$/;"	c	file:
GlobalCondition	global_operator.cc	/^GlobalCondition::GlobalCondition(int variable, int value, bool check_facts)$/;"	f	class:GlobalCondition
GlobalCondition	global_operator.cc	/^GlobalCondition::GlobalCondition(istream &in) {$/;"	f	class:GlobalCondition
GlobalCondition	global_operator.h	/^struct GlobalCondition {$/;"	s
GlobalEffect	global_operator.cc	/^GlobalEffect::GlobalEffect(int variable, int value, const vector<GlobalCondition> &conds, bool check_facts)$/;"	f	class:GlobalEffect
GlobalEffect	global_operator.h	/^struct GlobalEffect {$/;"	s
GlobalOperator	global_operator.cc	/^GlobalOperator::GlobalOperator(istream &in, bool axiom, int index) $/;"	f	class:GlobalOperator
GlobalOperator	global_operator.h	/^class GlobalOperator {$/;"	c
GlobalState	global_state.cc	/^GlobalState::GlobalState($/;"	f	class:GlobalState
GlobalState	global_state.h	/^class GlobalState {$/;"	c
GoalCountHeuristic	heuristics/goal_count_heuristic.cc	/^GoalCountHeuristic::GoalCountHeuristic(const Options &opts)$/;"	f	class:goal_count_heuristic::GoalCountHeuristic
GoalCountHeuristic	heuristics/goal_count_heuristic.h	/^class GoalCountHeuristic : public Heuristic {$/;"	c	namespace:goal_count_heuristic
GoalDecomposition	cegar/subtask_generators.cc	/^GoalDecomposition::GoalDecomposition(const Options &opts)$/;"	f	class:cegar::GoalDecomposition
GoalDecomposition	cegar/subtask_generators.h	/^class GoalDecomposition : public SubtaskGenerator {$/;"	c	namespace:cegar
GoalsProxy	task_proxy.h	/^    explicit GoalsProxy(const AbstractTask &task)$/;"	f	class:GoalsProxy
GoalsProxy	task_proxy.h	/^class GoalsProxy : public ConditionsProxy {$/;"	c
Graph	bliss/graph.cc	/^Graph::Graph(const unsigned int nof_vertices)$/;"	f	class:bliss::Graph
Graph	bliss/graph.h	/^class Graph : public AbstractGraph$/;"	c	namespace:bliss
GraphCreator	structural_symmetries/graph_creator.cc	/^GraphCreator::GraphCreator(const Options &opts)$/;"	f	class:GraphCreator
GraphCreator	structural_symmetries/graph_creator.h	/^class GraphCreator  {$/;"	c
Group	structural_symmetries/group.cc	/^Group::Group(const options::Options &opts)$/;"	f	class:Group
Group	structural_symmetries/group.h	/^class Group {$/;"	c
GroupAndTransitions	merge_and_shrink/transition_system.h	/^    GroupAndTransitions(const LabelGroup &label_group,$/;"	f	struct:merge_and_shrink::GroupAndTransitions
GroupAndTransitions	merge_and_shrink/transition_system.h	/^struct GroupAndTransitions {$/;"	s	namespace:merge_and_shrink
HADD_UP	cegar/subtask_generators.h	/^    HADD_UP,$/;"	m	class:cegar::FactOrder
HEURISTICS_ADDITIVE_HEURISTIC_H	heuristics/additive_heuristic.h	2;"	d
HEURISTICS_BLIND_SEARCH_HEURISTIC_H	heuristics/blind_search_heuristic.h	2;"	d
HEURISTICS_CEA_HEURISTIC_H	heuristics/cea_heuristic.h	2;"	d
HEURISTICS_CG_CACHE_H	heuristics/cg_cache.h	2;"	d
HEURISTICS_CG_HEURISTIC_H	heuristics/cg_heuristic.h	2;"	d
HEURISTICS_FF_HEURISTIC_H	heuristics/ff_heuristic.h	2;"	d
HEURISTICS_GOAL_COUNT_HEURISTIC_H	heuristics/goal_count_heuristic.h	2;"	d
HEURISTICS_HM_HEURISTIC_H	heuristics/hm_heuristic.h	2;"	d
HEURISTICS_LM_CUT_HEURISTIC_H	heuristics/lm_cut_heuristic.h	2;"	d
HEURISTICS_LM_CUT_LANDMARKS_H	heuristics/lm_cut_landmarks.h	2;"	d
HEURISTICS_MAX_HEURISTIC_H	heuristics/max_heuristic.h	2;"	d
HEURISTICS_RELAXATION_HEURISTIC_H	heuristics/relaxation_heuristic.h	2;"	d
HEURISTIC_CACHE_H	heuristic_cache.h	2;"	d
HEURISTIC_H	heuristic.h	2;"	d
HEntry	heuristic.h	/^        HEntry(int h, bool dirty)$/;"	f	struct:Heuristic::HEntry
HEntry	heuristic.h	/^    struct HEntry {$/;"	s	class:Heuristic
HIGH	merge_and_shrink/shrink_fh.h	/^    enum HighLow {HIGH, LOW};$/;"	e	enum:merge_and_shrink::ShrinkFH::HighLow
HMEntry	landmarks/landmark_factory_h_m.h	/^    HMEntry()$/;"	f	struct:landmarks::HMEntry
HMEntry	landmarks/landmark_factory_h_m.h	/^struct HMEntry {$/;"	s	namespace:landmarks
HMHeuristic	heuristics/hm_heuristic.cc	/^HMHeuristic::HMHeuristic(const Options &opts)$/;"	f	class:hm_heuristic::HMHeuristic
HMHeuristic	heuristics/hm_heuristic.h	/^class HMHeuristic : public Heuristic {$/;"	c	namespace:hm_heuristic
HSPMaxHeuristic	heuristics/max_heuristic.cc	/^HSPMaxHeuristic::HSPMaxHeuristic(const Options &opts)$/;"	f	class:max_heuristic::HSPMaxHeuristic
HSPMaxHeuristic	heuristics/max_heuristic.h	/^class HSPMaxHeuristic : public relaxation_heuristic::RelaxationHeuristic {$/;"	c	namespace:max_heuristic
tree_heap	search_engines/top_k_eager_search.h	/^	PerStateInformation<StateActionHeap> tree_heap;$/;"	m	class:top_k_eager_search::TopKEagerSearch
incomming_heap	search_engines/top_k_eager_search.h	/^    PerStateInformation<StateActionHeap> incomming_heap;$/;"	m	class:top_k_eager_search::TopKEagerSearch
Heap	algorithms/priority_queues.h	/^    class Heap$/;"	c	class:priority_queues::HeapQueue
Heap	bliss/heap.h	/^  Heap() {array = 0; n = 0; N = 0; }$/;"	f	class:bliss::Heap
Heap	bliss/heap.h	/^class Heap$/;"	c	namespace:bliss
HeapNode	open_lists/epsilon_greedy_open_list.cc	/^        HeapNode(int id, int h, const Entry &entry)$/;"	f	struct:EpsilonGreedyOpenList::HeapNode
HeapNode	open_lists/epsilon_greedy_open_list.cc	/^    struct HeapNode {$/;"	s	class:EpsilonGreedyOpenList	file:
HeapQueue	algorithms/priority_queues.h	/^    HeapQueue() {$/;"	f	class:priority_queues::HeapQueue
HeapQueue	algorithms/priority_queues.h	/^class HeapQueue : public AbstractQueue<Value> {$/;"	c	namespace:priority_queues
Heuristic	heuristic.cc	/^Heuristic::Heuristic(const Options &opts)$/;"	f	class:Heuristic
Heuristic	heuristic.h	/^class Heuristic : public ScalarEvaluator {$/;"	c
HeuristicCache	heuristic_cache.cc	/^HeuristicCache::HeuristicCache(const GlobalState &state)$/;"	f	class:HeuristicCache
HeuristicCache	heuristic_cache.h	/^class HeuristicCache {$/;"	c
HighLow	merge_and_shrink/shrink_fh.h	/^    enum HighLow {HIGH, LOW};$/;"	g	class:merge_and_shrink::ShrinkFH
HillClimbingTimeout	pdbs/pattern_collection_generator_hillclimbing.cc	/^struct HillClimbingTimeout : public exception {};$/;"	s	namespace:pdbs	file:
Holder	options/any.h	/^        Holder(const ValueType &value)$/;"	f	class:options::Any::Holder
Holder	options/any.h	/^    class Holder : public Placeholder {$/;"	c	class:options::Any
INDENT_AMOUNT	utils/logging.cc	/^    static const int INDENT_AMOUNT = 2;$/;"	m	class:utils::MemoryTracer	file:
INF	cegar/utils.h	/^const int INF = std::numeric_limits<int>::max();$/;"	m	namespace:cegar
INF	merge_and_shrink/types.cc	/^const int INF = numeric_limits<int>::max();$/;"	m	namespace:merge_and_shrink	file:
INFINITY	utils/util.h	25;"	d
INFTY	evaluation_result.cc	/^const int EvaluationResult::INFTY = numeric_limits<int>::max();$/;"	m	class:EvaluationResult	file:
INFTY	evaluation_result.h	/^    static const int INFTY;$/;"	m	class:EvaluationResult
INITIAL_STATE	potentials/single_potential_heuristics.cc	/^    INITIAL_STATE,$/;"	m	class:potentials::OptimizeFor	file:
INIT_VERTEX	structural_symmetries/graph_creator.cc	/^              GOAL_VERTEX, INIT_VERTEX, CONDITIONAL_EFFECT_VERTEX,$/;"	e	enum:color_t	file:
INPUT_ERROR	utils/system.h	/^    INPUT_ERROR = 2,$/;"	m	class:utils::ExitCode
INTERRUPTED	search_engine.h	/^enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED, INTERRUPTED};$/;"	e	enum:SearchStatus
INVALID	evaluation_context.h	/^    static const int INVALID = -1;$/;"	m	class:EvaluationContext
IN_PROGRESS	search_engine.h	/^enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED, INTERRUPTED};$/;"	e	enum:SearchStatus
IncrementalCanonicalPDBs	pdbs/incremental_canonical_pdbs.cc	/^IncrementalCanonicalPDBs::IncrementalCanonicalPDBs($/;"	f	class:pdbs::IncrementalCanonicalPDBs
IncrementalCanonicalPDBs	pdbs/incremental_canonical_pdbs.h	/^class IncrementalCanonicalPDBs {$/;"	c	namespace:pdbs
IntPacker	algorithms/int_packer.cc	/^IntPacker::IntPacker(const vector<int> &ranges)$/;"	f	class:int_packer::IntPacker
IntPacker	algorithms/int_packer.h	/^class IntPacker {$/;"	c	namespace:int_packer
IntRelation	causal_graph.h	/^typedef std::vector<std::vector<int>> IntRelation;$/;"	t
IntRelationBuilder	causal_graph.cc	/^IntRelationBuilder::IntRelationBuilder(int range)$/;"	f	class:IntRelationBuilder
IntRelationBuilder	causal_graph.cc	/^class IntRelationBuilder {$/;"	c	file:
IntSet	causal_graph.cc	/^    typedef unordered_set<int> IntSet;$/;"	t	class:IntRelationBuilder	file:
IteratedSearch	search_engines/iterated_search.cc	/^IteratedSearch::IteratedSearch(const Options &opts)$/;"	f	class:iterated_search::IteratedSearch
IteratedSearch	search_engines/iterated_search.h	/^class IteratedSearch : public SearchEngine {$/;"	c	namespace:iterated_search
KQueue	bliss/kqueue.h	/^KQueue<Type>::KQueue()$/;"	f	class:bliss::KQueue
KQueue	bliss/kqueue.h	/^class KQueue$/;"	c	namespace:bliss
KSTAR_H	search_engines/kstar.h	2;"	d
KStack	bliss/kstack.h	/^KStack<Type>::KStack()$/;"	f	class:bliss::KStack
KStack	bliss/kstack.h	/^class KStack {$/;"	c	namespace:bliss
KStar	search_engines/kstar.cc	/^KStar::KStar(const options::Options &opts) 	$/;"	f	class:kstar::KStar
KStar	search_engines/kstar.h	/^class KStar : public top_k_eager_search::TopKEagerSearch $/;"	c	namespace:kstar
KeySet	open_lists/pareto_open_list.cc	/^    typedef set<KeyType> KeySet;$/;"	t	class:ParetoOpenList	file:
KeyType	open_lists/pareto_open_list.cc	/^    typedef vector<int> KeyType;$/;"	t	class:ParetoOpenList	file:
LANDMARKS_EXPLORATION_H	landmarks/exploration.h	2;"	d
LANDMARKS_LAMA_FF_SYNERGY_H	landmarks/lama_ff_synergy.h	2;"	d
LANDMARKS_LANDMARK_COST_ASSIGNMENT_H	landmarks/landmark_cost_assignment.h	2;"	d
LANDMARKS_LANDMARK_COUNT_HEURISTIC_H	landmarks/landmark_count_heuristic.h	2;"	d
LANDMARKS_LANDMARK_FACTORY_H	landmarks/landmark_factory.h	2;"	d
LANDMARKS_LANDMARK_FACTORY_H_M_H	landmarks/landmark_factory_h_m.h	2;"	d
LANDMARKS_LANDMARK_FACTORY_MERGED_H	landmarks/landmark_factory_merged.h	2;"	d
LANDMARKS_LANDMARK_FACTORY_RPG_EXHAUST_H	landmarks/landmark_factory_rpg_exhaust.h	2;"	d
LANDMARKS_LANDMARK_FACTORY_RPG_SASP_H	landmarks/landmark_factory_rpg_sasp.h	2;"	d
LANDMARKS_LANDMARK_FACTORY_ZHU_GIVAN_H	landmarks/landmark_factory_zhu_givan.h	2;"	d
LANDMARKS_LANDMARK_GRAPH_H	landmarks/landmark_graph.h	2;"	d
LANDMARKS_LANDMARK_STATUS_MANAGER_H	landmarks/landmark_status_manager.h	2;"	d
LANDMARKS_UTIL_H	landmarks/util.h	2;"	d
LEAF_NODE	cegar/refinement_hierarchy.h	/^    static const int LEAF_NODE = -1;$/;"	m	class:cegar::Node
LEAF_NODE	pdbs/match_tree.cc	/^    static const int LEAF_NODE = -1;$/;"	m	struct:pdbs::MatchTree::Node	file:
LEVEL	merge_and_shrink/merge_scoring_function_total_order.h	/^        LEVEL,$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder::AtomicTSOrder
LEVEL	variable_order_finder.h	/^    LEVEL,$/;"	e	enum:VariableOrderType
LINUX	utils/system.h	4;"	d
LMCutConstraints	operator_counting/lm_cut_constraints.h	/^class LMCutConstraints : public ConstraintGenerator {$/;"	c	namespace:operator_counting
LOW	merge_and_shrink/shrink_fh.h	/^    enum HighLow {HIGH, LOW};$/;"	e	enum:merge_and_shrink::ShrinkFH::HighLow
LPConstraint	lp/lp_solver.cc	/^LPConstraint::LPConstraint(double lower_bound, double upper_bound)$/;"	f	class:lp::LPConstraint
LPConstraint	lp/lp_solver.h	/^class LPConstraint {$/;"	c	namespace:lp
LPObjectiveSense	lp/lp_solver.h	/^enum class LPObjectiveSense {$/;"	c	namespace:lp
LPSolver	lp/lp_solver.cc	/^LPSolver::LPSolver(LPSolverType solver_type)$/;"	f	class:lp::LPSolver
LPSolver	lp/lp_solver.h	/^class LPSolver {$/;"	c	namespace:lp
LPSolverType	lp/lp_solver.h	/^enum class LPSolverType {$/;"	c	namespace:lp
LPVariable	lp/lp_solver.cc	/^LPVariable::LPVariable(double lower_bound, double upper_bound,$/;"	f	class:lp::LPVariable
LPVariable	lp/lp_solver.h	/^struct LPVariable {$/;"	s	namespace:lp
LP_LP_INTERNALS_H	lp/lp_internals.h	2;"	d
LP_LP_SOLVER_H	lp/lp_solver.h	2;"	d
LP_METHOD	lp/lp_solver.h	17;"	d
LP_METHOD	lp/lp_solver.h	19;"	d
Label	merge_and_shrink/labels.h	/^    explicit Label(int cost_)$/;"	f	class:merge_and_shrink::Label
Label	merge_and_shrink/labels.h	/^class Label {$/;"	c	namespace:merge_and_shrink
LabelEquivalenceRelation	merge_and_shrink/label_equivalence_relation.cc	/^LabelEquivalenceRelation::LabelEquivalenceRelation(const Labels &labels)$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
LabelEquivalenceRelation	merge_and_shrink/label_equivalence_relation.h	/^class LabelEquivalenceRelation {$/;"	c	namespace:merge_and_shrink
LabelGroup	merge_and_shrink/label_equivalence_relation.h	/^    LabelGroup() : cost(INF) {$/;"	f	class:merge_and_shrink::LabelGroup
LabelGroup	merge_and_shrink/label_equivalence_relation.h	/^class LabelGroup {$/;"	c	namespace:merge_and_shrink
LabelReduction	merge_and_shrink/label_reduction.cc	/^LabelReduction::LabelReduction(const Options &options)$/;"	f	class:merge_and_shrink::LabelReduction
LabelReduction	merge_and_shrink/label_reduction.h	/^class LabelReduction {$/;"	c	namespace:merge_and_shrink
LabelReductionMethod	merge_and_shrink/label_reduction.h	/^    enum LabelReductionMethod {$/;"	g	class:merge_and_shrink::LabelReduction
LabelReductionSystemOrder	merge_and_shrink/label_reduction.h	/^    enum LabelReductionSystemOrder {$/;"	g	class:merge_and_shrink::LabelReduction
Labels	merge_and_shrink/labels.cc	/^Labels::Labels(vector<unique_ptr<Label>> &&labels)$/;"	f	class:merge_and_shrink::Labels
Labels	merge_and_shrink/labels.h	/^class Labels {$/;"	c	namespace:merge_and_shrink
LamaFFSynergy	landmarks/lama_ff_synergy.cc	/^LamaFFSynergy::LamaFFSynergy(const Options &opts)$/;"	f	class:landmarks::LamaFFSynergy
LamaFFSynergy	landmarks/lama_ff_synergy.h	/^class LamaFFSynergy {$/;"	c	namespace:landmarks
LamaMasterHeuristic	landmarks/lama_ff_synergy.cc	/^    explicit LamaMasterHeuristic(LamaFFSynergy *synergy)$/;"	f	class:landmarks::LamaMasterHeuristic
LamaMasterHeuristic	landmarks/lama_ff_synergy.cc	/^class LamaMasterHeuristic : public Heuristic {$/;"	c	namespace:landmarks	file:
LandmarkCostAssignment	landmarks/landmark_cost_assignment.cc	/^LandmarkCostAssignment::LandmarkCostAssignment(const vector<int> &operator_costs,$/;"	f	class:landmarks::LandmarkCostAssignment
LandmarkCostAssignment	landmarks/landmark_cost_assignment.h	/^class LandmarkCostAssignment {$/;"	c	namespace:landmarks
LandmarkCountHeuristic	landmarks/landmark_count_heuristic.cc	/^LandmarkCountHeuristic::LandmarkCountHeuristic(const options::Options &opts)$/;"	f	class:landmarks::LandmarkCountHeuristic
LandmarkCountHeuristic	landmarks/landmark_count_heuristic.h	/^class LandmarkCountHeuristic : public Heuristic {$/;"	c	namespace:landmarks
LandmarkCutHeuristic	heuristics/lm_cut_heuristic.cc	/^LandmarkCutHeuristic::LandmarkCutHeuristic(const Options &opts)$/;"	f	class:lm_cut_heuristic::LandmarkCutHeuristic
LandmarkCutHeuristic	heuristics/lm_cut_heuristic.h	/^class LandmarkCutHeuristic : public Heuristic {$/;"	c	namespace:lm_cut_heuristic
LandmarkCutLandmarks	heuristics/lm_cut_landmarks.cc	/^LandmarkCutLandmarks::LandmarkCutLandmarks(const TaskProxy &task_proxy) {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
LandmarkCutLandmarks	heuristics/lm_cut_landmarks.h	/^class LandmarkCutLandmarks {$/;"	c	namespace:lm_cut_heuristic
LandmarkDecomposition	cegar/subtask_generators.cc	/^LandmarkDecomposition::LandmarkDecomposition(const Options &opts)$/;"	f	class:cegar::LandmarkDecomposition
LandmarkDecomposition	cegar/subtask_generators.h	/^class LandmarkDecomposition : public SubtaskGenerator {$/;"	c	namespace:cegar
LandmarkEfficientOptimalSharedCostAssignment	landmarks/landmark_cost_assignment.cc	/^LandmarkEfficientOptimalSharedCostAssignment::LandmarkEfficientOptimalSharedCostAssignment($/;"	f	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
LandmarkEfficientOptimalSharedCostAssignment	landmarks/landmark_cost_assignment.h	/^class LandmarkEfficientOptimalSharedCostAssignment : public LandmarkCostAssignment {$/;"	c	namespace:landmarks
LandmarkFactory	landmarks/landmark_factory.cc	/^LandmarkFactory::LandmarkFactory(const options::Options &opts)$/;"	f	class:landmarks::LandmarkFactory
LandmarkFactory	landmarks/landmark_factory.h	/^class LandmarkFactory {$/;"	c	namespace:landmarks
LandmarkFactoryHM	landmarks/landmark_factory_h_m.cc	/^LandmarkFactoryHM::LandmarkFactoryHM(const options::Options &opts)$/;"	f	class:landmarks::LandmarkFactoryHM
LandmarkFactoryHM	landmarks/landmark_factory_h_m.h	/^class LandmarkFactoryHM : public LandmarkFactory {$/;"	c	namespace:landmarks
LandmarkFactoryMerged	landmarks/landmark_factory_merged.cc	/^LandmarkFactoryMerged::LandmarkFactoryMerged(const Options &opts)$/;"	f	class:landmarks::LandmarkFactoryMerged
LandmarkFactoryMerged	landmarks/landmark_factory_merged.h	/^class LandmarkFactoryMerged : public LandmarkFactory {$/;"	c	namespace:landmarks
LandmarkFactoryRpgExhaust	landmarks/landmark_factory_rpg_exhaust.cc	/^LandmarkFactoryRpgExhaust::LandmarkFactoryRpgExhaust(const Options &opts)$/;"	f	class:landmarks::LandmarkFactoryRpgExhaust
LandmarkFactoryRpgExhaust	landmarks/landmark_factory_rpg_exhaust.h	/^class LandmarkFactoryRpgExhaust : public LandmarkFactory {$/;"	c	namespace:landmarks
LandmarkFactoryRpgSasp	landmarks/landmark_factory_rpg_sasp.cc	/^LandmarkFactoryRpgSasp::LandmarkFactoryRpgSasp(const Options &opts)$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
LandmarkFactoryRpgSasp	landmarks/landmark_factory_rpg_sasp.h	/^class LandmarkFactoryRpgSasp : public LandmarkFactory {$/;"	c	namespace:landmarks
LandmarkFactoryZhuGivan	landmarks/landmark_factory_zhu_givan.cc	/^LandmarkFactoryZhuGivan::LandmarkFactoryZhuGivan(const Options &opts)$/;"	f	class:landmarks::LandmarkFactoryZhuGivan
LandmarkFactoryZhuGivan	landmarks/landmark_factory_zhu_givan.h	/^class LandmarkFactoryZhuGivan : public LandmarkFactory {$/;"	c	namespace:landmarks
LandmarkGraph	landmarks/landmark_graph.cc	/^LandmarkGraph::LandmarkGraph(const TaskProxy &task_proxy)$/;"	f	class:landmarks::LandmarkGraph
LandmarkGraph	landmarks/landmark_graph.h	/^class LandmarkGraph {$/;"	c	class:landmarks::EdgeType
LandmarkNode	landmarks/landmark_graph.h	/^    LandmarkNode(std::vector<FactPair> &facts, bool disj, bool conj = false)$/;"	f	class:landmarks::EdgeType::LandmarkNode
LandmarkNode	landmarks/landmark_graph.h	/^class LandmarkNode {$/;"	c	class:landmarks::EdgeType
LandmarkNodeComparer	landmarks/landmark_graph.h	/^struct LandmarkNodeComparer {$/;"	s	class:landmarks::EdgeType
LandmarkStatusManager	landmarks/landmark_status_manager.cc	/^LandmarkStatusManager::LandmarkStatusManager(LandmarkGraph &graph)$/;"	f	class:landmarks::LandmarkStatusManager
LandmarkStatusManager	landmarks/landmark_status_manager.h	/^class LandmarkStatusManager {$/;"	c	namespace:landmarks
LandmarkUniformSharedCostAssignment	landmarks/landmark_cost_assignment.cc	/^LandmarkUniformSharedCostAssignment::LandmarkUniformSharedCostAssignment($/;"	f	class:landmarks::LandmarkUniformSharedCostAssignment
LandmarkUniformSharedCostAssignment	landmarks/landmark_cost_assignment.h	/^class LandmarkUniformSharedCostAssignment : public LandmarkCostAssignment {$/;"	c	namespace:landmarks
LanguageSupportInfo	options/doc_store.h	/^    LanguageSupportInfo(std::string feat, std::string descr)$/;"	f	struct:options::LanguageSupportInfo
LanguageSupportInfo	options/doc_store.h	/^struct LanguageSupportInfo {$/;"	s	namespace:options
LazySearch	search_engines/lazy_search.cc	/^LazySearch::LazySearch(const Options &opts)$/;"	f	class:lazy_search::LazySearch
LazySearch	search_engines/lazy_search.h	/^class LazySearch : public SearchEngine {$/;"	c	namespace:lazy_search
LocalAssignment	domain_transition_graph.h	/^    LocalAssignment(int var, int val)$/;"	f	struct:LocalAssignment
LocalAssignment	domain_transition_graph.h	/^struct LocalAssignment {$/;"	s
LocalProblem	heuristics/cea_heuristic.cc	/^    LocalProblem()$/;"	f	struct:cea_heuristic::LocalProblem
LocalProblem	heuristics/cea_heuristic.cc	/^struct LocalProblem {$/;"	s	namespace:cea_heuristic	file:
LocalProblemNode	heuristics/cea_heuristic.cc	/^    LocalProblemNode(LocalProblem *owner_, int context_size)$/;"	f	struct:cea_heuristic::LocalProblemNode
LocalProblemNode	heuristics/cea_heuristic.cc	/^struct LocalProblemNode {$/;"	s	namespace:cea_heuristic	file:
LocalTransition	heuristics/cea_heuristic.cc	/^    LocalTransition($/;"	f	struct:cea_heuristic::LocalTransition
LocalTransition	heuristics/cea_heuristic.cc	/^struct LocalTransition {$/;"	s	namespace:cea_heuristic	file:
Log	utils/logging.h	/^struct Log {$/;"	s	namespace:utils
MAXIMIZE	lp/lp_solver.h	/^    MAXIMIZE, MINIMIZE$/;"	m	class:lp::LPObjectiveSense
MAX_COST_VALUE	heuristics/additive_heuristic.h	/^    static const int MAX_COST_VALUE = 100000000;$/;"	m	class:additive_heuristic::AdditiveHeuristic
MAX_COST_VALUE	landmarks/exploration.h	/^    static const int MAX_COST_VALUE = 100000000; \/\/ See additive_heuristic.h.$/;"	m	class:landmarks::Exploration
MAX_OPERATOR_COST	operator_cost.h	/^enum OperatorCost {NORMAL = 0, ONE = 1, PLUSONE = 2, MAX_OPERATOR_COST};$/;"	e	enum:OperatorCost
MAX_REFINED	cegar/split_selector.h	/^    MAX_REFINED,$/;"	m	class:cegar::PickSplit
MAX_UNWANTED	cegar/split_selector.h	/^    MAX_UNWANTED,$/;"	m	class:cegar::PickSplit
MAX_VALUE	structural_symmetries/graph_creator.cc	/^              CONDITIONAL_DELETE_EFFECT_VERTEX, MAX_VALUE};$/;"	e	enum:color_t	file:
MAYBE	bliss/graph.cc	/^  static const char MAYBE = 0;$/;"	m	class:bliss::TreeNode	file:
MEM_FIELD_WIDTH	utils/logging.cc	/^    static const int MEM_FIELD_WIDTH = 7;$/;"	m	class:utils::MemoryTracer	file:
MERGE_AND_SHRINK_DISTANCES_H	merge_and_shrink/distances.h	2;"	d
MERGE_AND_SHRINK_FACTORED_TRANSITION_SYSTEM_H	merge_and_shrink/factored_transition_system.h	2;"	d
MERGE_AND_SHRINK_FTS_FACTORY_H	merge_and_shrink/fts_factory.h	2;"	d
MERGE_AND_SHRINK_LABELS_H	merge_and_shrink/labels.h	2;"	d
MERGE_AND_SHRINK_LABEL_EQUIVALENCE_RELATION_H	merge_and_shrink/label_equivalence_relation.h	2;"	d
MERGE_AND_SHRINK_LABEL_REDUCTION_H	merge_and_shrink/label_reduction.h	2;"	d
MERGE_AND_SHRINK_MERGE_AND_SHRINK_HEURISTIC_H	merge_and_shrink/merge_and_shrink_heuristic.h	2;"	d
MERGE_AND_SHRINK_MERGE_AND_SHRINK_REPRESENTATION_H	merge_and_shrink/merge_and_shrink_representation.h	2;"	d
MERGE_AND_SHRINK_MERGE_SCORING_FUNCTION_DFP_H	merge_and_shrink/merge_scoring_function_dfp.h	2;"	d
MERGE_AND_SHRINK_MERGE_SCORING_FUNCTION_GOAL_RELEVANCE_H	merge_and_shrink/merge_scoring_function_goal_relevance.h	2;"	d
MERGE_AND_SHRINK_MERGE_SCORING_FUNCTION_H	merge_and_shrink/merge_scoring_function.h	2;"	d
MERGE_AND_SHRINK_MERGE_SCORING_FUNCTION_SINGLE_RANDOM_H	merge_and_shrink/merge_scoring_function_single_random.h	2;"	d
MERGE_AND_SHRINK_MERGE_SCORING_FUNCTION_TOTAL_ORDER_H	merge_and_shrink/merge_scoring_function_total_order.h	2;"	d
MERGE_AND_SHRINK_MERGE_SELECTOR_H	merge_and_shrink/merge_selector.h	2;"	d
MERGE_AND_SHRINK_MERGE_SELECTOR_SCORE_BASED_FILTERING_H	merge_and_shrink/merge_selector_score_based_filtering.h	2;"	d
MERGE_AND_SHRINK_MERGE_STRATEGY_FACTORY_H	merge_and_shrink/merge_strategy_factory.h	2;"	d
MERGE_AND_SHRINK_MERGE_STRATEGY_FACTORY_PRECOMPUTED_H	merge_and_shrink/merge_strategy_factory_precomputed.h	2;"	d
MERGE_AND_SHRINK_MERGE_STRATEGY_FACTORY_STATELESS_H	merge_and_shrink/merge_strategy_factory_stateless.h	2;"	d
MERGE_AND_SHRINK_MERGE_STRATEGY_H	merge_and_shrink/merge_strategy.h	2;"	d
MERGE_AND_SHRINK_MERGE_STRATEGY_PRECOMPUTED_H	merge_and_shrink/merge_strategy_precomputed.h	2;"	d
MERGE_AND_SHRINK_MERGE_STRATEGY_STATELESS_H	merge_and_shrink/merge_strategy_stateless.h	2;"	d
MERGE_AND_SHRINK_MERGE_TREE_FACTORY_H	merge_and_shrink/merge_tree_factory.h	2;"	d
MERGE_AND_SHRINK_MERGE_TREE_FACTORY_LINEAR_H	merge_and_shrink/merge_tree_factory_linear.h	2;"	d
MERGE_AND_SHRINK_MERGE_TREE_H	merge_and_shrink/merge_tree.h	2;"	d
MERGE_AND_SHRINK_SHRINK_BISIMULATION_H	merge_and_shrink/shrink_bisimulation.h	2;"	d
MERGE_AND_SHRINK_SHRINK_BUCKET_BASED_H	merge_and_shrink/shrink_bucket_based.h	2;"	d
MERGE_AND_SHRINK_SHRINK_FH_H	merge_and_shrink/shrink_fh.h	2;"	d
MERGE_AND_SHRINK_SHRINK_RANDOM_H	merge_and_shrink/shrink_random.h	2;"	d
MERGE_AND_SHRINK_SHRINK_STRATEGY_H	merge_and_shrink/shrink_strategy.h	2;"	d
MERGE_AND_SHRINK_TRANSITION_SYSTEM_H	merge_and_shrink/transition_system.h	2;"	d
MERGE_AND_SHRINK_TYPES_H	merge_and_shrink/types.h	2;"	d
MERGE_AND_SHRINK_UTILS_H	merge_and_shrink/utils.h	2;"	d
MINUSINF	merge_and_shrink/types.cc	/^const int MINUSINF = numeric_limits<int>::min();$/;"	m	namespace:merge_and_shrink	file:
MIN_BUCKETS_BEFORE_SWITCH	algorithms/priority_queues.h	/^    static const int MIN_BUCKETS_BEFORE_SWITCH = 100;$/;"	m	class:priority_queues::BucketQueue
MIN_HADD	cegar/split_selector.h	/^    MIN_HADD,$/;"	m	class:cegar::PickSplit
MIN_REFINED	cegar/split_selector.h	/^    MIN_REFINED,$/;"	m	class:cegar::PickSplit
MIN_UNWANTED	cegar/split_selector.h	/^    MIN_UNWANTED,$/;"	m	class:cegar::PickSplit
MatchTree	pdbs/match_tree.cc	/^MatchTree::MatchTree(const TaskProxy &task_proxy,$/;"	f	class:pdbs::MatchTree
MatchTree	pdbs/match_tree.h	/^class MatchTree {$/;"	c	namespace:pdbs
MaxCliqueComputer	algorithms/max_cliques.cc	/^    MaxCliqueComputer(const vector<vector<int>> &graph_,$/;"	f	class:max_cliques::MaxCliqueComputer
MaxCliqueComputer	algorithms/max_cliques.cc	/^class MaxCliqueComputer {$/;"	c	namespace:max_cliques	file:
MaxEvaluator	evaluators/max_evaluator.cc	/^MaxEvaluator::MaxEvaluator(const Options &opts)$/;"	f	class:max_evaluator::MaxEvaluator
MaxEvaluator	evaluators/max_evaluator.h	/^class MaxEvaluator : public combining_evaluator::CombiningEvaluator {$/;"	c	namespace:max_evaluator
MemoryTracer	utils/logging.cc	/^MemoryTracer::MemoryTracer() {$/;"	f	class:utils::MemoryTracer
MemoryTracer	utils/logging.cc	/^class MemoryTracer {$/;"	c	namespace:utils	file:
MergeAndShrinkHeuristic	merge_and_shrink/merge_and_shrink_heuristic.cc	/^MergeAndShrinkHeuristic::MergeAndShrinkHeuristic(const Options &opts)$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
MergeAndShrinkHeuristic	merge_and_shrink/merge_and_shrink_heuristic.h	/^class MergeAndShrinkHeuristic : public Heuristic {$/;"	c	namespace:merge_and_shrink
MergeAndShrinkRepresentation	merge_and_shrink/merge_and_shrink_representation.cc	/^MergeAndShrinkRepresentation::MergeAndShrinkRepresentation(int domain_size)$/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentation
MergeAndShrinkRepresentation	merge_and_shrink/merge_and_shrink_representation.h	/^class MergeAndShrinkRepresentation {$/;"	c	namespace:merge_and_shrink
MergeAndShrinkRepresentationLeaf	merge_and_shrink/merge_and_shrink_representation.cc	/^MergeAndShrinkRepresentationLeaf::MergeAndShrinkRepresentationLeaf($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
MergeAndShrinkRepresentationLeaf	merge_and_shrink/merge_and_shrink_representation.h	/^class MergeAndShrinkRepresentationLeaf : public MergeAndShrinkRepresentation {$/;"	c	namespace:merge_and_shrink
MergeAndShrinkRepresentationMerge	merge_and_shrink/merge_and_shrink_representation.cc	/^MergeAndShrinkRepresentationMerge::MergeAndShrinkRepresentationMerge($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
MergeAndShrinkRepresentationMerge	merge_and_shrink/merge_and_shrink_representation.h	/^class MergeAndShrinkRepresentationMerge : public MergeAndShrinkRepresentation {$/;"	c	namespace:merge_and_shrink
MergeScoringFunction	merge_and_shrink/merge_scoring_function.cc	/^MergeScoringFunction::MergeScoringFunction()$/;"	f	class:merge_and_shrink::MergeScoringFunction
MergeScoringFunction	merge_and_shrink/merge_scoring_function.h	/^class MergeScoringFunction {$/;"	c	namespace:merge_and_shrink
MergeScoringFunctionDFP	merge_and_shrink/merge_scoring_function_dfp.h	/^class MergeScoringFunctionDFP : public MergeScoringFunction {$/;"	c	namespace:merge_and_shrink
MergeScoringFunctionGoalRelevance	merge_and_shrink/merge_scoring_function_goal_relevance.h	/^class MergeScoringFunctionGoalRelevance : public MergeScoringFunction {$/;"	c	namespace:merge_and_shrink
MergeScoringFunctionSingleRandom	merge_and_shrink/merge_scoring_function_single_random.cc	/^MergeScoringFunctionSingleRandom::MergeScoringFunctionSingleRandom($/;"	f	class:merge_and_shrink::MergeScoringFunctionSingleRandom
MergeScoringFunctionSingleRandom	merge_and_shrink/merge_scoring_function_single_random.h	/^class MergeScoringFunctionSingleRandom : public MergeScoringFunction {$/;"	c	namespace:merge_and_shrink
MergeScoringFunctionTotalOrder	merge_and_shrink/merge_scoring_function_total_order.cc	/^MergeScoringFunctionTotalOrder::MergeScoringFunctionTotalOrder($/;"	f	class:merge_and_shrink::MergeScoringFunctionTotalOrder
MergeScoringFunctionTotalOrder	merge_and_shrink/merge_scoring_function_total_order.h	/^class MergeScoringFunctionTotalOrder : public MergeScoringFunction {$/;"	c	namespace:merge_and_shrink
MergeSelector	merge_and_shrink/merge_selector.h	/^class MergeSelector {$/;"	c	namespace:merge_and_shrink
MergeSelectorScoreBasedFiltering	merge_and_shrink/merge_selector_score_based_filtering.cc	/^MergeSelectorScoreBasedFiltering::MergeSelectorScoreBasedFiltering($/;"	f	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
MergeSelectorScoreBasedFiltering	merge_and_shrink/merge_selector_score_based_filtering.h	/^class MergeSelectorScoreBasedFiltering : public MergeSelector {$/;"	c	namespace:merge_and_shrink
MergeStrategy	merge_and_shrink/merge_strategy.cc	/^MergeStrategy::MergeStrategy($/;"	f	class:merge_and_shrink::MergeStrategy
MergeStrategy	merge_and_shrink/merge_strategy.h	/^class MergeStrategy {$/;"	c	namespace:merge_and_shrink
MergeStrategyFactory	merge_and_shrink/merge_strategy_factory.h	/^class MergeStrategyFactory {$/;"	c	namespace:merge_and_shrink
MergeStrategyFactoryPrecomputed	merge_and_shrink/merge_strategy_factory_precomputed.cc	/^MergeStrategyFactoryPrecomputed::MergeStrategyFactoryPrecomputed($/;"	f	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
MergeStrategyFactoryPrecomputed	merge_and_shrink/merge_strategy_factory_precomputed.h	/^class MergeStrategyFactoryPrecomputed : public MergeStrategyFactory {$/;"	c	namespace:merge_and_shrink
MergeStrategyFactoryStateless	merge_and_shrink/merge_strategy_factory_stateless.cc	/^MergeStrategyFactoryStateless::MergeStrategyFactoryStateless($/;"	f	class:merge_and_shrink::MergeStrategyFactoryStateless
MergeStrategyFactoryStateless	merge_and_shrink/merge_strategy_factory_stateless.h	/^class MergeStrategyFactoryStateless : public MergeStrategyFactory {$/;"	c	namespace:merge_and_shrink
MergeStrategyPrecomputed	merge_and_shrink/merge_strategy_precomputed.cc	/^MergeStrategyPrecomputed::MergeStrategyPrecomputed($/;"	f	class:merge_and_shrink::MergeStrategyPrecomputed
MergeStrategyPrecomputed	merge_and_shrink/merge_strategy_precomputed.h	/^class MergeStrategyPrecomputed : public MergeStrategy {$/;"	c	namespace:merge_and_shrink
MergeStrategyStateless	merge_and_shrink/merge_strategy_stateless.cc	/^MergeStrategyStateless::MergeStrategyStateless($/;"	f	class:merge_and_shrink::MergeStrategyStateless
MergeStrategyStateless	merge_and_shrink/merge_strategy_stateless.h	/^class MergeStrategyStateless : public MergeStrategy {$/;"	c	namespace:merge_and_shrink
MergeTree	merge_and_shrink/merge_tree.cc	/^MergeTree::MergeTree($/;"	f	class:merge_and_shrink::MergeTree
MergeTree	merge_and_shrink/merge_tree.h	/^class MergeTree {$/;"	c	namespace:merge_and_shrink
MergeTreeFactory	merge_and_shrink/merge_tree_factory.cc	/^MergeTreeFactory::MergeTreeFactory(const options::Options &options)$/;"	f	class:merge_and_shrink::MergeTreeFactory
MergeTreeFactory	merge_and_shrink/merge_tree_factory.h	/^class MergeTreeFactory {$/;"	c	namespace:merge_and_shrink
MergeTreeFactoryLinear	merge_and_shrink/merge_tree_factory_linear.cc	/^MergeTreeFactoryLinear::MergeTreeFactoryLinear(const options::Options &options)$/;"	f	class:merge_and_shrink::MergeTreeFactoryLinear
MergeTreeFactoryLinear	merge_and_shrink/merge_tree_factory_linear.h	/^class MergeTreeFactoryLinear : public MergeTreeFactory {$/;"	c	namespace:merge_and_shrink
MergeTreeNode	merge_and_shrink/merge_tree.cc	/^MergeTreeNode::MergeTreeNode($/;"	f	class:merge_and_shrink::MergeTreeNode
MergeTreeNode	merge_and_shrink/merge_tree.cc	/^MergeTreeNode::MergeTreeNode(const MergeTreeNode &other)$/;"	f	class:merge_and_shrink::MergeTreeNode
MergeTreeNode	merge_and_shrink/merge_tree.cc	/^MergeTreeNode::MergeTreeNode(int ts_index)$/;"	f	class:merge_and_shrink::MergeTreeNode
MergeTreeNode	merge_and_shrink/merge_tree.h	/^struct MergeTreeNode {$/;"	s	namespace:merge_and_shrink
ModifiedGoalsTask	tasks/modified_goals_task.cc	/^ModifiedGoalsTask::ModifiedGoalsTask($/;"	f	class:extra_tasks::ModifiedGoalsTask
ModifiedGoalsTask	tasks/modified_goals_task.h	/^class ModifiedGoalsTask : public tasks::DelegatingTask {$/;"	c	namespace:extra_tasks
ModifiedOperatorCostsTask	tasks/modified_operator_costs_task.cc	/^ModifiedOperatorCostsTask::ModifiedOperatorCostsTask($/;"	f	class:extra_tasks::ModifiedOperatorCostsTask
ModifiedOperatorCostsTask	tasks/modified_operator_costs_task.h	/^class ModifiedOperatorCostsTask : public tasks::DelegatingTask {$/;"	c	namespace:extra_tasks
N	bliss/heap.h	/^  unsigned int N;$/;"	m	class:bliss::Heap
N	bliss/partition.h	/^  unsigned int N;$/;"	m	class:bliss::Partition
NEW	search_node_info.h	/^    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};$/;"	e	enum:SearchNodeInfo::NodeStatus
NEW_SORT1	bliss/partition.cc	461;"	d	file:
NEW_TO_OLD	merge_and_shrink/merge_scoring_function_total_order.h	/^        NEW_TO_OLD,$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder::ProductTSOrder
NO	bliss/graph.cc	/^  static const char NO = -1;$/;"	m	class:bliss::TreeNode	file:
NOEXCEPT	utils/language.h	13;"	d
NOEXCEPT	utils/language.h	15;"	d
NOMINMAX	utils/system_windows.h	6;"	d
NONE	options/option_parser.cc	/^const string OptionParser::NONE = "<none>";$/;"	m	class:options::OptionParser	file:
NONE	options/option_parser.h	/^    static const std::string NONE;$/;"	m	class:options::OptionParser
NONE	structural_symmetries/group.h	/^    NONE,$/;"	m	class:SearchSymmetries
NONE	structural_symmetries/group.h	/^    NONE,$/;"	m	class:SymmetricalLookups
NORMAL	merge_and_shrink/types.h	/^    NORMAL,$/;"	m	class:merge_and_shrink::Verbosity
NORMAL	operator_cost.h	/^enum OperatorCost {NORMAL = 0, ONE = 1, PLUSONE = 2, MAX_OPERATOR_COST};$/;"	e	enum:OperatorCost
NOT_COMPUTED	heuristics/cg_cache.cc	/^const int CGCache::NOT_COMPUTED;$/;"	m	class:cg_heuristic::CGCache	file:
NOT_COMPUTED	heuristics/cg_cache.h	/^    static const int NOT_COMPUTED = -2;$/;"	m	class:cg_heuristic::CGCache
NO_RETURN	utils/language.h	5;"	d
NO_RETURN	utils/language.h	7;"	d
NO_VALUE	heuristic.h	/^    enum {DEAD_END = -1, NO_VALUE = -2};$/;"	e	enum:Heuristic::__anon4
NegationByFailureInfo	axioms.h	/^        NegationByFailureInfo(int var, AxiomLiteral *lit)$/;"	f	struct:AxiomEvaluator::NegationByFailureInfo
NegationByFailureInfo	axioms.h	/^    struct NegationByFailureInfo {$/;"	s	class:AxiomEvaluator
Node	cegar/refinement_hierarchy.cc	/^Node::Node()$/;"	f	class:cegar::Node
Node	cegar/refinement_hierarchy.h	/^class Node {$/;"	c	namespace:cegar
Node	pdbs/match_tree.cc	/^MatchTree::Node::Node()$/;"	f	class:pdbs::MatchTree::Node
Node	pdbs/match_tree.cc	/^struct MatchTree::Node {$/;"	s	class:pdbs::MatchTree	file:
NodeStatus	search_node_info.h	/^    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};$/;"	g	struct:SearchNodeInfo
NoteInfo	options/doc_store.h	/^    NoteInfo(std::string n, std::string descr, bool long_text_)$/;"	f	struct:options::NoteInfo
NoteInfo	options/doc_store.h	/^struct NoteInfo {$/;"	s	namespace:options
NullPruningMethod	pruning/null_pruning_method.h	/^class NullPruningMethod : public PruningMethod {$/;"	c	namespace:null_pruning_method
OLD_TO_NEW	merge_and_shrink/merge_scoring_function_total_order.h	/^        OLD_TO_NEW,$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder::ProductTSOrder
ONE	operator_cost.h	/^enum OperatorCost {NORMAL = 0, ONE = 1, PLUSONE = 2, MAX_OPERATOR_COST};$/;"	e	enum:OperatorCost
ONE_STATE	structural_symmetries/group.h	/^    ONE_STATE,$/;"	m	class:SymmetricalLookups
OPEN	search_node_info.h	/^    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};$/;"	e	enum:SearchNodeInfo::NodeStatus
OPEN_LISTS_ALTERNATION_OPEN_LIST_H	open_lists/alternation_open_list.h	2;"	d
OPEN_LISTS_EPSILON_GREEDY_OPEN_LIST_H	open_lists/epsilon_greedy_open_list.h	2;"	d
OPEN_LISTS_OPEN_LIST_FACTORY_H	open_lists/open_list_factory.h	2;"	d
OPEN_LISTS_OPEN_LIST_H	open_lists/open_list.h	2;"	d
OPEN_LISTS_PARETO_OPEN_LIST_H	open_lists/pareto_open_list.h	2;"	d
OPEN_LISTS_STANDARD_SCALAR_OPEN_LIST_H	open_lists/standard_scalar_open_list.h	2;"	d
OPEN_LISTS_TIEBREAKING_OPEN_LIST_H	open_lists/tiebreaking_open_list.h	2;"	d
OPEN_LISTS_TYPE_BASED_OPEN_LIST_H	open_lists/type_based_open_list.h	2;"	d
OPERATING_SYSTEM	utils/system.h	12;"	d
OPERATING_SYSTEM	utils/system.h	15;"	d
OPERATING_SYSTEM	utils/system.h	9;"	d
OPERATOR_COST_H	operator_cost.h	2;"	d
OPERATOR_COUNTING_CONSTRAINT_GENERATOR_H	operator_counting/constraint_generator.h	2;"	d
OPERATOR_COUNTING_LM_CUT_CONSTRAINTS_H	operator_counting/lm_cut_constraints.h	2;"	d
OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H	operator_counting/operator_counting_heuristic.h	2;"	d
OPERATOR_COUNTING_PHO_CONSTRAINTS_H	operator_counting/pho_constraints.h	2;"	d
OPERATOR_COUNTING_STATE_EQUATION_CONSTRAINTS_H	operator_counting/state_equation_constraints.h	2;"	d
OPTIONS_ANY_H	options/any.h	2;"	d
OPTIONS_BOUNDS_H	options/bounds.h	2;"	d
OPTIONS_DOC_PRINTER_H	options/doc_printer.h	2;"	d
OPTIONS_DOC_STORE_H	options/doc_store.h	2;"	d
OPTIONS_ERRORS_H	options/errors.h	2;"	d
OPTIONS_OPTIONS_H	options/options.h	2;"	d
OPTIONS_OPTION_PARSER_H	options/option_parser.h	2;"	d
OPTIONS_PARSE_TREE_H	options/parse_tree.h	2;"	d
OPTIONS_PLUGIN_H	options/plugin.h	2;"	d
OPTIONS_PREDEFINITIONS_H	options/predefinitions.h	2;"	d
OPTIONS_REGISTRIES_H	options/registries.h	2;"	d
OPTIONS_SYNERGY_H	options/synergy.h	2;"	d
OPTIONS_TOKEN_PARSER_H	options/token_parser.h	2;"	d
OPTIONS_TYPE_DOCUMENTER_H	options/type_documenter.h	2;"	d
OPTIONS_TYPE_NAMER_H	options/type_namer.h	2;"	d
OPTION_PARSER_H	option_parser.h	2;"	d
OPTION_PARSER_UTIL_H	option_parser_util.h	2;"	d
ORIGINAL	cegar/subtask_generators.h	/^    ORIGINAL,$/;"	m	class:cegar::FactOrder
OSS	structural_symmetries/group.h	/^    OSS,$/;"	m	class:SearchSymmetries
OSX	utils/system.h	5;"	d
OUT_OF_MEMORY	utils/system.h	/^    OUT_OF_MEMORY = 6$/;"	m	class:utils::ExitCode
OpenList	open_lists/open_list.h	/^OpenList<Entry>::OpenList(bool only_preferred)$/;"	f	class:OpenList
OpenList	open_lists/open_list.h	/^class OpenList {$/;"	c
OpenListFactory	open_lists/open_list_factory.h	/^class OpenListFactory {$/;"	c
OperatorCost	operator_cost.h	/^enum OperatorCost {NORMAL = 0, ONE = 1, PLUSONE = 2, MAX_OPERATOR_COST};$/;"	g
OperatorCountingHeuristic	operator_counting/operator_counting_heuristic.cc	/^OperatorCountingHeuristic::OperatorCountingHeuristic(const Options &opts)$/;"	f	class:operator_counting::OperatorCountingHeuristic
OperatorCountingHeuristic	operator_counting/operator_counting_heuristic.h	/^class OperatorCountingHeuristic : public Heuristic {$/;"	c	namespace:operator_counting
OperatorPermutation	structural_symmetries/operator_permutation.cc	/^OperatorPermutation::OperatorPermutation(const Permutation& permutation){$/;"	f	class:OperatorPermutation
OperatorPermutation	structural_symmetries/operator_permutation.cc	/^OperatorPermutation::OperatorPermutation(const unsigned int* full_permutation){$/;"	f	class:OperatorPermutation
OperatorPermutation	structural_symmetries/operator_permutation.h	/^class OperatorPermutation {$/;"	c
OperatorProxy	task_proxy.h	/^    OperatorProxy(const AbstractTask &task, int index, bool is_axiom)$/;"	f	class:OperatorProxy
OperatorProxy	task_proxy.h	/^class OperatorProxy {$/;"	c
OperatorsProxy	task_proxy.h	/^    explicit OperatorsProxy(const AbstractTask &task)$/;"	f	class:OperatorsProxy
OperatorsProxy	task_proxy.h	/^class OperatorsProxy {$/;"	c
OptimizeFor	potentials/single_potential_heuristics.cc	/^enum class OptimizeFor {$/;"	c	namespace:potentials	file:
OptionParser	options/option_parser.cc	/^OptionParser::OptionParser(ParseTree pt, bool dr)$/;"	f	class:options::OptionParser
OptionParser	options/option_parser.cc	/^OptionParser::OptionParser(const string config, bool dr)$/;"	f	class:options::OptionParser
OptionParser	options/option_parser.h	/^class OptionParser {$/;"	c	namespace:options
Options	options/options.h	/^    Options(bool hm = false)$/;"	f	class:options::Options
Options	options/options.h	/^class Options {$/;"	c	namespace:options
Orbit	bliss/orbit.cc	/^Orbit::Orbit()$/;"	f	class:bliss::Orbit
Orbit	bliss/orbit.h	/^class Orbit$/;"	c	namespace:bliss
OrbitEntry	bliss/orbit.h	/^  class OrbitEntry$/;"	c	class:bliss::Orbit
OrderedSet	algorithms/ordered_set.h	/^class OrderedSet {$/;"	c	namespace:ordered_set
PDBHeuristic	pdbs/pdb_heuristic.cc	/^PDBHeuristic::PDBHeuristic(const Options &opts)$/;"	f	class:pdbs::PDBHeuristic
PDBHeuristic	pdbs/pdb_heuristic.h	/^class PDBHeuristic : public Heuristic {$/;"	c	namespace:pdbs
PDBS_CANONICAL_PDBS_H	pdbs/canonical_pdbs.h	2;"	d
PDBS_CANONICAL_PDBS_HEURISTIC_H	pdbs/canonical_pdbs_heuristic.h	2;"	d
PDBS_DOMINANCE_PRUNING_H	pdbs/dominance_pruning.h	2;"	d
PDBS_INCREMENTAL_CANONICAL_PDBS_H	pdbs/incremental_canonical_pdbs.h	2;"	d
PDBS_MATCH_TREE_H	pdbs/match_tree.h	2;"	d
PDBS_MAX_ADDITIVE_PDB_SETS_H	pdbs/max_additive_pdb_sets.h	2;"	d
PDBS_PATTERN_COLLECTION_GENERATOR_COMBO_H	pdbs/pattern_collection_generator_combo.h	2;"	d
PDBS_PATTERN_COLLECTION_GENERATOR_GENETIC_H	pdbs/pattern_collection_generator_genetic.h	2;"	d
PDBS_PATTERN_COLLECTION_GENERATOR_HILLCLIMBING_H	pdbs/pattern_collection_generator_hillclimbing.h	2;"	d
PDBS_PATTERN_COLLECTION_GENERATOR_MANUAL_H	pdbs/pattern_collection_generator_manual.h	2;"	d
PDBS_PATTERN_COLLECTION_GENERATOR_SYSTEMATIC_H	pdbs/pattern_collection_generator_systematic.h	2;"	d
PDBS_PATTERN_COLLECTION_INFORMATION_H	pdbs/pattern_collection_information.h	2;"	d
PDBS_PATTERN_DATABASE_H	pdbs/pattern_database.h	2;"	d
PDBS_PATTERN_GENERATOR_GREEDY_H	pdbs/pattern_generator_greedy.h	2;"	d
PDBS_PATTERN_GENERATOR_H	pdbs/pattern_generator.h	2;"	d
PDBS_PATTERN_GENERATOR_MANUAL_H	pdbs/pattern_generator_manual.h	2;"	d
PDBS_PDB_HEURISTIC_H	pdbs/pdb_heuristic.h	2;"	d
PDBS_TYPES_H	pdbs/types.h	2;"	d
PDBS_VALIDATION_H	pdbs/validation.h	2;"	d
PDBS_ZERO_ONE_PDBS_H	pdbs/zero_one_pdbs.h	2;"	d
PDBS_ZERO_ONE_PDBS_HEURISTIC_H	pdbs/zero_one_pdbs_heuristic.h	2;"	d
PER_STATE_INFORMATION_H	per_state_information.h	2;"	d
PLAN_FOUND	utils/system.h	/^    PLAN_FOUND = 0,$/;"	m	class:utils::ExitCode
PLUGIN_H	plugin.h	2;"	d
PLUSONE	operator_cost.h	/^enum OperatorCost {NORMAL = 0, ONE = 1, PLUSONE = 2, MAX_OPERATOR_COST};$/;"	e	enum:OperatorCost
PMOp	landmarks/landmark_factory_h_m.h	/^struct PMOp {$/;"	s	namespace:landmarks
POTENTIALS_DIVERSE_POTENTIAL_HEURISTICS_H	potentials/diverse_potential_heuristics.h	2;"	d
POTENTIALS_POTENTIAL_FUNCTION_H	potentials/potential_function.h	2;"	d
POTENTIALS_POTENTIAL_HEURISTIC_H	potentials/potential_heuristic.h	2;"	d
POTENTIALS_POTENTIAL_MAX_HEURISTIC_H	potentials/potential_max_heuristic.h	2;"	d
POTENTIALS_POTENTIAL_OPTIMIZER_H	potentials/potential_optimizer.h	2;"	d
POTENTIALS_UTIL_H	potentials/util.h	2;"	d
PRECOND_VERTEX	structural_symmetries/graph_creator.cc	/^enum color_t {PREDICATE_VERTEX, VALUE_VERTEX, PRECOND_VERTEX, EFFECT_VERTEX,$/;"	e	enum:color_t	file:
PREDICATE_VERTEX	structural_symmetries/graph_creator.cc	/^enum color_t {PREDICATE_VERTEX, VALUE_VERTEX, PRECOND_VERTEX, EFFECT_VERTEX,$/;"	e	enum:color_t	file:
PRE_FILE_VERSION	globals.cc	/^const int PRE_FILE_VERSION = 3;$/;"	v
PRUNED_STATE	merge_and_shrink/types.cc	/^const int PRUNED_STATE = -1;$/;"	m	namespace:merge_and_shrink	file:
PRUNE_BY_PREFERRED	search_engines/enforced_hill_climbing_search.h	/^    PRUNE_BY_PREFERRED,$/;"	m	class:enforced_hill_climbing_search::PreferredUsage
PRUNING_METHOD_H	pruning_method.h	2;"	d
PRUNING_NULL_PRUNING_METHOD_H	pruning/null_pruning_method.h	2;"	d
PRUNING_STUBBORN_SETS_EC_H	pruning/stubborn_sets_ec.h	2;"	d
PRUNING_STUBBORN_SETS_H	pruning/stubborn_sets.h	2;"	d
PRUNING_STUBBORN_SETS_SIMPLE_H	pruning/stubborn_sets_simple.h	2;"	d
ParetoOpenList	open_lists/pareto_open_list.cc	/^ParetoOpenList<Entry>::ParetoOpenList(const Options &opts)$/;"	f	class:ParetoOpenList
ParetoOpenList	open_lists/pareto_open_list.cc	/^class ParetoOpenList : public OpenList<Entry> {$/;"	c	file:
ParetoOpenListFactory	open_lists/pareto_open_list.cc	/^ParetoOpenListFactory::ParetoOpenListFactory($/;"	f	class:ParetoOpenListFactory
ParetoOpenListFactory	open_lists/pareto_open_list.h	/^class ParetoOpenListFactory : public OpenListFactory {$/;"	c
ParseError	options/errors.cc	/^ParseError::ParseError(string m, ParseTree pt)$/;"	f	class:options::ParseError
ParseError	options/errors.cc	/^ParseError::ParseError(string m, ParseTree pt, string correct_substring)$/;"	f	class:options::ParseError
ParseError	options/errors.h	/^struct ParseError {$/;"	s	namespace:options
ParseNode	options/parse_tree.h	/^    ParseNode()$/;"	f	struct:options::ParseNode
ParseNode	options/parse_tree.h	/^    ParseNode(std::string val, std::string k = "")$/;"	f	struct:options::ParseNode
ParseNode	options/parse_tree.h	/^struct ParseNode {$/;"	s	namespace:options
ParseTree	options/parse_tree.h	/^typedef tree<ParseNode> ParseTree;$/;"	t	namespace:options
Partition	bliss/partition.cc	/^Partition::Partition()$/;"	f	class:bliss::Partition
Partition	bliss/partition.h	/^class Partition$/;"	c	namespace:bliss
PathInfo	bliss/graph.cc	/^} PathInfo;$/;"	t	namespace:bliss	typeref:struct:bliss::__anon3	file:
PatternCollectionGenerator	pdbs/pattern_generator.h	/^class PatternCollectionGenerator {$/;"	c	namespace:pdbs
PatternCollectionGeneratorCombo	pdbs/pattern_collection_generator_combo.cc	/^PatternCollectionGeneratorCombo::PatternCollectionGeneratorCombo(const Options &opts)$/;"	f	class:pdbs::PatternCollectionGeneratorCombo
PatternCollectionGeneratorCombo	pdbs/pattern_collection_generator_combo.h	/^class PatternCollectionGeneratorCombo : public PatternCollectionGenerator {$/;"	c	namespace:pdbs
PatternCollectionGeneratorGenetic	pdbs/pattern_collection_generator_genetic.cc	/^PatternCollectionGeneratorGenetic::PatternCollectionGeneratorGenetic($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
PatternCollectionGeneratorGenetic	pdbs/pattern_collection_generator_genetic.h	/^class PatternCollectionGeneratorGenetic : public PatternCollectionGenerator {$/;"	c	namespace:pdbs
PatternCollectionGeneratorHillclimbing	pdbs/pattern_collection_generator_hillclimbing.cc	/^PatternCollectionGeneratorHillclimbing::PatternCollectionGeneratorHillclimbing(const Options &opts)$/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
PatternCollectionGeneratorHillclimbing	pdbs/pattern_collection_generator_hillclimbing.h	/^class PatternCollectionGeneratorHillclimbing : public PatternCollectionGenerator {$/;"	c	namespace:pdbs
PatternCollectionGeneratorManual	pdbs/pattern_collection_generator_manual.cc	/^PatternCollectionGeneratorManual::PatternCollectionGeneratorManual(const Options &opts)$/;"	f	class:pdbs::PatternCollectionGeneratorManual
PatternCollectionGeneratorManual	pdbs/pattern_collection_generator_manual.h	/^class PatternCollectionGeneratorManual : public PatternCollectionGenerator {$/;"	c	namespace:pdbs
PatternCollectionGeneratorSystematic	pdbs/pattern_collection_generator_systematic.cc	/^PatternCollectionGeneratorSystematic::PatternCollectionGeneratorSystematic($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
PatternCollectionGeneratorSystematic	pdbs/pattern_collection_generator_systematic.h	/^class PatternCollectionGeneratorSystematic : public PatternCollectionGenerator {$/;"	c	namespace:pdbs
PatternCollectionInformation	pdbs/pattern_collection_information.cc	/^PatternCollectionInformation::PatternCollectionInformation($/;"	f	class:pdbs::PatternCollectionInformation
PatternCollectionInformation	pdbs/pattern_collection_information.h	/^class PatternCollectionInformation {$/;"	c	namespace:pdbs
PatternDatabase	pdbs/pattern_database.cc	/^PatternDatabase::PatternDatabase($/;"	f	class:pdbs::PatternDatabase
PatternDatabase	pdbs/pattern_database.h	/^class PatternDatabase {$/;"	c	namespace:pdbs
PatternGenerator	pdbs/pattern_generator.h	/^class PatternGenerator {$/;"	c	namespace:pdbs
PatternGeneratorGreedy	pdbs/pattern_generator_greedy.cc	/^PatternGeneratorGreedy::PatternGeneratorGreedy(const Options &opts)$/;"	f	class:pdbs::PatternGeneratorGreedy
PatternGeneratorGreedy	pdbs/pattern_generator_greedy.cc	/^PatternGeneratorGreedy::PatternGeneratorGreedy(int max_states)$/;"	f	class:pdbs::PatternGeneratorGreedy
PatternGeneratorGreedy	pdbs/pattern_generator_greedy.h	/^class PatternGeneratorGreedy : public PatternGenerator {$/;"	c	namespace:pdbs
PatternGeneratorManual	pdbs/pattern_generator_manual.cc	/^PatternGeneratorManual::PatternGeneratorManual(const Options &opts)$/;"	f	class:pdbs::PatternGeneratorManual
PatternGeneratorManual	pdbs/pattern_generator_manual.h	/^class PatternGeneratorManual : public PatternGenerator {$/;"	c	namespace:pdbs
PerStateInformation	per_state_information.h	/^    PerStateInformation()$/;"	f	class:PerStateInformation
PerStateInformation	per_state_information.h	/^    explicit PerStateInformation(const Entry &default_value_)$/;"	f	class:PerStateInformation
PerStateInformation	per_state_information.h	/^class PerStateInformation : public PerStateInformationBase {$/;"	c
PerStateInformationBase	per_state_information.h	/^    PerStateInformationBase() {$/;"	f	class:PerStateInformationBase
PerStateInformationBase	per_state_information.h	/^class PerStateInformationBase {$/;"	c
Permutation	structural_symmetries/permutation.cc	/^Permutation::Permutation(){$/;"	f	class:Permutation
Permutation	structural_symmetries/permutation.cc	/^Permutation::Permutation(const Permutation &perm, bool invert){$/;"	f	class:Permutation
Permutation	structural_symmetries/permutation.cc	/^Permutation::Permutation(const Permutation &perm1, const Permutation &perm2){$/;"	f	class:Permutation
Permutation	structural_symmetries/permutation.cc	/^Permutation::Permutation(const unsigned int* full_permutation){$/;"	f	class:Permutation
Permutation	structural_symmetries/permutation.h	/^class Permutation{$/;"	c
PhOConstraints	operator_counting/pho_constraints.cc	/^PhOConstraints::PhOConstraints(const Options &opts)$/;"	f	class:operator_counting::PhOConstraints
PhOConstraints	operator_counting/pho_constraints.h	/^class PhOConstraints : public ConstraintGenerator {$/;"	c	namespace:operator_counting
PickSplit	cegar/split_selector.h	/^enum class PickSplit {$/;"	c	namespace:cegar
Placeholder	options/any.h	/^    class Placeholder {$/;"	c	class:options::Any
PlainPrinter	options/doc_printer.cc	/^PlainPrinter::PlainPrinter(ostream &out, bool pa)$/;"	f	class:options::PlainPrinter
PlainPrinter	options/doc_printer.h	/^class PlainPrinter : public DocPrinter {$/;"	c	namespace:options
Plan	search_engine.h	/^    typedef std::vector<const GlobalOperator *> Plan;$/;"	t	class:SearchEngine
PlanForbidReformulatedTask	tasks/plan_forbid_reformulated_task.cc	/^PlanForbidReformulatedTask::PlanForbidReformulatedTask($/;"	f	class:extra_tasks::PlanForbidReformulatedTask
PlanForbidReformulatedTask	tasks/plan_forbid_reformulated_task.h	/^class PlanForbidReformulatedTask : public tasks::DelegatingTask {$/;"	c	namespace:extra_tasks
Plugin	options/plugin.h	/^    Plugin(const std::string &key, typename Registry<T *>::Factory factory) {$/;"	f	class:options::Plugin
Plugin	options/plugin.h	/^class Plugin {$/;"	c	namespace:options
PluginShared	options/plugin.h	/^    PluginShared(const std::string &key, typename Registry<std::shared_ptr<T>>::Factory factory) {$/;"	f	class:options::PluginShared
PluginShared	options/plugin.h	/^class PluginShared {$/;"	c	namespace:options
PluginTypeInfo	options/registries.h	/^    PluginTypeInfo(const std::type_index &type,$/;"	f	class:options::PluginTypeInfo
PluginTypeInfo	options/registries.h	/^class PluginTypeInfo {$/;"	c	namespace:options
PluginTypePlugin	options/plugin.h	/^    PluginTypePlugin(const std::string &type_name,$/;"	f	class:options::PluginTypePlugin
PluginTypePlugin	options/plugin.h	/^class PluginTypePlugin {$/;"	c	namespace:options
PluginTypeRegistry	options/registries.h	/^class PluginTypeRegistry {$/;"	c	namespace:options
PotentialFunction	potentials/potential_function.cc	/^PotentialFunction::PotentialFunction($/;"	f	class:potentials::PotentialFunction
PotentialFunction	potentials/potential_function.h	/^class PotentialFunction {$/;"	c	namespace:potentials
PotentialHeuristic	potentials/potential_heuristic.cc	/^PotentialHeuristic::PotentialHeuristic($/;"	f	class:potentials::PotentialHeuristic
PotentialHeuristic	potentials/potential_heuristic.h	/^class PotentialHeuristic : public Heuristic {$/;"	c	namespace:potentials
PotentialMaxHeuristic	potentials/potential_max_heuristic.cc	/^PotentialMaxHeuristic::PotentialMaxHeuristic($/;"	f	class:potentials::PotentialMaxHeuristic
PotentialMaxHeuristic	potentials/potential_max_heuristic.h	/^class PotentialMaxHeuristic : public Heuristic {$/;"	c	namespace:potentials
PotentialOptimizer	potentials/potential_optimizer.cc	/^PotentialOptimizer::PotentialOptimizer(const Options &opts)$/;"	f	class:potentials::PotentialOptimizer
PotentialOptimizer	potentials/potential_optimizer.h	/^class PotentialOptimizer {$/;"	c	namespace:potentials
PreconditionsProxy	task_proxy.h	/^    PreconditionsProxy(const AbstractTask &task, int op_index, bool is_axiom)$/;"	f	class:PreconditionsProxy
PreconditionsProxy	task_proxy.h	/^class PreconditionsProxy : public ConditionsProxy {$/;"	c
Predefinitions	options/predefinitions.h	/^class Predefinitions {$/;"	c	namespace:options
PrefEvaluator	evaluators/pref_evaluator.cc	/^PrefEvaluator::PrefEvaluator() {$/;"	f	class:pref_evaluator::PrefEvaluator
PrefEvaluator	evaluators/pref_evaluator.h	/^class PrefEvaluator : public ScalarEvaluator {$/;"	c	namespace:pref_evaluator
PreferredUsage	search_engines/enforced_hill_climbing_search.h	/^enum class PreferredUsage {$/;"	c	namespace:enforced_hill_climbing_search
ProductTSOrder	merge_and_shrink/merge_scoring_function_total_order.h	/^    enum class ProductTSOrder {$/;"	c	class:merge_and_shrink::MergeScoringFunctionTotalOrder
PropertyInfo	options/doc_store.h	/^    PropertyInfo(std::string prop, std::string descr)$/;"	f	struct:options::PropertyInfo
PropertyInfo	options/doc_store.h	/^struct PropertyInfo {$/;"	s	namespace:options
Proposition	heuristics/relaxation_heuristic.h	/^    Proposition(int id_) {$/;"	f	struct:relaxation_heuristic::Proposition
Proposition	heuristics/relaxation_heuristic.h	/^struct Proposition {$/;"	s	namespace:relaxation_heuristic
Proposition	operator_counting/state_equation_constraints.h	/^    Proposition() : constraint_index(-1) {$/;"	f	struct:operator_counting::Proposition
Proposition	operator_counting/state_equation_constraints.h	/^struct Proposition {$/;"	s	namespace:operator_counting
PropositionStatus	heuristics/lm_cut_landmarks.h	/^enum PropositionStatus {$/;"	g	namespace:lm_cut_heuristic
ProxyIterator	task_proxy.h	/^    ProxyIterator(const ProxyCollection &collection, std::size_t pos)$/;"	f	class:ProxyIterator
ProxyIterator	task_proxy.h	/^class ProxyIterator {$/;"	c
PruningMethod	pruning_method.cc	/^PruningMethod::PruningMethod()$/;"	f	class:PruningMethod
PruningMethod	pruning_method.h	/^class PruningMethod {$/;"	c
RANDOM	cegar/split_selector.h	/^    RANDOM,$/;"	m	class:cegar::PickSplit
RANDOM	cegar/subtask_generators.h	/^    RANDOM,$/;"	m	class:cegar::FactOrder
RANDOM	merge_and_shrink/label_reduction.h	/^        RANDOM$/;"	e	enum:merge_and_shrink::LabelReduction::LabelReductionSystemOrder
RANDOM	variable_order_finder.h	/^    RANDOM,$/;"	e	enum:VariableOrderType
REACHED	heuristics/lm_cut_landmarks.h	/^    REACHED = 1,$/;"	e	enum:lm_cut_heuristic::PropositionStatus
REGULAR	merge_and_shrink/label_reduction.h	/^        REGULAR,$/;"	e	enum:merge_and_shrink::LabelReduction::LabelReductionSystemOrder
RETURN	merge_and_shrink/shrink_bisimulation.h	/^        RETURN,$/;"	e	enum:merge_and_shrink::ShrinkBisimulation::AtLimit
REVERSE	merge_and_shrink/label_reduction.h	/^        REVERSE,$/;"	e	enum:merge_and_shrink::LabelReduction::LabelReductionSystemOrder
REVERSE_LEVEL	merge_and_shrink/merge_scoring_function_total_order.h	/^        REVERSE_LEVEL,$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder::AtomicTSOrder
REVERSE_LEVEL	variable_order_finder.h	/^    REVERSE_LEVEL$/;"	e	enum:VariableOrderType
RandomNumberGenerator	utils/rng.cc	/^RandomNumberGenerator::RandomNumberGenerator() {$/;"	f	class:utils::RandomNumberGenerator
RandomNumberGenerator	utils/rng.cc	/^RandomNumberGenerator::RandomNumberGenerator(int seed_) {$/;"	f	class:utils::RandomNumberGenerator
RandomNumberGenerator	utils/rng.h	/^class RandomNumberGenerator {$/;"	c	namespace:utils
RefInfo	bliss/partition.h	/^  class RefInfo {$/;"	c	class:bliss::Partition
RefinementHierarchy	cegar/refinement_hierarchy.cc	/^RefinementHierarchy::RefinementHierarchy()$/;"	f	class:cegar::RefinementHierarchy
RefinementHierarchy	cegar/refinement_hierarchy.h	/^    RefinementHierarchy(RefinementHierarchy &&other)$/;"	f	class:cegar::RefinementHierarchy
RefinementHierarchy	cegar/refinement_hierarchy.h	/^class RefinementHierarchy {$/;"	c	namespace:cegar
Registry	options/registries.h	/^class Registry {$/;"	c	namespace:options
RelaxationHeuristic	heuristics/relaxation_heuristic.cc	/^RelaxationHeuristic::RelaxationHeuristic(const options::Options &opts)$/;"	f	class:relaxation_heuristic::RelaxationHeuristic
RelaxationHeuristic	heuristics/relaxation_heuristic.h	/^class RelaxationHeuristic : public Heuristic {$/;"	c	namespace:relaxation_heuristic
RelaxedOperator	heuristics/lm_cut_landmarks.h	/^    RelaxedOperator(std::vector<RelaxedProposition *> &&pre,$/;"	f	struct:lm_cut_heuristic::RelaxedOperator
RelaxedOperator	heuristics/lm_cut_landmarks.h	/^struct RelaxedOperator {$/;"	s	namespace:lm_cut_heuristic
RelaxedPlan	heuristics/ff_heuristic.h	/^    typedef std::vector<bool> RelaxedPlan;$/;"	t	class:ff_heuristic::FFHeuristic
RelaxedProposition	heuristics/lm_cut_landmarks.h	/^struct RelaxedProposition {$/;"	s	namespace:lm_cut_heuristic
RootTask	tasks/root_task.h	/^class RootTask : public AbstractTask {$/;"	c	namespace:tasks
SAMPLING_H	sampling.h	2;"	d
SCALAR_EVALUATOR_H	scalar_evaluator.h	2;"	d
SEARCH_ENGINES_EAGER_SEARCH_H	search_engines/eager_search.h	2;"	d
SEARCH_ENGINES_ENFORCED_HILL_CLIMBING_SEARCH_H	search_engines/enforced_hill_climbing_search.h	2;"	d
SEARCH_ENGINES_ITERATED_SEARCH_H	search_engines/iterated_search.h	2;"	d
SEARCH_ENGINES_LAZY_SEARCH_H	search_engines/lazy_search.h	2;"	d
SEARCH_ENGINES_SEARCH_COMMON_H	search_engines/search_common.h	2;"	d
SEARCH_ENGINES_TOP_K_EAGER_SEARCH_H	search_engines/top_k_eager_search.h	2;"	d
SEARCH_ENGINE_H	search_engine.h	2;"	d
SEARCH_NODE_INFO_H	search_node_info.h	2;"	d
SEARCH_PROGRESS_H	search_progress.h	2;"	d
SEARCH_SPACE_H	search_space.h	2;"	d
SEARCH_STATISTICS_H	search_statistics.h	2;"	d
SEGMENT_BYTES	algorithms/segmented_vector.h	/^    static const size_t SEGMENT_BYTES = 8192;$/;"	m	class:segmented_vector::SegmentedArrayVector
SEGMENT_BYTES	algorithms/segmented_vector.h	/^    static const size_t SEGMENT_BYTES = 8192;$/;"	m	class:segmented_vector::SegmentedVector
SEGMENT_ELEMENTS	algorithms/segmented_vector.h	/^    static const size_t SEGMENT_ELEMENTS =$/;"	m	class:segmented_vector::SegmentedVector
SILENT	merge_and_shrink/types.h	/^    SILENT,$/;"	m	class:merge_and_shrink::Verbosity
SOLVED	search_engine.h	/^enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED, INTERRUPTED};$/;"	e	enum:SearchStatus
SPLIT_END	bliss/graph.cc	/^  static const int SPLIT_END   = -2;$/;"	m	class:bliss::TreeNode	file:
SPLIT_START	bliss/graph.cc	/^  static const int SPLIT_START = -1;$/;"	m	class:bliss::TreeNode	file:
STATE_ID_H	state_id.h	2;"	d
STATE_REGISTRY_H	state_registry.h	2;"	d
STRUCTURAL_SYMMETRIES_GRAPH_CREATOR_H	structural_symmetries/graph_creator.h	2;"	d
STRUCTURAL_SYMMETRIES_GROUP_H	structural_symmetries/group.h	2;"	d
STRUCTURAL_SYMMETRIES_OPERATOR_PERMUTATION_H	structural_symmetries/operator_permutation.h	2;"	d
STRUCTURAL_SYMMETRIES_PERMUTATION_H	structural_symmetries/permutation.h	2;"	d
SUBSET_OF_STATES	structural_symmetries/group.h	/^    SUBSET_OF_STATES,$/;"	m	class:SymmetricalLookups
SUCCESSOR_GENERATOR_H	successor_generator.h	2;"	d
SamplingTimeout	sampling.h	/^struct SamplingTimeout : public std::exception {};$/;"	s
ScalarEvaluator	scalar_evaluator.h	/^class ScalarEvaluator {$/;"	c
SearchControl	search_engines/top_k_eager_search.h	/^struct SearchControl {$/;"	s	namespace:top_k_eager_search
SearchEngine	search_engine.cc	/^SearchEngine::SearchEngine(const Options &opts)$/;"	f	class:SearchEngine
SearchEngine	search_engine.h	/^class SearchEngine {$/;"	c
SearchNode	search_space.cc	/^SearchNode::SearchNode(const StateRegistry &state_registry,$/;"	f	class:SearchNode
SearchNode	search_space.h	/^class SearchNode {$/;"	c
SearchNodeInfo	search_node_info.h	/^    SearchNodeInfo()$/;"	f	struct:SearchNodeInfo
SearchNodeInfo	search_node_info.h	/^struct SearchNodeInfo {$/;"	s
SearchProgress	search_progress.h	/^class SearchProgress {$/;"	c
SearchSpace	search_space.cc	/^SearchSpace::SearchSpace(StateRegistry &state_registry, OperatorCost cost_type)$/;"	f	class:SearchSpace
SearchSpace	search_space.h	/^class SearchSpace {$/;"	c
SearchStatistics	search_statistics.cc	/^SearchStatistics::SearchStatistics() {$/;"	f	class:SearchStatistics
SearchStatistics	search_statistics.h	/^class SearchStatistics {$/;"	c
SearchStatus	search_engine.h	/^enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED, INTERRUPTED};$/;"	g
SearchSymmetries	structural_symmetries/group.h	/^enum class SearchSymmetries {$/;"	c
SegmentedArrayVector	algorithms/segmented_vector.h	/^    SegmentedArrayVector(size_t elements_per_array_)$/;"	f	class:segmented_vector::SegmentedArrayVector
SegmentedArrayVector	algorithms/segmented_vector.h	/^    SegmentedArrayVector(size_t elements_per_array_, const ElementAllocator &allocator_)$/;"	f	class:segmented_vector::SegmentedArrayVector
SegmentedArrayVector	algorithms/segmented_vector.h	/^class SegmentedArrayVector {$/;"	c	namespace:segmented_vector
SegmentedVector	algorithms/segmented_vector.h	/^    SegmentedVector()$/;"	f	class:segmented_vector::SegmentedVector
SegmentedVector	algorithms/segmented_vector.h	/^    SegmentedVector(const EntryAllocator &allocator_)$/;"	f	class:segmented_vector::SegmentedVector
SegmentedVector	algorithms/segmented_vector.h	/^class SegmentedVector {$/;"	c	namespace:segmented_vector
ShrinkBisimulation	merge_and_shrink/shrink_bisimulation.cc	/^ShrinkBisimulation::ShrinkBisimulation(const Options &opts)$/;"	f	class:merge_and_shrink::ShrinkBisimulation
ShrinkBisimulation	merge_and_shrink/shrink_bisimulation.h	/^class ShrinkBisimulation : public ShrinkStrategy {$/;"	c	namespace:merge_and_shrink
ShrinkBucketBased	merge_and_shrink/shrink_bucket_based.cc	/^ShrinkBucketBased::ShrinkBucketBased(const options::Options &opts)$/;"	f	class:merge_and_shrink::ShrinkBucketBased
ShrinkBucketBased	merge_and_shrink/shrink_bucket_based.h	/^class ShrinkBucketBased : public ShrinkStrategy {$/;"	c	namespace:merge_and_shrink
ShrinkFH	merge_and_shrink/shrink_fh.cc	/^ShrinkFH::ShrinkFH(const Options &opts)$/;"	f	class:merge_and_shrink::ShrinkFH
ShrinkFH	merge_and_shrink/shrink_fh.h	/^class ShrinkFH : public ShrinkBucketBased {$/;"	c	namespace:merge_and_shrink
ShrinkRandom	merge_and_shrink/shrink_random.cc	/^ShrinkRandom::ShrinkRandom(const Options &opts)$/;"	f	class:merge_and_shrink::ShrinkRandom
ShrinkRandom	merge_and_shrink/shrink_random.h	/^class ShrinkRandom : public ShrinkBucketBased {$/;"	c	namespace:merge_and_shrink
ShrinkStrategy	merge_and_shrink/shrink_strategy.h	/^class ShrinkStrategy {$/;"	c	namespace:merge_and_shrink
Signature	merge_and_shrink/shrink_bisimulation.cc	/^    Signature(int h, bool is_goal, int group_,$/;"	f	struct:merge_and_shrink::Signature
Signature	merge_and_shrink/shrink_bisimulation.cc	/^struct Signature {$/;"	s	namespace:merge_and_shrink	file:
SortFactsByIncreasingHaddValues	cegar/subtask_generators.cc	/^    explicit SortFactsByIncreasingHaddValues($/;"	f	class:cegar::SortFactsByIncreasingHaddValues
SortFactsByIncreasingHaddValues	cegar/subtask_generators.cc	/^class SortFactsByIncreasingHaddValues {$/;"	c	namespace:cegar	file:
Split	cegar/split_selector.h	/^    Split(int var_id, std::vector<int> &&values)$/;"	f	struct:cegar::Split
Split	cegar/split_selector.h	/^struct Split {$/;"	s	namespace:cegar
SplitSelector	cegar/split_selector.cc	/^SplitSelector::SplitSelector($/;"	f	class:cegar::SplitSelector
SplitSelector	cegar/split_selector.h	/^class SplitSelector {$/;"	c	namespace:cegar
SplittingHeuristic	bliss/graph.h	/^  } SplittingHeuristic;$/;"	t	class:bliss::Digraph	typeref:enum:bliss::Digraph::__anon2
SplittingHeuristic	bliss/graph.h	/^  } SplittingHeuristic;$/;"	t	class:bliss::Graph	typeref:enum:bliss::Graph::__anon1
StandardScalarOpenList	open_lists/standard_scalar_open_list.cc	/^StandardScalarOpenList<Entry>::StandardScalarOpenList($/;"	f	class:StandardScalarOpenList
StandardScalarOpenList	open_lists/standard_scalar_open_list.cc	/^StandardScalarOpenList<Entry>::StandardScalarOpenList(const Options &opts)$/;"	f	class:StandardScalarOpenList
StandardScalarOpenList	open_lists/standard_scalar_open_list.cc	/^class StandardScalarOpenList : public OpenList<Entry> {$/;"	c	file:
StandardScalarOpenListFactory	open_lists/standard_scalar_open_list.cc	/^StandardScalarOpenListFactory::StandardScalarOpenListFactory($/;"	f	class:StandardScalarOpenListFactory
StandardScalarOpenListFactory	open_lists/standard_scalar_open_list.h	/^class StandardScalarOpenListFactory : public OpenListFactory {$/;"	c
State	task_proxy.h	/^    State(State &&other)$/;"	f	class:State
State	task_proxy.h	/^    State(const AbstractTask &task, std::vector<int> &&values)$/;"	f	class:State
State	task_proxy.h	/^class State {$/;"	c
StateActionHeap	search_engines/top_k_eager_search.h	/^typedef std::priority_queue<StateActionPair> StateActionHeap;$/;"	t	namespace:top_k_eager_search
StateActionPair	search_engines/top_k_eager_search.h	/^struct StateActionPair {$/;"	s	namespace:top_k_eager_search
StateEquationConstraints	operator_counting/state_equation_constraints.h	/^class StateEquationConstraints : public ConstraintGenerator {$/;"	c	namespace:operator_counting
StateID	state_id.h	/^    explicit StateID(int value_)$/;"	f	class:StateID
StateID	state_id.h	/^class StateID {$/;"	c
StateIDSemanticEqual	state_registry.h	/^        StateIDSemanticEqual($/;"	f	struct:StateRegistry::StateIDSemanticEqual
StateIDSemanticEqual	state_registry.h	/^    struct StateIDSemanticEqual {$/;"	s	class:StateRegistry
StateIDSemanticHash	state_registry.h	/^        StateIDSemanticHash($/;"	f	struct:StateRegistry::StateIDSemanticHash
StateIDSemanticHash	state_registry.h	/^    struct StateIDSemanticHash {$/;"	s	class:StateRegistry
StateIDSet	state_registry.h	/^                               StateIDSemanticEqual> StateIDSet;$/;"	t	class:StateRegistry
StateRegistry	state_registry.cc	/^StateRegistry::StateRegistry($/;"	f	class:StateRegistry
StateRegistry	state_registry.h	/^class StateRegistry {$/;"	c
Stats	bliss/graph.h	/^  Stats() { reset(); }$/;"	f	class:bliss::Stats
Stats	bliss/graph.h	/^class Stats$/;"	c	namespace:bliss
StubbornSets	pruning/stubborn_sets.h	/^class StubbornSets : public PruningMethod {$/;"	c	namespace:stubborn_sets
StubbornSetsEC	pruning/stubborn_sets_ec.h	/^class StubbornSetsEC : public stubborn_sets::StubbornSets {$/;"	c	namespace:stubborn_sets_ec
StubbornSetsSimple	pruning/stubborn_sets_simple.h	/^class StubbornSetsSimple : public stubborn_sets::StubbornSets {$/;"	c	namespace:stubborn_sets_simple
SubtaskGenerator	cegar/subtask_generators.h	/^class SubtaskGenerator {$/;"	c	namespace:cegar
SuccessorGenerator	successor_generator.cc	/^SuccessorGenerator::SuccessorGenerator(const TaskProxy &task_proxy)$/;"	f	class:SuccessorGenerator
SuccessorGenerator	successor_generator.h	/^class SuccessorGenerator {$/;"	c
SumEvaluator	evaluators/sum_evaluator.cc	/^SumEvaluator::SumEvaluator(const Options &opts)$/;"	f	class:sum_evaluator::SumEvaluator
SumEvaluator	evaluators/sum_evaluator.cc	/^SumEvaluator::SumEvaluator(const vector<ScalarEvaluator *> &evals)$/;"	f	class:sum_evaluator::SumEvaluator
SumEvaluator	evaluators/sum_evaluator.h	/^class SumEvaluator : public combining_evaluator::CombiningEvaluator {$/;"	c	namespace:sum_evaluator
SymmetricalLookups	structural_symmetries/group.h	/^enum class SymmetricalLookups {$/;"	c
Synergy	options/synergy.h	/^class Synergy {$/;"	c	namespace:options
TASKS_COST_ADAPTED_TASK_H	tasks/cost_adapted_task.h	2;"	d
TASKS_DELEGATING_TASK_H	tasks/delegating_task.h	2;"	d
TASKS_DOMAIN_ABSTRACTED_TASK_FACTORY_H	tasks/domain_abstracted_task_factory.h	2;"	d
TASKS_DOMAIN_ABSTRACTED_TASK_H	tasks/domain_abstracted_task.h	2;"	d
TASKS_MODIFIED_GOALS_TASK_H	tasks/modified_goals_task.h	2;"	d
TASKS_MODIFIED_OPERATOR_COSTS_TASK_H	tasks/modified_operator_costs_task.h	2;"	d
TASKS_PLAN_FORBID_REFORMULATED_TASK_H	tasks/plan_forbid_reformulated_task.h	2;"	d
TASKS_ROOT_TASK_H	tasks/root_task.h	2;"	d
TASK_PROXY_H	task_proxy.h	2;"	d
TASK_TOOLS_H	task_tools.h	2;"	d
TIMEOUT	search_engine.h	/^enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED, INTERRUPTED};$/;"	e	enum:SearchStatus
TIME_FIELD_WIDTH	utils/logging.cc	/^    static const int TIME_FIELD_WIDTH = 7;$/;"	m	class:utils::MemoryTracer	file:
TSConstIterator	merge_and_shrink/transition_system.cc	/^TSConstIterator::TSConstIterator($/;"	f	class:merge_and_shrink::TSConstIterator
TSConstIterator	merge_and_shrink/transition_system.h	/^class TSConstIterator {$/;"	c	namespace:merge_and_shrink
TWO_TRANSITION_SYSTEMS	merge_and_shrink/label_reduction.h	/^        TWO_TRANSITION_SYSTEMS,$/;"	e	enum:merge_and_shrink::LabelReduction::LabelReductionMethod
TaskDuplicator	cegar/subtask_generators.cc	/^TaskDuplicator::TaskDuplicator(const Options &opts)$/;"	f	class:cegar::TaskDuplicator
TaskDuplicator	cegar/subtask_generators.h	/^class TaskDuplicator : public SubtaskGenerator {$/;"	c	namespace:cegar
TaskProxy	task_proxy.h	/^    explicit TaskProxy(const AbstractTask &task)$/;"	f	class:TaskProxy
TaskProxy	task_proxy.h	/^class TaskProxy {$/;"	c
TieBreakingOpenList	open_lists/tiebreaking_open_list.cc	/^TieBreakingOpenList<Entry>::TieBreakingOpenList(const Options &opts)$/;"	f	class:TieBreakingOpenList
TieBreakingOpenList	open_lists/tiebreaking_open_list.cc	/^class TieBreakingOpenList : public OpenList<Entry> {$/;"	c	file:
TieBreakingOpenListFactory	open_lists/tiebreaking_open_list.cc	/^TieBreakingOpenListFactory::TieBreakingOpenListFactory(const Options &options)$/;"	f	class:TieBreakingOpenListFactory
TieBreakingOpenListFactory	open_lists/tiebreaking_open_list.h	/^class TieBreakingOpenListFactory : public OpenListFactory {$/;"	c
Timer	bliss/timer.cc	/^Timer::Timer()$/;"	f	class:bliss::Timer
Timer	bliss/timer.h	/^class Timer$/;"	c	namespace:bliss
Timer	utils/timer.cc	/^Timer::Timer() {$/;"	f	class:utils::Timer
Timer	utils/timer.h	/^class Timer {$/;"	c	namespace:utils
TokenParser	options/token_parser.h	/^class TokenParser {$/;"	c	namespace:options
TokenParser	options/token_parser.h	/^class TokenParser<T *> {$/;"	c	namespace:options
TokenParser	options/token_parser.h	/^class TokenParser<std::shared_ptr<T>> {$/;"	c	namespace:options
TokenParser	options/token_parser.h	/^class TokenParser<std::vector<T>> {$/;"	c	namespace:options
TopKEagerSearch	search_engines/top_k_eager_search.cc	/^TopKEagerSearch::TopKEagerSearch(const Options &opts)$/;"	f	class:top_k_eager_search::TopKEagerSearch
TopKEagerSearch	search_engines/top_k_eager_search.h	/^class TopKEagerSearch : public SearchEngine {$/;"	c	namespace:top_k_eager_search
Trace	structural_symmetries/group.h	/^    typedef std::vector<short int> Trace;$/;"	t	class:Group
TraceBlock	utils/logging.cc	/^TraceBlock::TraceBlock(const string &block_name)$/;"	f	class:utils::TraceBlock
TraceBlock	utils/logging.h	/^class TraceBlock {$/;"	c	namespace:utils
Transition	cegar/transition.h	/^    Transition(int op_id, AbstractState *state)$/;"	f	struct:cegar::Transition
Transition	cegar/transition.h	/^struct Transition {$/;"	s	namespace:cegar
Transition	merge_and_shrink/transition_system.h	/^    Transition(int src, int target)$/;"	f	struct:merge_and_shrink::Transition
Transition	merge_and_shrink/transition_system.h	/^struct Transition {$/;"	s	namespace:merge_and_shrink
TransitionSystem	merge_and_shrink/transition_system.cc	/^TransitionSystem::TransitionSystem($/;"	f	class:merge_and_shrink::TransitionSystem
TransitionSystem	merge_and_shrink/transition_system.h	/^class TransitionSystem {$/;"	c	namespace:merge_and_shrink
TransitionSystemData	merge_and_shrink/fts_factory.cc	/^        TransitionSystemData(TransitionSystemData &&other)$/;"	f	struct:merge_and_shrink::FTSFactory::TransitionSystemData
TransitionSystemData	merge_and_shrink/fts_factory.cc	/^    struct TransitionSystemData {$/;"	s	class:merge_and_shrink::FTSFactory	file:
TransitionUpdater	cegar/transition_updater.cc	/^TransitionUpdater::TransitionUpdater(const OperatorsProxy &ops)$/;"	f	class:cegar::TransitionUpdater
TransitionUpdater	cegar/transition_updater.h	/^class TransitionUpdater {$/;"	c	namespace:cegar
TreeNode	bliss/graph.cc	/^class TreeNode$/;"	c	namespace:bliss	file:
Txt2TagsPrinter	options/doc_printer.cc	/^Txt2TagsPrinter::Txt2TagsPrinter(ostream &out)$/;"	f	class:options::Txt2TagsPrinter
Txt2TagsPrinter	options/doc_printer.h	/^class Txt2TagsPrinter : public DocPrinter {$/;"	c	namespace:options
TypeBasedOpenList	open_lists/type_based_open_list.cc	/^TypeBasedOpenList<Entry>::TypeBasedOpenList(const Options &opts)$/;"	f	class:TypeBasedOpenList
TypeBasedOpenList	open_lists/type_based_open_list.cc	/^class TypeBasedOpenList : public OpenList<Entry> {$/;"	c	file:
TypeBasedOpenListFactory	open_lists/type_based_open_list.cc	/^TypeBasedOpenListFactory::TypeBasedOpenListFactory($/;"	f	class:TypeBasedOpenListFactory
TypeBasedOpenListFactory	open_lists/type_based_open_list.h	/^class TypeBasedOpenListFactory : public OpenListFactory {$/;"	c
TypeDocumenter	options/type_documenter.h	/^struct TypeDocumenter {$/;"	s	namespace:options
TypeDocumenter	options/type_documenter.h	/^struct TypeDocumenter<T *> {$/;"	s	namespace:options
TypeDocumenter	options/type_documenter.h	/^struct TypeDocumenter<std::shared_ptr<T>> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<ParseTree> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<T *> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<bool> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<double> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<int> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<std::shared_ptr<T>> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<std::string> {$/;"	s	namespace:options
TypeNamer	options/type_namer.h	/^struct TypeNamer<std::vector<T>> {$/;"	s	namespace:options
UNDEFINED_OPERATOR	cegar/abstract_state.cc	/^const int AbstractSearchInfo::UNDEFINED_OPERATOR = -1;$/;"	m	class:cegar::AbstractSearchInfo	file:
UNDEFINED_OPERATOR	cegar/abstract_state.h	/^    static const int UNDEFINED_OPERATOR;$/;"	m	class:cegar::AbstractSearchInfo
UNDEFINED_VALUE	cegar/utils.h	/^const int UNDEFINED_VALUE = -1;$/;"	m	namespace:cegar
UNINITIALIZED	evaluation_result.h	/^    static const int UNINITIALIZED = -2;$/;"	m	class:EvaluationResult
UNINITIALIZED	merge_and_shrink/merge_tree.cc	/^const int UNINITIALIZED = -1;$/;"	m	namespace:merge_and_shrink	file:
UNREACHED	heuristics/lm_cut_landmarks.h	/^    UNREACHED = 0,$/;"	e	enum:lm_cut_heuristic::PropositionStatus
UNSOLVABLE	utils/system.h	/^    UNSOLVABLE = 4,$/;"	m	class:utils::ExitCode
UNSOLVED_INCOMPLETE	utils/system.h	/^    UNSOLVED_INCOMPLETE = 5,$/;"	m	class:utils::ExitCode
UNSUPPORTED	utils/system.h	/^    UNSUPPORTED = 3,$/;"	m	class:utils::ExitCode
USE_CACHE	heuristics/cg_heuristic.cc	18;"	d	file:
USE_FIRST	merge_and_shrink/merge_tree.h	/^    USE_FIRST,$/;"	m	class:merge_and_shrink::UpdateOption
USE_SECOND	merge_and_shrink/merge_tree.h	/^    USE_SECOND,$/;"	m	class:merge_and_shrink::UpdateOption
USE_UP	merge_and_shrink/shrink_bisimulation.h	/^        USE_UP$/;"	e	enum:merge_and_shrink::ShrinkBisimulation::AtLimit
UTIL	utils/util.h	2;"	d
UTILS_COLLECTIONS_H	utils/collections.h	2;"	d
UTILS_COUNTDOWN_TIMER_H	utils/countdown_timer.h	2;"	d
UTILS_HASH_H	utils/hash.h	2;"	d
UTILS_LANGUAGE_H	utils/language.h	2;"	d
UTILS_LOGGING_H	utils/logging.h	2;"	d
UTILS_MARKUP_H	utils/markup.h	2;"	d
UTILS_MATH_H	utils/math.h	2;"	d
UTILS_MEMORY_H	utils/memory.h	2;"	d
UTILS_RNG_H	utils/rng.h	2;"	d
UTILS_RNG_OPTIONS_H	utils/rng_options.h	2;"	d
UTILS_SYSTEM_H	utils/system.h	2;"	d
UTILS_SYSTEM_UNIX_H	utils/system_unix.h	2;"	d
UTILS_SYSTEM_WINDOWS_H	utils/system_windows.h	2;"	d
UTILS_TIMER_H	utils/timer.h	2;"	d
UintSeqHash	bliss/uintseqhash.h	/^  UintSeqHash() {h = 0; }$/;"	f	class:bliss::UintSeqHash
UintSeqHash	bliss/uintseqhash.h	/^  UintSeqHash(const UintSeqHash &other) {h = other.h; }$/;"	f	class:bliss::UintSeqHash
UintSeqHash	bliss/uintseqhash.h	/^class UintSeqHash$/;"	c	namespace:bliss
UnaryOperator	heuristics/relaxation_heuristic.h	/^    UnaryOperator(const std::vector<Proposition *> &pre, Proposition *eff,$/;"	f	struct:relaxation_heuristic::UnaryOperator
UnaryOperator	heuristics/relaxation_heuristic.h	/^struct UnaryOperator {$/;"	s	namespace:relaxation_heuristic
UpdateOption	merge_and_shrink/merge_tree.h	/^enum class UpdateOption {$/;"	c	namespace:merge_and_shrink
VALUE_VERTEX	structural_symmetries/graph_creator.cc	/^enum color_t {PREDICATE_VERTEX, VALUE_VERTEX, PRECOND_VERTEX, EFFECT_VERTEX,$/;"	e	enum:color_t	file:
VARIABLE_ORDER_FINDER_H	variable_order_finder.h	2;"	d
ValueExplanations	options/doc_store.h	/^typedef std::vector<std::pair<std::string, std::string>> ValueExplanations;$/;"	t	namespace:options
ValueNode	domain_transition_graph.h	/^    ValueNode(DomainTransitionGraph *parent, int val)$/;"	f	struct:ValueNode
ValueNode	domain_transition_graph.h	/^struct ValueNode {$/;"	s
ValueTransition	domain_transition_graph.h	/^    ValueTransition(ValueNode *targ)$/;"	f	struct:ValueTransition
ValueTransition	domain_transition_graph.h	/^struct ValueTransition {$/;"	s
ValueTransitionLabel	domain_transition_graph.h	/^    ValueTransitionLabel(int op_id, bool axiom,$/;"	f	struct:ValueTransitionLabel
ValueTransitionLabel	domain_transition_graph.h	/^struct ValueTransitionLabel {$/;"	s
VariableInfo	algorithms/int_packer.cc	/^    VariableInfo()$/;"	f	class:int_packer::IntPacker::VariableInfo
VariableInfo	algorithms/int_packer.cc	/^    VariableInfo(int range_, int bin_index_, int shift_)$/;"	f	class:int_packer::IntPacker::VariableInfo
VariableInfo	algorithms/int_packer.cc	/^class IntPacker::VariableInfo {$/;"	c	class:int_packer::IntPacker	file:
VariableOrderFinder	variable_order_finder.cc	/^VariableOrderFinder::VariableOrderFinder(const TaskProxy &task_proxy,$/;"	f	class:VariableOrderFinder
VariableOrderFinder	variable_order_finder.h	/^class VariableOrderFinder {$/;"	c
VariableOrderType	variable_order_finder.h	/^enum VariableOrderType {$/;"	g
VariableProxy	task_proxy.h	/^    VariableProxy(const AbstractTask &task, int id)$/;"	f	class:VariableProxy
VariableProxy	task_proxy.h	/^class VariableProxy {$/;"	c
VariablesProxy	task_proxy.h	/^    explicit VariablesProxy(const AbstractTask &task)$/;"	f	class:VariablesProxy
VariablesProxy	task_proxy.h	/^class VariablesProxy {$/;"	c
Verbosity	merge_and_shrink/types.h	/^enum class Verbosity {$/;"	c	namespace:merge_and_shrink
Vertex	bliss/graph.cc	/^Digraph::Vertex::Vertex()$/;"	f	class:bliss::Digraph::Vertex
Vertex	bliss/graph.cc	/^Graph::Vertex::Vertex()$/;"	f	class:bliss::Graph::Vertex
Vertex	bliss/graph.h	/^  class Vertex {$/;"	c	class:bliss::Digraph
Vertex	bliss/graph.h	/^  class Vertex {$/;"	c	class:bliss::Graph
WIN32_LEAN_AND_MEAN	utils/system_windows.h	12;"	d
WINDOWS	utils/system.h	6;"	d
WeightedEvaluator	evaluators/weighted_evaluator.cc	/^WeightedEvaluator::WeightedEvaluator(ScalarEvaluator *eval, int weight)$/;"	f	class:weighted_evaluator::WeightedEvaluator
WeightedEvaluator	evaluators/weighted_evaluator.cc	/^WeightedEvaluator::WeightedEvaluator(const Options &opts)$/;"	f	class:weighted_evaluator::WeightedEvaluator
WeightedEvaluator	evaluators/weighted_evaluator.h	/^class WeightedEvaluator : public ScalarEvaluator {$/;"	c	namespace:weighted_evaluator
YES	bliss/graph.cc	/^  static const char YES = 1;$/;"	m	class:bliss::TreeNode	file:
ZeroOnePDBs	pdbs/zero_one_pdbs.cc	/^ZeroOnePDBs::ZeroOnePDBs($/;"	f	class:pdbs::ZeroOnePDBs
ZeroOnePDBs	pdbs/zero_one_pdbs.h	/^class ZeroOnePDBs {$/;"	c	namespace:pdbs
ZeroOnePDBsHeuristic	pdbs/zero_one_pdbs_heuristic.cc	/^ZeroOnePDBsHeuristic::ZeroOnePDBsHeuristic($/;"	f	class:pdbs::ZeroOnePDBsHeuristic
ZeroOnePDBsHeuristic	pdbs/zero_one_pdbs_heuristic.h	/^class ZeroOnePDBsHeuristic : public Heuristic {$/;"	c	namespace:pdbs
_ARGS	utils/util.h	27;"	d
_INTERNAL_ERROR	bliss/graph.cc	37;"	d	file:
_OUT_OF_MEMORY	bliss/defs.cc	/^void _OUT_OF_MEMORY(const char* file, int line) {$/;"	f	namespace:bliss
_add_options_to_parser	landmarks/landmark_factory.cc	/^void _add_options_to_parser(OptionParser &parser) {$/;"	f	namespace:landmarks
_add_succ_order_options	search_engines/lazy_search.cc	/^static void _add_succ_order_options(OptionParser &parser) {$/;"	f	namespace:lazy_search
_allocate	structural_symmetries/operator_permutation.cc	/^void OperatorPermutation::_allocate() {$/;"	f	class:OperatorPermutation
_allocate	structural_symmetries/permutation.cc	/^void Permutation::_allocate() {$/;"	f	class:Permutation
_check_bounds	options/option_parser.cc	/^void _check_bounds($/;"	f	namespace:options
_copy_value_from_permutation	structural_symmetries/permutation.cc	/^void Permutation::_copy_value_from_permutation(const Permutation &perm) {$/;"	f	class:Permutation
_deallocate	structural_symmetries/operator_permutation.cc	/^void OperatorPermutation::_deallocate() {$/;"	f	class:OperatorPermutation
_deallocate	structural_symmetries/permutation.cc	/^void Permutation::_deallocate() {$/;"	f	class:Permutation
_intersect	landmarks/util.cc	/^unordered_map<int, int> _intersect(const unordered_map<int, int> &a, const unordered_map<int, int> &b) {$/;"	f	namespace:landmarks
_intersection	landmarks/landmark_factory_zhu_givan.cc	/^static lm_set _intersection(const lm_set &a, const lm_set &b) {$/;"	f	namespace:landmarks
_inverse_value_from_permutation	structural_symmetries/permutation.cc	/^void Permutation::_inverse_value_from_permutation(const Permutation &perm) {$/;"	f	class:Permutation
_nof_orbits	bliss/orbit.h	/^  unsigned int _nof_orbits;$/;"	m	class:bliss::Orbit
_parse	cegar/additive_cartesian_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:cegar
_parse	evaluators/const_evaluator.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:const_evaluator
_parse	evaluators/g_evaluator.cc	/^static ScalarEvaluator *_parse(OptionParser &parser) {$/;"	f	namespace:g_evaluator
_parse	evaluators/max_evaluator.cc	/^static ScalarEvaluator *_parse(OptionParser &parser) {$/;"	f	namespace:max_evaluator
_parse	evaluators/pref_evaluator.cc	/^static ScalarEvaluator *_parse(OptionParser &parser) {$/;"	f	namespace:pref_evaluator
_parse	evaluators/sum_evaluator.cc	/^static ScalarEvaluator *_parse(OptionParser &parser) {$/;"	f	namespace:sum_evaluator
_parse	evaluators/weighted_evaluator.cc	/^static ScalarEvaluator *_parse(OptionParser &parser) {$/;"	f	namespace:weighted_evaluator
_parse	heuristics/additive_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:additive_heuristic
_parse	heuristics/blind_search_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:blind_search_heuristic
_parse	heuristics/cea_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:cea_heuristic
_parse	heuristics/cg_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:cg_heuristic
_parse	heuristics/ff_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:ff_heuristic
_parse	heuristics/goal_count_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:goal_count_heuristic
_parse	heuristics/hm_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:hm_heuristic
_parse	heuristics/lm_cut_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:lm_cut_heuristic
_parse	heuristics/max_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:max_heuristic
_parse	landmarks/lama_ff_synergy.cc	/^static Synergy *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	landmarks/landmark_count_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	landmarks/landmark_factory_h_m.cc	/^static LandmarkFactory *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	landmarks/landmark_factory_merged.cc	/^static LandmarkFactory *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	landmarks/landmark_factory_rpg_exhaust.cc	/^static LandmarkFactory *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	landmarks/landmark_factory_rpg_sasp.cc	/^static LandmarkFactory *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	landmarks/landmark_factory_zhu_givan.cc	/^static LandmarkFactory *_parse(OptionParser &parser) {$/;"	f	namespace:landmarks
_parse	merge_and_shrink/label_reduction.cc	/^static shared_ptr<LabelReduction>_parse(OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_and_shrink_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_scoring_function_dfp.cc	/^static shared_ptr<MergeScoringFunction>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_scoring_function_goal_relevance.cc	/^static shared_ptr<MergeScoringFunction>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_scoring_function_single_random.cc	/^static shared_ptr<MergeScoringFunction>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_scoring_function_total_order.cc	/^static shared_ptr<MergeScoringFunction>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_selector_score_based_filtering.cc	/^static shared_ptr<MergeSelector>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_strategy_factory_precomputed.cc	/^static shared_ptr<MergeStrategyFactory>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_strategy_factory_stateless.cc	/^static shared_ptr<MergeStrategyFactory>_parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/merge_tree_factory_linear.cc	/^static shared_ptr<MergeTreeFactory> _parse(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/shrink_bisimulation.cc	/^static shared_ptr<ShrinkStrategy>_parse(OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/shrink_fh.cc	/^static shared_ptr<ShrinkStrategy>_parse(OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	merge_and_shrink/shrink_random.cc	/^static shared_ptr<ShrinkStrategy>_parse(OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse	open_lists/alternation_open_list.cc	/^static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {$/;"	f	file:
_parse	open_lists/epsilon_greedy_open_list.cc	/^static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {$/;"	f	file:
_parse	open_lists/pareto_open_list.cc	/^static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {$/;"	f	file:
_parse	open_lists/standard_scalar_open_list.cc	/^static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {$/;"	f	file:
_parse	open_lists/tiebreaking_open_list.cc	/^static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {$/;"	f	file:
_parse	open_lists/type_based_open_list.cc	/^static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {$/;"	f	file:
_parse	operator_counting/lm_cut_constraints.cc	/^static shared_ptr<ConstraintGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:operator_counting
_parse	operator_counting/operator_counting_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:operator_counting
_parse	operator_counting/pho_constraints.cc	/^static shared_ptr<ConstraintGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:operator_counting
_parse	operator_counting/state_equation_constraints.cc	/^static shared_ptr<ConstraintGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:operator_counting
_parse	pdbs/canonical_pdbs_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_collection_generator_combo.cc	/^static shared_ptr<PatternCollectionGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_collection_generator_genetic.cc	/^static shared_ptr<PatternCollectionGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_collection_generator_hillclimbing.cc	/^static shared_ptr<PatternCollectionGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_collection_generator_manual.cc	/^static shared_ptr<PatternCollectionGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_collection_generator_systematic.cc	/^static shared_ptr<PatternCollectionGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_generator_greedy.cc	/^static shared_ptr<PatternGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pattern_generator_manual.cc	/^static shared_ptr<PatternGenerator> _parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/pdb_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	pdbs/zero_one_pdbs_heuristic.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse	potentials/diverse_potential_heuristics.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:potentials
_parse	potentials/sample_based_potential_heuristics.cc	/^static Heuristic *_parse(OptionParser &parser) {$/;"	f	namespace:potentials
_parse	potentials/single_potential_heuristics.cc	/^static Heuristic *_parse(OptionParser &parser, OptimizeFor opt_func) {$/;"	f	namespace:potentials
_parse	pruning/null_pruning_method.cc	/^static shared_ptr<PruningMethod> _parse(OptionParser &parser) {$/;"	f	namespace:null_pruning_method
_parse	pruning/stubborn_sets_ec.cc	/^static shared_ptr<PruningMethod> _parse(OptionParser &parser) {$/;"	f	namespace:stubborn_sets_ec
_parse	pruning/stubborn_sets_simple.cc	/^static shared_ptr<PruningMethod> _parse(OptionParser &parser) {$/;"	f	namespace:stubborn_sets_simple
_parse	search_engines/eager_search.cc	/^static SearchEngine *_parse(OptionParser &parser) {$/;"	f	namespace:eager_search
_parse	search_engines/enforced_hill_climbing_search.cc	/^static SearchEngine *_parse(OptionParser &parser) {$/;"	f	namespace:enforced_hill_climbing_search
_parse	search_engines/iterated_search.cc	/^static SearchEngine *_parse(OptionParser &parser) {$/;"	f	namespace:iterated_search
_parse	search_engines/kstar.cc	/^static SearchEngine *_parse(OptionParser &parser) {$/;"	f	namespace:kstar
_parse	search_engines/lazy_search.cc	/^static SearchEngine *_parse(OptionParser &parser) {$/;"	f	namespace:lazy_search
_parse	search_engines/top_k_eager_search.cc	/^static SearchEngine *_parse(OptionParser &parser) {$/;"	f	namespace:top_k_eager_search
_parse	structural_symmetries/group.cc	/^static shared_ptr<Group> _parse(OptionParser &parser) {$/;"	f	file:
_parse	tasks/cost_adapted_task.cc	/^static shared_ptr<AbstractTask> _parse(OptionParser &parser) {$/;"	f	namespace:tasks
_parse	tasks/root_task.cc	/^static shared_ptr<AbstractTask> _parse(OptionParser &parser) {$/;"	f	namespace:tasks
_parse_all_states_potential	potentials/single_potential_heuristics.cc	/^static Heuristic *_parse_all_states_potential(OptionParser &parser) {$/;"	f	namespace:potentials
_parse_astar	search_engines/eager_search.cc	/^static SearchEngine *_parse_astar(OptionParser &parser) {$/;"	f	namespace:eager_search
_parse_astar	search_engines/top_k_eager_search.cc	/^static SearchEngine *_parse_astar(OptionParser &parser) {$/;"	f	namespace:top_k_eager_search
_parse_dfp	merge_and_shrink/merge_strategy_aliases.cc	/^static shared_ptr<MergeStrategyFactory>_parse_dfp(options::OptionParser &parser) {$/;"	f	namespace:merge_and_shrink
_parse_goals	cegar/subtask_generators.cc	/^static shared_ptr<SubtaskGenerator> _parse_goals(OptionParser &parser) {$/;"	f	namespace:cegar
_parse_greedy	search_engines/eager_search.cc	/^static SearchEngine *_parse_greedy(OptionParser &parser) {$/;"	f	namespace:eager_search
_parse_greedy	search_engines/lazy_search.cc	/^static SearchEngine *_parse_greedy(OptionParser &parser) {$/;"	f	namespace:lazy_search
_parse_greedy	search_engines/top_k_eager_search.cc	/^static SearchEngine *_parse_greedy(OptionParser &parser) {$/;"	f	namespace:top_k_eager_search
_parse_initial_state_potential	potentials/single_potential_heuristics.cc	/^static Heuristic *_parse_initial_state_potential(OptionParser &parser) {$/;"	f	namespace:potentials
_parse_ipdb	pdbs/pattern_collection_generator_hillclimbing.cc	/^static Heuristic *_parse_ipdb(OptionParser &parser) {$/;"	f	namespace:pdbs
_parse_landmarks	cegar/subtask_generators.cc	/^static shared_ptr<SubtaskGenerator> _parse_landmarks(OptionParser &parser) {$/;"	f	namespace:cegar
_parse_linear	merge_and_shrink/merge_strategy_aliases.cc	/^static shared_ptr<MergeStrategyFactory> _parse_linear($/;"	f	namespace:merge_and_shrink
_parse_original	cegar/subtask_generators.cc	/^static shared_ptr<SubtaskGenerator> _parse_original(OptionParser &parser) {$/;"	f	namespace:cegar
_parse_weighted_astar	search_engines/lazy_search.cc	/^static SearchEngine *_parse_weighted_astar(OptionParser &parser) {$/;"	f	namespace:lazy_search
_possibly_fires	landmarks/util.cc	/^bool _possibly_fires(const EffectConditionsProxy &conditions, const vector<vector<int>> &lvl_var) {$/;"	f	namespace:landmarks
_possibly_reaches_lm	landmarks/util.cc	/^bool _possibly_reaches_lm(const OperatorProxy &op, const vector<vector<int>> &lvl_var, const LandmarkNode *lmp) {$/;"	f	namespace:landmarks
_propagate_labels	landmarks/landmark_factory_zhu_givan.cc	/^static bool _propagate_labels(lm_set &labels, const lm_set &new_labels,$/;"	f	namespace:landmarks
_tracer	utils/logging.cc	/^static MemoryTracer _tracer;$/;"	m	namespace:utils	file:
_union	landmarks/landmark_factory_zhu_givan.cc	/^static lm_set _union(const lm_set &a, const lm_set &b) {$/;"	f	namespace:landmarks
abstract_search	cegar/abstraction.h	/^    AbstractSearch abstract_search;$/;"	m	class:cegar::Abstraction
achievers	pruning/stubborn_sets.h	/^    std::vector<std::vector<std::vector<int>>> achievers;$/;"	m	class:stubborn_sets::StubbornSets
achieves_non_conditional	landmarks/landmark_factory.cc	/^bool LandmarkFactory::achieves_non_conditional(const OperatorProxy &o,$/;"	f	class:landmarks::LandmarkFactory
action_cost	heuristics/cea_heuristic.cc	/^    int action_cost;$/;"	m	struct:cea_heuristic::LocalTransition	file:
active_ops	pruning/stubborn_sets_ec.h	/^    std::vector<bool> active_ops;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
add	cegar/domains.cc	/^void Domains::add(int var, int value) {$/;"	f	class:cegar::Domains
add_all	cegar/domains.cc	/^void Domains::add_all(int var) {$/;"	f	class:cegar::Domains
add_arg	options/doc_store.cc	/^void DocStore::add_arg(string k,$/;"	f	class:options::DocStore
add_conflicting_and_disabling	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::add_conflicting_and_disabling(int op_no,$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
add_constraints	operator_counting/state_equation_constraints.cc	/^void StateEquationConstraints::add_constraints($/;"	f	class:operator_counting::StateEquationConstraints
add_cost_type_option_to_parser	operator_cost.cc	/^void add_cost_type_option_to_parser(OptionParser &parser) {$/;"	f
add_dtg_successor	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::add_dtg_successor(int var_id, int pre, int post) {$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
add_edge	bliss/graph.cc	/^Digraph::add_edge(const unsigned int vertex1, const unsigned int vertex2)$/;"	f	class:bliss::Digraph
add_edge	bliss/graph.cc	/^Graph::Vertex::add_edge(const unsigned int other_vertex)$/;"	f	class:bliss::Graph::Vertex
add_edge	bliss/graph.cc	/^Graph::add_edge(const unsigned int vertex1, const unsigned int vertex2)$/;"	f	class:bliss::Graph
add_edge	utils/util.h	/^inline void add_edge(int from_id, int to_id, std::string label, std::stringstream &stream)$/;"	f
add_edge_from	bliss/graph.cc	/^Digraph::Vertex::add_edge_from(const unsigned int other_vertex)$/;"	f	class:bliss::Digraph::Vertex
add_edge_to	bliss/graph.cc	/^Digraph::Vertex::add_edge_to(const unsigned int other_vertex)$/;"	f	class:bliss::Digraph::Vertex
add_empty_block	algorithms/equivalence_relation.cc	/^BlockListIter EquivalenceRelation::add_empty_block() {$/;"	f	class:equivalence_relation::EquivalenceRelation
add_enum_option	options/option_parser.cc	/^void OptionParser::add_enum_option(string k,$/;"	f	class:options::OptionParser
add_fact_order_option	cegar/subtask_generators.cc	/^static void add_fact_order_option(OptionParser &parser) {$/;"	f	namespace:cegar
add_feature	options/doc_store.cc	/^void DocStore::add_feature(string k,$/;"	f	class:options::DocStore
add_first_plan	search_engines/kstar.cc	/^void KStar::add_first_plan() {$/;"	f	class:kstar::KStar
add_forbid_plan_reformulation_option	search_engines/eager_search.cc	/^void add_forbid_plan_reformulation_option(OptionParser &parser) {$/;"	f	namespace:eager_search
add_generator	structural_symmetries/group.cc	/^void Group::add_generator(const Permutation *gen) {$/;"	f	class:Group
add_goal_heap_top	search_engines/kstar.cc	/^void KStar::add_goal_heap_top() {$/;"	f	class:kstar::KStar
add_hillclimbing_options	pdbs/pattern_collection_generator_hillclimbing.cc	/^void add_hillclimbing_options(OptionParser &parser) {$/;"	f	namespace:pdbs
add_incoming_transition	cegar/abstract_state.cc	/^void AbstractState::add_incoming_transition(int op_id, AbstractState *src) {$/;"	f	class:cegar::AbstractState
add_indices_to_constraint	operator_counting/state_equation_constraints.cc	/^void add_indices_to_constraint(lp::LPConstraint &constraint,$/;"	f	namespace:operator_counting
add_interfering	pruning/stubborn_sets_simple.cc	/^void StubbornSetsSimple::add_interfering(int op_no) {$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
add_label_group	merge_and_shrink/label_equivalence_relation.cc	/^int LabelEquivalenceRelation::add_label_group(const vector<int> &new_labels) {$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
add_label_to_group	merge_and_shrink/label_equivalence_relation.cc	/^void LabelEquivalenceRelation::add_label_to_group(int group_id,$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
add_list_option	options/option_parser.h	/^void OptionParser::add_list_option($/;"	f	class:options::OptionParser
add_lm_forward_orders	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::add_lm_forward_orders() {$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
add_lm_node	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::add_lm_node(int set_index, bool goal) {$/;"	f	class:landmarks::LandmarkFactoryHM
add_loop	cegar/abstract_state.cc	/^void AbstractState::add_loop(int op_id) {$/;"	f	class:cegar::AbstractState
add_loop	cegar/transition_updater.cc	/^void TransitionUpdater::add_loop(AbstractState *state, int op_id) {$/;"	f	class:cegar::TransitionUpdater
add_loops_to_trivial_abstract_state	cegar/transition_updater.cc	/^void TransitionUpdater::add_loops_to_trivial_abstract_state(AbstractState *state) {$/;"	f	class:cegar::TransitionUpdater
add_lp_solver_option_to_parser	lp/lp_solver.cc	/^void add_lp_solver_option_to_parser(OptionParser &parser) {$/;"	f	namespace:lp
add_necessary_enabling_set	pruning/stubborn_sets_simple.cc	/^void StubbornSetsSimple::add_necessary_enabling_set(const FactPair &fact) {$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
add_nes_for_fact	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::add_nes_for_fact(const FactPair &fact, const State &state) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
add_node	utils/util.h	/^inline void add_node(int id, std::string label, std::stringstream &stream)$/;"	f
add_note	options/doc_store.cc	/^void DocStore::add_note(string k,$/;"	f	class:options::DocStore
add_operator_and_propositions_to_list	landmarks/landmark_factory.cc	/^void LandmarkFactory::add_operator_and_propositions_to_list(const OperatorProxy &op,$/;"	f	class:landmarks::LandmarkFactory
add_operator_directed_graph	structural_symmetries/graph_creator.cc	/^void GraphCreator::add_operator_directed_graph(bliss::Digraph &bliss_graph,$/;"	f	class:GraphCreator
add_operator_generator	structural_symmetries/group.cc	/^void Group::add_operator_generator(const unsigned int * full_perm) {$/;"	f	class:Group
add_operator_to_triggers	landmarks/landmark_factory_zhu_givan.cc	/^void LandmarkFactoryZhuGivan::add_operator_to_triggers(const OperatorProxy &op) {$/;"	f	class:landmarks::LandmarkFactoryZhuGivan
add_option	options/option_parser.h	/^void OptionParser::add_option($/;"	f	class:options::OptionParser
add_options_to_parser	heuristic.cc	/^void Heuristic::add_options_to_parser(OptionParser &parser) {$/;"	f	class:Heuristic
add_options_to_parser	merge_and_shrink/merge_scoring_function_total_order.cc	/^void MergeScoringFunctionTotalOrder::add_options_to_parser($/;"	f	class:merge_and_shrink::MergeScoringFunctionTotalOrder
add_options_to_parser	merge_and_shrink/merge_tree_factory.cc	/^void MergeTreeFactory::add_options_to_parser(options::OptionParser &parser) {$/;"	f	class:merge_and_shrink::MergeTreeFactory
add_options_to_parser	merge_and_shrink/merge_tree_factory_linear.cc	/^void MergeTreeFactoryLinear::add_options_to_parser($/;"	f	class:merge_and_shrink::MergeTreeFactoryLinear
add_options_to_parser	merge_and_shrink/shrink_bucket_based.cc	/^void ShrinkBucketBased::add_options_to_parser(options::OptionParser &parser) {$/;"	f	class:merge_and_shrink::ShrinkBucketBased
add_options_to_parser	search_engine.cc	/^void SearchEngine::add_options_to_parser(OptionParser &parser) {$/;"	f	class:SearchEngine
add_outgoing_transition	cegar/abstract_state.cc	/^void AbstractState::add_outgoing_transition(int op_id, AbstractState *target) {$/;"	f	class:cegar::AbstractState
add_pair	causal_graph.cc	/^void IntRelationBuilder::add_pair(int u, int v) {$/;"	f	class:IntRelationBuilder
add_pdb	pdbs/incremental_canonical_pdbs.cc	/^void IncrementalCanonicalPDBs::add_pdb(const shared_ptr<PatternDatabase> &pdb) {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
add_pdb_for_pattern	pdbs/incremental_canonical_pdbs.cc	/^void IncrementalCanonicalPDBs::add_pdb_for_pattern(const Pattern &pattern) {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
add_permutation	structural_symmetries/group.cc	/^void Group::add_permutation(void* param, unsigned int, const unsigned int * full_perm){$/;"	f	class:Group
add_property	options/doc_store.cc	/^void DocStore::add_property(string k,$/;"	f	class:options::DocStore
add_pruning_option	search_engines/eager_search.cc	/^void add_pruning_option(OptionParser &parser) {$/;"	f	namespace:eager_search
add_pruning_option	search_engines/top_k_eager_search.cc	/^void add_pruning_option(OptionParser &parser) {$/;"	f	namespace:top_k_eager_search
add_relaxed_operator	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::add_relaxed_operator($/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
add_rng_options	utils/rng_options.cc	/^void add_rng_options(options::OptionParser &parser) {$/;"	f	namespace:utils
add_segment	algorithms/segmented_vector.h	/^    void add_segment() {$/;"	f	class:segmented_vector::SegmentedArrayVector
add_segment	algorithms/segmented_vector.h	/^    void add_segment() {$/;"	f	class:segmented_vector::SegmentedVector
add_shrink_limit_options_to_parser	merge_and_shrink/merge_and_shrink_heuristic.cc	/^void MergeAndShrinkHeuristic::add_shrink_limit_options_to_parser(OptionParser &parser) {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
add_temporary_constraints	lp/lp_solver.cc	/^void LPSolver::add_temporary_constraints(const vector<LPConstraint> &constraints) {$/;"	f	class:lp::LPSolver
add_to_heap	heuristics/cea_heuristic.cc	/^inline void ContextEnhancedAdditiveHeuristic::add_to_heap($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
add_top_k_option	search_engines/top_k_eager_search.cc	/^void add_top_k_option(OptionParser &parser) {$/;"	f	namespace:top_k_eager_search
add_transition	cegar/transition_updater.cc	/^void TransitionUpdater::add_transition($/;"	f	class:cegar::TransitionUpdater
add_transition	merge_and_shrink/fts_factory.cc	/^void FTSFactory::add_transition(int var_no, int label_no,$/;"	f	class:merge_and_shrink::FTSFactory
add_value_explanations	options/doc_store.cc	/^void DocStore::add_value_explanations(string k,$/;"	f	class:options::DocStore
add_vertex	bliss/graph.cc	/^Digraph::add_vertex(const unsigned int color)$/;"	f	class:bliss::Digraph
add_vertex	bliss/graph.cc	/^Graph::add_vertex(const unsigned int color)$/;"	f	class:bliss::Graph
add_virtual_pushes	algorithms/priority_queues.h	/^    virtual void add_virtual_pushes(int \/*num_extra_pushes*\/) {$/;"	f	class:priority_queues::HeapQueue
add_virtual_pushes	algorithms/priority_queues.h	/^    virtual void add_virtual_pushes(int num_extra_pushes) {$/;"	f	class:priority_queues::BucketQueue
add_virtual_pushes	algorithms/priority_queues.h	/^    void add_virtual_pushes(int num_extra_pushes) {$/;"	f	class:priority_queues::AdaptiveQueue
additive_heuristic	cegar/split_selector.h	/^    std::unique_ptr<additive_heuristic::AdditiveHeuristic> additive_heuristic;$/;"	m	class:cegar::SplitSelector
additive_heuristic	cegar/split_selector.h	/^namespace additive_heuristic {$/;"	n
additive_heuristic	cegar/utils.h	/^namespace additive_heuristic {$/;"	n
additive_heuristic	heuristics/additive_heuristic.cc	/^namespace additive_heuristic {$/;"	n	file:
additive_heuristic	heuristics/additive_heuristic.h	/^namespace additive_heuristic {$/;"	n
adjust_heap_up	open_lists/epsilon_greedy_open_list.cc	/^static void adjust_heap_up(vector<HeapNode> &heap, size_t pos) {$/;"	f	file:
admissible	landmarks/landmark_count_heuristic.h	/^    const bool admissible;$/;"	m	class:landmarks::LandmarkCountHeuristic
affected	structural_symmetries/permutation.h	/^    std::vector<bool> affected;$/;"	m	class:Permutation
affected_vars_cycles	structural_symmetries/permutation.h	/^    std::vector<std::vector<int> > affected_vars_cycles;$/;"	m	class:Permutation
all_dead_ends_are_reliable	evaluators/combining_evaluator.h	/^    bool all_dead_ends_are_reliable;$/;"	m	class:combining_evaluator::CombiningEvaluator
alloc_	ext/tree.hh	/^		tree_node_allocator alloc_;$/;"	m	class:tree
allocate_graphs_and_nodes	domain_transition_graph.cc	/^void DTGFactory::allocate_graphs_and_nodes(vector<DomainTransitionGraph *> &dtgs) {$/;"	f	class:DTGFactory
allow_unsafe_pruning	open_lists/tiebreaking_open_list.cc	/^    bool allow_unsafe_pruning;$/;"	m	class:TieBreakingOpenList	file:
always_consumed_by	operator_counting/state_equation_constraints.h	/^    std::set<int> always_consumed_by;$/;"	m	struct:operator_counting::Proposition
always_produced_by	operator_counting/state_equation_constraints.h	/^    std::set<int> always_produced_by;$/;"	m	struct:operator_counting::Proposition
any_cast	options/any.h	/^ValueType *any_cast(Any *operand) {$/;"	f	namespace:options
any_cast	options/any.h	/^ValueType any_cast(Any &operand) {$/;"	f	namespace:options
any_cast	options/any.h	/^inline ValueType any_cast(const Any &operand) {$/;"	f	namespace:options
any_cast	options/any.h	/^inline const ValueType *any_cast(const Any *operand) {$/;"	f	namespace:options
append_child	ext/tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position)$/;"	f	class:tree
append_child	ext/tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position, const T& x)$/;"	f	class:tree
append_child	ext/tree.hh	/^iter tree<T, tree_node_allocator>::append_child(iter position, iter other)$/;"	f	class:tree
append_children	ext/tree.hh	/^iter tree<T, tree_node_allocator>::append_children(iter position, sibling_iterator from, sibling_iterator to)$/;"	f	class:tree
applicable_operators	pdbs/match_tree.cc	/^    vector<const AbstractOperator *> applicable_operators;$/;"	m	struct:pdbs::MatchTree::Node	file:
applicable_operators	successor_generator.cc	/^    list<OperatorProxy> applicable_operators;$/;"	m	class:GeneratorLeaf	file:
apply_abstraction	merge_and_shrink/distances.cc	/^void Distances::apply_abstraction($/;"	f	class:merge_and_shrink::Distances
apply_abstraction	merge_and_shrink/factored_transition_system.cc	/^bool FactoredTransitionSystem::apply_abstraction($/;"	f	class:merge_and_shrink::FactoredTransitionSystem
apply_abstraction	merge_and_shrink/transition_system.cc	/^bool TransitionSystem::apply_abstraction($/;"	f	class:merge_and_shrink::TransitionSystem
apply_abstraction_to_lookup_table	merge_and_shrink/merge_and_shrink_representation.cc	/^void MergeAndShrinkRepresentationLeaf::apply_abstraction_to_lookup_table($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
apply_abstraction_to_lookup_table	merge_and_shrink/merge_and_shrink_representation.cc	/^void MergeAndShrinkRepresentationMerge::apply_abstraction_to_lookup_table($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
apply_label_mapping	merge_and_shrink/label_equivalence_relation.cc	/^void LabelEquivalenceRelation::apply_label_mapping($/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
apply_label_reduction	merge_and_shrink/factored_transition_system.cc	/^void FactoredTransitionSystem::apply_label_reduction($/;"	f	class:merge_and_shrink::FactoredTransitionSystem
apply_label_reduction	merge_and_shrink/transition_system.cc	/^void TransitionSystem::apply_label_reduction($/;"	f	class:merge_and_shrink::TransitionSystem
apply_operator_and_propagate_labels	landmarks/landmark_factory_zhu_givan.cc	/^lm_set LandmarkFactoryZhuGivan::apply_operator_and_propagate_labels($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
apply_s5	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::apply_s5(int op_no, const State &state) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
approximate_lookahead_orders	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::approximate_lookahead_orders($/;"	f	class:landmarks::LandmarkFactoryRpgSasp
approximate_reasonable_orders	landmarks/landmark_factory.cc	/^void LandmarkFactory::approximate_reasonable_orders($/;"	f	class:landmarks::LandmarkFactory
are_additive	pdbs/incremental_canonical_pdbs.h	/^    VariableAdditivity are_additive;$/;"	m	class:pdbs::IncrementalCanonicalPDBs
are_distances_computed	merge_and_shrink/distances.cc	/^bool Distances::are_distances_computed() const {$/;"	f	class:merge_and_shrink::Distances
are_facts_mutex	tasks/delegating_task.cc	/^bool DelegatingTask::are_facts_mutex(const FactPair &fact1, const FactPair &fact2) const {$/;"	f	class:tasks::DelegatingTask
are_facts_mutex	tasks/domain_abstracted_task.cc	/^bool DomainAbstractedTask::are_facts_mutex(const FactPair &, const FactPair &) const {$/;"	f	class:extra_tasks::DomainAbstractedTask
are_facts_mutex	tasks/plan_forbid_reformulated_task.cc	/^bool PlanForbidReformulatedTask::are_facts_mutex(const FactPair &fact1, const FactPair &fact2) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
are_facts_mutex	tasks/root_task.cc	/^bool RootTask::are_facts_mutex(const FactPair &fact1, const FactPair &fact2) const {$/;"	f	class:tasks::RootTask
are_mutex	globals.cc	/^bool are_mutex(const FactPair &a, const FactPair &b) {$/;"	f
are_patterns_additive	pdbs/max_additive_pdb_sets.cc	/^bool are_patterns_additive(const Pattern &pattern1,$/;"	f	namespace:pdbs
are_transitions_sorted_unique	merge_and_shrink/transition_system.cc	/^bool TransitionSystem::are_transitions_sorted_unique() const {$/;"	f	class:merge_and_shrink::TransitionSystem
arg_help	options/doc_store.h	/^    std::vector<ArgumentInfo> arg_help;$/;"	m	struct:options::DocStruct
array	bliss/heap.h	/^  unsigned int *array;$/;"	m	class:bliss::Heap
arrays_per_segment	algorithms/segmented_vector.h	/^    const size_t arrays_per_segment;$/;"	m	class:segmented_vector::SegmentedArrayVector
artificial_goal	heuristics/lm_cut_landmarks.h	/^    RelaxedProposition artificial_goal;$/;"	m	class:lm_cut_heuristic::LandmarkCutLandmarks
artificial_precondition	heuristics/lm_cut_landmarks.h	/^    RelaxedProposition artificial_precondition;$/;"	m	class:lm_cut_heuristic::LandmarkCutLandmarks
assign	bliss/bignum.h	/^  void assign(const int n) {mpz_set_si(v, n); }$/;"	f	class:bliss::BigNum
assign_id	landmarks/landmark_graph.h	/^    void assign_id(int new_id) {$/;"	f	class:landmarks::EdgeType::LandmarkNode
astar_search	cegar/abstract_search.cc	/^AbstractState *AbstractSearch::astar_search($/;"	f	class:cegar::AbstractSearch
at_limit	merge_and_shrink/shrink_bisimulation.h	/^    const AtLimit at_limit;$/;"	m	class:merge_and_shrink::ShrinkBisimulation
atomic_before_product	merge_and_shrink/merge_scoring_function_total_order.h	/^    bool atomic_before_product;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
atomic_ts_order	merge_and_shrink/merge_scoring_function_total_order.h	/^    AtomicTSOrder atomic_ts_order;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
aux_split_in_two	bliss/partition.cc	/^Partition::aux_split_in_two(Partition::Cell* const cell,$/;"	f	class:bliss::Partition
axiom_evaluator	state_registry.h	/^    AxiomEvaluator &axiom_evaluator;$/;"	m	class:StateRegistry
axiom_literals	axioms.h	/^    std::vector<std::vector<AxiomLiteral>> axiom_literals;$/;"	m	class:AxiomEvaluator
backwards_dijkstra	cegar/abstract_search.cc	/^void AbstractSearch::backwards_dijkstra(const AbstractStates goals) {$/;"	f	class:cegar::AbstractSearch
base_cost	heuristics/lm_cut_landmarks.h	/^    int base_cost; \/\/ 0 for axioms, 1 for regular operators$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
base_cost	heuristics/relaxation_heuristic.h	/^    int base_cost;$/;"	m	struct:relaxation_heuristic::UnaryOperator
base_cost	landmarks/exploration.h	/^    int base_cost; \/\/ 0 for axioms, 1 for regular operators$/;"	m	struct:landmarks::ExUnaryOperator
base_priority	heuristics/cea_heuristic.cc	/^    int base_priority;$/;"	m	struct:cea_heuristic::LocalProblem	file:
begin	algorithms/equivalence_relation.h	/^    BlockListConstIter begin() const {return blocks.begin(); }$/;"	f	class:equivalence_relation::EquivalenceRelation
begin	algorithms/equivalence_relation.h	/^    ElementListConstIter begin() const {return elements.begin(); }$/;"	f	class:equivalence_relation::Block
begin	algorithms/equivalence_relation.h	/^    ElementListIter begin() {return elements.begin(); }$/;"	f	class:equivalence_relation::Block
begin	algorithms/ordered_set.h	/^    typename std::vector<T>::const_iterator begin() const {$/;"	f	class:ordered_set::OrderedSet
begin	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::begin() const$/;"	f	class:tree
begin	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::begin(const iterator_base& pos) const$/;"	f	class:tree
begin	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::iterator_base::begin() const$/;"	f	class:tree::iterator_base
begin	merge_and_shrink/factored_transition_system.h	/^    FTSConstIterator begin() const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
begin	merge_and_shrink/label_equivalence_relation.h	/^    LabelConstIter begin() const {$/;"	f	class:merge_and_shrink::LabelGroup
begin	merge_and_shrink/transition_system.h	/^    TSConstIterator begin() const {$/;"	f	class:merge_and_shrink::TransitionSystem
begin	options/registries.h	/^    Map::const_iterator begin() const {$/;"	f	class:options::PluginTypeRegistry
begin	per_state_information.h	/^    const_iterator begin(const StateRegistry *registry) const {$/;"	f	class:PerStateInformation
begin	task_proxy.h	/^    FactsProxyIterator begin() const {$/;"	f	class:FactsProxy
begin	task_proxy.h	/^inline ProxyIterator<ProxyCollection> begin(ProxyCollection &collection) {$/;"	f
begin_breadth_first	ext/tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::begin_breadth_first() const$/;"	f	class:tree
begin_fixed	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::begin_fixed(const iterator_base& pos, unsigned int dp) const$/;"	f	class:tree
begin_leaf	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::begin_leaf() const$/;"	f	class:tree
begin_leaf	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::begin_leaf(const iterator_base& top) const$/;"	f	class:tree
begin_post	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::begin_post() const$/;"	f	class:tree
best_bound	search_engines/iterated_search.h	/^    int best_bound;$/;"	m	class:iterated_search::IteratedSearch
best_checked	bliss/graph.h	/^    bool best_checked;$/;"	m	class:bliss::AbstractGraph::CR_CEP
best_fitness	pdbs/pattern_collection_generator_genetic.h	/^    double best_fitness;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
best_heuristic_values	search_progress.h	/^    std::unordered_map<const Heuristic *, int> best_heuristic_values;$/;"	m	class:SearchProgress
best_path_automorphism	bliss/graph.h	/^  unsigned int *best_path_automorphism;$/;"	m	class:bliss::AbstractGraph
best_path_labeling	bliss/graph.h	/^  unsigned int *best_path_labeling;$/;"	m	class:bliss::AbstractGraph
best_path_labeling_inv	bliss/graph.h	/^  unsigned int *best_path_labeling_inv;$/;"	m	class:bliss::AbstractGraph
best_path_orbits	bliss/graph.h	/^  Orbit         best_path_orbits;$/;"	m	class:bliss::AbstractGraph
best_patterns	pdbs/pattern_collection_generator_genetic.h	/^    std::shared_ptr<PatternCollection> best_patterns;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
bin_index	algorithms/int_packer.cc	/^    int bin_index;$/;"	m	class:int_packer::IntPacker::VariableInfo	file:
bin_packing	pdbs/pattern_collection_generator_genetic.cc	/^void PatternCollectionGeneratorGenetic::bin_packing() {$/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
bit_index	algorithms/dynamic_bitset.h	/^    static std::size_t bit_index(std::size_t pos) {$/;"	f	class:dynamic_bitset::DynamicBitset
bit_mask	algorithms/dynamic_bitset.h	/^    static Block bit_mask(std::size_t pos) {$/;"	f	class:dynamic_bitset::DynamicBitset
bits_per_block	algorithms/dynamic_bitset.h	/^    static const int bits_per_block = std::numeric_limits<Block>::digits;$/;"	m	class:dynamic_bitset::DynamicBitset
blind_search_heuristic	heuristics/blind_search_heuristic.cc	/^namespace blind_search_heuristic {$/;"	n	file:
blind_search_heuristic	heuristics/blind_search_heuristic.h	/^namespace blind_search_heuristic {$/;"	n
bliss	bliss/bignum.h	/^namespace bliss {$/;"	n
bliss	bliss/defs.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/defs.h	/^namespace bliss {$/;"	n
bliss	bliss/graph.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/graph.h	/^namespace bliss {$/;"	n
bliss	bliss/heap.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/heap.h	/^namespace bliss {$/;"	n
bliss	bliss/kqueue.h	/^namespace bliss {$/;"	n
bliss	bliss/kstack.h	/^namespace bliss {$/;"	n
bliss	bliss/orbit.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/orbit.h	/^namespace bliss {$/;"	n
bliss	bliss/partition.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/partition.h	/^namespace bliss {$/;"	n
bliss	bliss/timer.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/timer.h	/^namespace bliss {$/;"	n
bliss	bliss/uintseqhash.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/uintseqhash.h	/^namespace bliss {$/;"	n
bliss	bliss/utils.cc	/^namespace bliss {$/;"	n	file:
bliss	bliss/utils.h	/^namespace bliss {$/;"	n
bliss	structural_symmetries/graph_creator.h	/^namespace bliss {$/;"	n
block_index	algorithms/dynamic_bitset.h	/^    static std::size_t block_index(std::size_t pos) {$/;"	f	class:dynamic_bitset::DynamicBitset
block_name	utils/logging.h	/^    std::string block_name;$/;"	m	class:utils::TraceBlock
block_stack	utils/logging.cc	/^    vector<string> block_stack;$/;"	m	class:utils::MemoryTracer	file:
blocks	algorithms/dynamic_bitset.h	/^    std::vector<Block> blocks;$/;"	m	class:dynamic_bitset::DynamicBitset
blocks	algorithms/equivalence_relation.h	/^    std::list<Block> blocks;$/;"	m	class:equivalence_relation::EquivalenceRelation
boost_amount	open_lists/alternation_open_list.cc	/^    const int boost_amount;$/;"	m	class:AlternationOpenList	file:
boost_preferred	open_lists/alternation_open_list.cc	/^void AlternationOpenList<Entry>::boost_preferred() {$/;"	f	class:AlternationOpenList
boost_preferred	open_lists/open_list.h	/^void OpenList<Entry>::boost_preferred() {$/;"	f	class:OpenList
bound	search_engine.h	/^    int bound;$/;"	m	class:SearchEngine
bounds	options/doc_store.h	/^    Bounds bounds;$/;"	m	struct:options::ArgumentInfo
breadth_first_iterator	ext/tree.hh	/^		typedef breadth_first_queued_iterator breadth_first_iterator;$/;"	t	class:tree
breadth_first_queued_iterator	ext/tree.hh	/^		class breadth_first_queued_iterator : public iterator_base {$/;"	c	class:tree
breadth_first_queued_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator()$/;"	f	class:tree::breadth_first_queued_iterator
breadth_first_queued_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator(const iterator_base& other)$/;"	f	class:tree::breadth_first_queued_iterator
breadth_first_queued_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::breadth_first_queued_iterator::breadth_first_queued_iterator(tree_node *tn)$/;"	f	class:tree::breadth_first_queued_iterator
breadth_first_search	merge_and_shrink/distances.cc	/^static void breadth_first_search($/;"	f	namespace:merge_and_shrink
bt_stack	bliss/partition.h	/^  std::vector<BacktrackInfo> bt_stack;$/;"	m	class:bliss::Partition
buckets	algorithms/priority_queues.h	/^    std::vector<Bucket> buckets;$/;"	m	class:priority_queues::BucketQueue
buckets	open_lists/pareto_open_list.cc	/^    BucketMap buckets;$/;"	m	class:ParetoOpenList	file:
buckets	open_lists/standard_scalar_open_list.cc	/^    map<int, Bucket> buckets;$/;"	m	class:StandardScalarOpenList	file:
buffer	global_state.h	/^    const PackedStateBin *buffer;$/;"	m	class:GlobalState
build	cegar/abstraction.cc	/^void Abstraction::build(utils::RandomNumberGenerator &rng) {$/;"	f	class:cegar::Abstraction
build	merge_and_shrink/merge_and_shrink_heuristic.cc	/^void MergeAndShrinkHeuristic::build(const utils::Timer &timer) {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
build_abstract_operators	pdbs/pattern_database.cc	/^void PatternDatabase::build_abstract_operators($/;"	f	class:pdbs::PatternDatabase
build_abstractions	cegar/cost_saturation.cc	/^void CostSaturation::build_abstractions($/;"	f	class:cegar::CostSaturation
build_disjunction_classes	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::build_disjunction_classes(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
build_domain_abstracted_task	cegar/subtask_generators.cc	/^shared_ptr<AbstractTask> LandmarkDecomposition::build_domain_abstracted_task($/;"	f	class:cegar::LandmarkDecomposition
build_domain_abstracted_task	tasks/domain_abstracted_task_factory.cc	/^shared_ptr<AbstractTask> build_domain_abstracted_task($/;"	f	namespace:extra_tasks
build_dtg_successors	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::build_dtg_successors(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
build_dtgs	domain_transition_graph.cc	/^vector<DomainTransitionGraph *> DTGFactory::build_dtgs() {$/;"	f	class:DTGFactory
build_dtgs	pruning/stubborn_sets_ec.cc	/^vector<StubbornDTG> build_dtgs(TaskProxy task_proxy) {$/;"	f	namespace:stubborn_sets_ec
build_label_equivalence_relation	merge_and_shrink/fts_factory.cc	/^void FTSFactory::build_label_equivalence_relation($/;"	f	class:merge_and_shrink::FTSFactory
build_patterns	pdbs/pattern_collection_generator_systematic.cc	/^void PatternCollectionGeneratorSystematic::build_patterns($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
build_patterns_naive	pdbs/pattern_collection_generator_systematic.cc	/^void PatternCollectionGeneratorSystematic::build_patterns_naive($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
build_pm_ops	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::build_pm_ops(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkFactoryHM
build_problem_for_goal	heuristics/cea_heuristic.cc	/^LocalProblem *ContextEnhancedAdditiveHeuristic::build_problem_for_goal() const {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
build_problem_for_variable	heuristics/cea_heuristic.cc	/^LocalProblem *ContextEnhancedAdditiveHeuristic::build_problem_for_variable($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
build_propositions	operator_counting/state_equation_constraints.cc	/^void StateEquationConstraints::build_propositions(const TaskProxy &task_proxy) {$/;"	f	class:operator_counting::StateEquationConstraints
build_reachability_map	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::build_reachability_map(const TaskProxy &task_proxy) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
build_relaxed_operator	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::build_relaxed_operator(const OperatorProxy &op) {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
build_relaxed_plan_graph_with_labels	landmarks/landmark_factory_zhu_givan.cc	/^LandmarkFactoryZhuGivan::PropositionLayer LandmarkFactoryZhuGivan::build_relaxed_plan_graph_with_labels($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
build_sga_patterns	pdbs/pattern_collection_generator_systematic.cc	/^void PatternCollectionGeneratorSystematic::build_sga_patterns($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
build_state_data	merge_and_shrink/fts_factory.cc	/^void FTSFactory::build_state_data(VariableProxy var) {$/;"	f	class:merge_and_shrink::FTSFactory
build_transitions	merge_and_shrink/fts_factory.cc	/^void FTSFactory::build_transitions() {$/;"	f	class:merge_and_shrink::FTSFactory
build_transitions_for_irrelevant_ops	merge_and_shrink/fts_factory.cc	/^void FTSFactory::build_transitions_for_irrelevant_ops(VariableProxy variable) {$/;"	f	class:merge_and_shrink::FTSFactory
build_transitions_for_operator	merge_and_shrink/fts_factory.cc	/^void FTSFactory::build_transitions_for_operator(OperatorProxy op) {$/;"	f	class:merge_and_shrink::FTSFactory
build_unary_operators	heuristics/relaxation_heuristic.cc	/^void RelaxationHeuristic::build_unary_operators(const OperatorProxy &op, int op_no) {$/;"	f	class:relaxation_heuristic::RelaxationHeuristic
build_unary_operators	landmarks/exploration.cc	/^void Exploration::build_unary_operators(const OperatorProxy &op) {$/;"	f	class:landmarks::Exploration
cache	evaluation_context.h	/^    HeuristicCache cache;$/;"	m	class:EvaluationContext
cache	heuristics/cg_cache.h	/^    std::vector<std::vector<int>> cache;$/;"	m	class:cg_heuristic::CGCache
cache	heuristics/cg_heuristic.h	/^    CGCache *cache;$/;"	m	class:cg_heuristic::CGHeuristic
cache_h_values	heuristic.h	/^    bool cache_h_values;$/;"	m	class:Heuristic
cache_hits	heuristics/cg_heuristic.h	/^    int cache_hits;$/;"	m	class:cg_heuristic::CGHeuristic
cache_misses	heuristics/cg_heuristic.h	/^    int cache_misses;$/;"	m	class:cg_heuristic::CGHeuristic
cached_entries	per_state_information.h	/^    mutable segmented_vector::SegmentedVector<Entry> *cached_entries;$/;"	m	class:PerStateInformation
cached_initial_state	state_registry.h	/^    GlobalState *cached_initial_state;$/;"	m	class:StateRegistry
cached_registry	per_state_information.h	/^    mutable const StateRegistry *cached_registry;$/;"	m	class:PerStateInformation
calc_achievers	landmarks/landmark_factory.cc	/^void LandmarkFactory::calc_achievers(const TaskProxy &task_proxy, Exploration &exploration) {$/;"	f	class:landmarks::LandmarkFactory
calc_achievers	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::calc_achievers(const TaskProxy &task_proxy, Exploration &) {$/;"	f	class:landmarks::LandmarkFactoryHM
calculate_lms_cost	landmarks/landmark_factory.cc	/^int LandmarkFactory::calculate_lms_cost() const {$/;"	f	class:landmarks::LandmarkFactory
calculate_plan_cost	globals.cc	/^int calculate_plan_cost(const vector<const GlobalOperator *> &plan) {$/;"	f
calculate_preferred	evaluation_context.h	/^    bool calculate_preferred;$/;"	m	class:EvaluationContext
can_conflict	pruning/stubborn_sets.cc	/^bool StubbornSets::can_conflict(int op1_no, int op2_no) const {$/;"	f	class:stubborn_sets::StubbornSets
can_disable	pruning/stubborn_sets.cc	/^bool StubbornSets::can_disable(int op1_no, int op2_no) const {$/;"	f	class:stubborn_sets::StubbornSets
canonical_form	bliss/graph.cc	/^AbstractGraph::canonical_form(Stats& stats,$/;"	f	class:bliss::AbstractGraph
canonical_pdbs	pdbs/canonical_pdbs_heuristic.h	/^    CanonicalPDBs canonical_pdbs;$/;"	m	class:pdbs::CanonicalPDBsHeuristic
canonical_registered_states	state_registry.h	/^    StateIDSet canonical_registered_states;$/;"	m	class:StateRegistry
canonical_state_data_pool	state_registry.h	/^    segmented_vector::SegmentedArrayVector<PackedStateBin> canonical_state_data_pool;$/;"	m	class:StateRegistry
capacity	bliss/kstack.h	/^  int capacity() {return kapacity; }$/;"	f	class:bliss::KStack
causal_graph_cache	causal_graph.cc	/^                     unique_ptr<CausalGraph>> causal_graph_cache;$/;"	v	file:
cea_heuristic	domain_transition_graph.h	/^namespace cea_heuristic {$/;"	n
cea_heuristic	heuristics/cea_heuristic.cc	/^namespace cea_heuristic {$/;"	n	file:
cea_heuristic	heuristics/cea_heuristic.h	/^namespace cea_heuristic {$/;"	n
cegar	cegar/abstract_search.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/abstract_search.h	/^namespace cegar {$/;"	n
cegar	cegar/abstract_state.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/abstract_state.h	/^namespace cegar {$/;"	n
cegar	cegar/abstraction.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/abstraction.h	/^namespace cegar {$/;"	n
cegar	cegar/additive_cartesian_heuristic.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/additive_cartesian_heuristic.h	/^namespace cegar {$/;"	n
cegar	cegar/cartesian_heuristic_function.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/cartesian_heuristic_function.h	/^namespace cegar {$/;"	n
cegar	cegar/cost_saturation.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/cost_saturation.h	/^namespace cegar {$/;"	n
cegar	cegar/domains.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/domains.h	/^namespace cegar {$/;"	n
cegar	cegar/refinement_hierarchy.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/refinement_hierarchy.h	/^namespace cegar {$/;"	n
cegar	cegar/split_selector.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/split_selector.h	/^namespace cegar {$/;"	n
cegar	cegar/subtask_generators.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/subtask_generators.h	/^namespace cegar {$/;"	n
cegar	cegar/transition.h	/^namespace cegar {$/;"	n
cegar	cegar/transition_updater.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/transition_updater.h	/^namespace cegar {$/;"	n
cegar	cegar/utils.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/utils.h	/^namespace cegar {$/;"	n
cegar	cegar/utils_landmarks.cc	/^namespace cegar {$/;"	n	file:
cegar	cegar/utils_landmarks.h	/^namespace cegar {$/;"	n
cegar	options/option_parser.cc	/^namespace cegar {$/;"	n	file:
cells	bliss/partition.h	/^  Cell* cells;$/;"	m	class:bliss::Partition
cert_add	bliss/graph.cc	/^AbstractGraph::cert_add(const unsigned int v1,$/;"	f	class:bliss::AbstractGraph
cert_add_redundant	bliss/graph.cc	/^AbstractGraph::cert_add_redundant(const unsigned int v1,$/;"	f	class:bliss::AbstractGraph
certificate_best_path	bliss/graph.h	/^  std::vector<unsigned int> certificate_best_path;$/;"	m	class:bliss::AbstractGraph
certificate_current_path	bliss/graph.h	/^  std::vector<unsigned int> certificate_current_path;$/;"	m	class:bliss::AbstractGraph
certificate_first_path	bliss/graph.h	/^  std::vector<unsigned int> certificate_first_path;$/;"	m	class:bliss::AbstractGraph
certificate_index	bliss/graph.cc	/^  unsigned int certificate_index;$/;"	m	class:bliss::TreeNode	file:
certificate_index	bliss/graph.cc	/^  unsigned int certificate_index;$/;"	m	struct:bliss::__anon3	file:
certificate_index	bliss/graph.h	/^  unsigned int certificate_index;$/;"	m	class:bliss::AbstractGraph
cg_heuristic	domain_transition_graph.h	/^namespace cg_heuristic {$/;"	n
cg_heuristic	heuristics/cg_cache.cc	/^namespace cg_heuristic {$/;"	n	file:
cg_heuristic	heuristics/cg_cache.h	/^namespace cg_heuristic {$/;"	n
cg_heuristic	heuristics/cg_heuristic.cc	/^namespace cg_heuristic {$/;"	n	file:
cg_heuristic	heuristics/cg_heuristic.h	/^namespace cg_heuristic {$/;"	n
change_color	bliss/graph.cc	/^Digraph::change_color(const unsigned int vertex, const unsigned int new_color)$/;"	f	class:bliss::Digraph
change_color	bliss/graph.cc	/^Graph::change_color(const unsigned int vertex, const unsigned int color)$/;"	f	class:bliss::Graph
checkSeverity	lp/lp_internals.cc	/^    virtual void checkSeverity() {$/;"	f	class:lp::ErrorCatchingCoinMessageHandler
check_bounds	options/option_parser.cc	/^void OptionParser::check_bounds<double>($/;"	f	class:options::OptionParser
check_bounds	options/option_parser.cc	/^void OptionParser::check_bounds<int>($/;"	f	class:options::OptionParser
check_bounds	options/option_parser.h	/^void OptionParser::check_bounds($/;"	f	class:options::OptionParser
check_fact	global_operator.cc	/^static void check_fact(int var, int val) {$/;"	f	file:
check_goal_and_set_plan	search_engine.cc	/^bool SearchEngine::check_goal_and_set_plan(const GlobalState &state,$/;"	f	class:SearchEngine
check_hillclimbing_options	pdbs/pattern_collection_generator_hillclimbing.cc	/^void check_hillclimbing_options($/;"	f	namespace:pdbs
check_interrupt	search_engines/top_k_eager_search.h	/^	bool check_interrupt(int optimal_solution_cost, int g_n, int f_u) {	$/;"	f	struct:top_k_eager_search::SearchControl
check_lost_landmark_children_needed_again	landmarks/landmark_status_manager.cc	/^bool LandmarkStatusManager::check_lost_landmark_children_needed_again(const LandmarkNode &node) const {$/;"	f	class:landmarks::LandmarkStatusManager
check_magic	globals.cc	/^void check_magic(istream &in, string magic) {$/;"	f
check_node_orders_disobeyed	landmarks/landmark_count_heuristic.cc	/^bool LandmarkCountHeuristic::check_node_orders_disobeyed(const LandmarkNode &node,$/;"	f	class:landmarks::LandmarkCountHeuristic
check_progress	search_progress.cc	/^bool SearchProgress::check_progress(const EvaluationContext &eval_context) {$/;"	f	class:SearchProgress
check_tuple_in_tuple	heuristics/hm_heuristic.cc	/^int HMHeuristic::check_tuple_in_tuple($/;"	f	class:hm_heuristic::HMHeuristic
child	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::child(const iterator_base& it, unsigned int num) $/;"	f	class:tree
children	landmarks/landmark_graph.h	/^    std::unordered_map<LandmarkNode *, EdgeType> children;$/;"	m	class:landmarks::EdgeType::LandmarkNode
children_state	domain_transition_graph.h	/^    std::vector<int> children_state;$/;"	m	struct:ValueNode
choose	utils/rng.h	/^    typename std::vector<T>::const_iterator choose(const std::vector<T> &vec) {$/;"	f	class:utils::RandomNumberGenerator
choose	utils/rng.h	/^    typename std::vector<T>::iterator choose(std::vector<T> &vec) {$/;"	f	class:utils::RandomNumberGenerator
clean	bliss/kstack.h	/^  void clean() {cursor = entries; }$/;"	f	class:bliss::KStack
clear	algorithms/ordered_set.h	/^    void clear() {$/;"	f	class:ordered_set::OrderedSet
clear	algorithms/priority_queues.h	/^    virtual void clear() {$/;"	f	class:priority_queues::BucketQueue
clear	algorithms/priority_queues.h	/^    virtual void clear() {$/;"	f	class:priority_queues::HeapQueue
clear	algorithms/priority_queues.h	/^    void clear() {$/;"	f	class:priority_queues::AdaptiveQueue
clear	bliss/heap.h	/^  void clear() {n = 0;}$/;"	f	class:bliss::Heap
clear	bliss/kqueue.h	/^void KQueue<Type>::clear()$/;"	f	class:bliss::KQueue
clear	ext/tree.hh	/^void tree<T, tree_node_allocator>::clear()$/;"	f	class:tree
clear	lp/lp_solver.cc	/^void LPConstraint::clear() {$/;"	f	class:lp::LPConstraint
clear	merge_and_shrink/label_equivalence_relation.h	/^    void clear() {$/;"	f	class:merge_and_shrink::LabelGroup
clear	open_lists/alternation_open_list.cc	/^void AlternationOpenList<Entry>::clear() {$/;"	f	class:AlternationOpenList
clear	open_lists/epsilon_greedy_open_list.cc	/^void EpsilonGreedyOpenList<Entry>::clear() {$/;"	f	class:EpsilonGreedyOpenList
clear	open_lists/pareto_open_list.cc	/^void ParetoOpenList<Entry>::clear() {$/;"	f	class:ParetoOpenList
clear	open_lists/standard_scalar_open_list.cc	/^void StandardScalarOpenList<Entry>::clear() {$/;"	f	class:StandardScalarOpenList
clear	open_lists/tiebreaking_open_list.cc	/^void TieBreakingOpenList<Entry>::clear() {$/;"	f	class:TieBreakingOpenList
clear	open_lists/type_based_open_list.cc	/^void TypeBasedOpenList<Entry>::clear() {$/;"	f	class:TypeBasedOpenList
clear_distances	merge_and_shrink/distances.cc	/^void Distances::clear_distances() {$/;"	f	class:merge_and_shrink::Distances
clear_ivs	bliss/partition.cc	/^Partition::clear_ivs(Cell* const cell)$/;"	f	class:bliss::Partition
clear_mask	algorithms/int_packer.cc	/^    Bin clear_mask;$/;"	m	class:int_packer::IntPacker::VariableInfo	file:
clear_temporary_constraints	lp/lp_solver.cc	/^void LPSolver::clear_temporary_constraints() {$/;"	f	class:lp::LPSolver
clear_temporary_data	lp/lp_solver.cc	/^void LPSolver::clear_temporary_data() {$/;"	f	class:lp::LPSolver
clone	options/any.h	/^        virtual std::unique_ptr<Placeholder> clone() const {$/;"	f	class:options::Any::Holder
close	search_space.cc	/^void SearchNode::close() {$/;"	f	class:SearchNode
cmp	bliss/graph.cc	/^Digraph::cmp(Digraph& other)$/;"	f	class:bliss::Digraph
cmp	bliss/graph.cc	/^Graph::cmp(Graph& other)$/;"	f	class:bliss::Graph
cmp	bliss/uintseqhash.h	/^  int cmp(const UintSeqHash &other) const {$/;"	f	class:bliss::UintSeqHash
cmp_to_best_path	bliss/graph.cc	/^  int cmp_to_best_path;$/;"	m	class:bliss::TreeNode	file:
coefficients	lp/lp_solver.h	/^    std::vector<double> coefficients;$/;"	m	class:lp::LPConstraint
col_lb	lp/lp_solver.h	/^    std::vector<double> col_lb;$/;"	m	class:lp::LPSolver
col_ub	lp/lp_solver.h	/^    std::vector<double> col_ub;$/;"	m	class:lp::LPSolver
collect_all_side_effects	domain_transition_graph.cc	/^void DTGFactory::collect_all_side_effects(vector<DomainTransitionGraph *> &dtgs) {$/;"	f	class:DTGFactory
collect_ancestors	landmarks/landmark_factory.cc	/^void LandmarkFactory::collect_ancestors($/;"	f	class:landmarks::LandmarkFactory
collect_f_h_buckets	merge_and_shrink/shrink_fh.cc	/^static void collect_f_h_buckets($/;"	f	namespace:merge_and_shrink
collect_h_buckets	merge_and_shrink/shrink_fh.cc	/^static void collect_h_buckets($/;"	f	namespace:merge_and_shrink
collect_helpful_actions	landmarks/exploration.cc	/^void Exploration::collect_helpful_actions($/;"	f	class:landmarks::Exploration
collect_lm_leaves	landmarks/landmark_count_heuristic.cc	/^vector<FactPair> LandmarkCountHeuristic::collect_lm_leaves($/;"	f	class:landmarks::LandmarkCountHeuristic
collect_preferred_operators	search_engine.cc	/^ordered_set::OrderedSet<const GlobalOperator *> collect_preferred_operators($/;"	f
collect_relaxed_plan	landmarks/exploration.cc	/^void Exploration::collect_relaxed_plan(ExProposition *goal,$/;"	f	class:landmarks::Exploration
collect_side_effects	domain_transition_graph.cc	/^void DTGFactory::collect_side_effects(DomainTransitionGraph *dtg,$/;"	f	class:DTGFactory
collect_transition_side_effects	domain_transition_graph.h	/^    bool collect_transition_side_effects;$/;"	m	class:DTGFactory
collected_time	utils/timer.h	/^    double collected_time;$/;"	m	class:utils::Timer
collection	task_proxy.h	/^    const ProxyCollection *collection;$/;"	m	class:ProxyIterator
collection_dominates	pdbs/dominance_pruning.cc	/^bool collection_dominates(const PDBCollection &superset,$/;"	f	namespace:pdbs
collection_max_size	pdbs/pattern_collection_generator_hillclimbing.h	/^    const int collection_max_size;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
color	bliss/graph.h	/^    unsigned int color;$/;"	m	class:bliss::Digraph::Vertex
color	bliss/graph.h	/^    unsigned int color;$/;"	m	class:bliss::Graph::Vertex
color_t	structural_symmetries/graph_creator.cc	/^enum color_t {PREDICATE_VERTEX, VALUE_VERTEX, PRECOND_VERTEX, EFFECT_VERTEX,$/;"	g	file:
combine_facts	cegar/subtask_generators.h	/^    bool combine_facts;$/;"	m	class:cegar::LandmarkDecomposition
combine_values	evaluators/max_evaluator.cc	/^int MaxEvaluator::combine_values(const vector<int> &values) {$/;"	f	class:max_evaluator::MaxEvaluator
combine_values	evaluators/sum_evaluator.cc	/^int SumEvaluator::combine_values(const vector<int> &values) {$/;"	f	class:sum_evaluator::SumEvaluator
combine_values	tasks/domain_abstracted_task_factory.cc	/^void DomainAbstractedTaskFactory::combine_values(int var, const ValueGroups &groups) {$/;"	f	class:extra_tasks::DomainAbstractedTaskFactory
combining_evaluator	evaluators/combining_evaluator.cc	/^namespace combining_evaluator {$/;"	n	file:
combining_evaluator	evaluators/combining_evaluator.h	/^namespace combining_evaluator {$/;"	n
comp_	ext/tree.hh	/^				StrictWeakOrdering comp_;$/;"	m	class:tree::compare_nodes
compare_func	algorithms/priority_queues.h	/^    struct compare_func {$/;"	s	class:priority_queues::HeapQueue
compare_nodes	ext/tree.hh	/^				compare_nodes(StrictWeakOrdering comp) : comp_(comp) {};$/;"	f	class:tree::compare_nodes
compare_nodes	ext/tree.hh	/^		class compare_nodes {$/;"	c	class:tree
compose_permutation	structural_symmetries/group.cc	/^Permutation *Group::compose_permutation(const Trace& perm_index) const {$/;"	f	class:Group
compute	algorithms/max_cliques.cc	/^    void compute() {$/;"	f	class:max_cliques::MaxCliqueComputer
compute_abstraction	merge_and_shrink/shrink_bucket_based.cc	/^void ShrinkBucketBased::compute_abstraction($/;"	f	class:merge_and_shrink::ShrinkBucketBased
compute_achievers	pruning/stubborn_sets.cc	/^void StubbornSets::compute_achievers(const TaskProxy &task_proxy) {$/;"	f	class:stubborn_sets::StubbornSets
compute_active_operators	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::compute_active_operators(const State &state) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
compute_add_and_ff	heuristics/additive_heuristic.cc	/^int AdditiveHeuristic::compute_add_and_ff(const State &state) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
compute_additive_vars	pdbs/max_additive_pdb_sets.cc	/^VariableAdditivity compute_additive_vars(const TaskProxy &task_proxy) {$/;"	f	namespace:pdbs
compute_approx_mean_finite_h	pdbs/zero_one_pdbs.cc	/^double ZeroOnePDBs::compute_approx_mean_finite_h() const {$/;"	f	class:pdbs::ZeroOnePDBs
compute_combinable_equivalence_relation	merge_and_shrink/label_reduction.cc	/^equivalence_relation::EquivalenceRelation *LabelReduction::compute_combinable_equivalence_relation($/;"	f	class:merge_and_shrink::LabelReduction
compute_conflicts_and_disabling	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::compute_conflicts_and_disabling() {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
compute_connection_points	pdbs/pattern_collection_generator_systematic.cc	/^void PatternCollectionGeneratorSystematic::compute_connection_points($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
compute_costs	heuristics/cea_heuristic.cc	/^int ContextEnhancedAdditiveHeuristic::compute_costs(const State &state) {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
compute_disjunctive_preconditions	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::compute_disjunctive_preconditions($/;"	f	class:landmarks::LandmarkFactoryRpgSasp
compute_distances	merge_and_shrink/distances.cc	/^vector<bool> Distances::compute_distances(Verbosity verbosity) {$/;"	f	class:merge_and_shrink::Distances
compute_distances_and_prune	merge_and_shrink/factored_transition_system.cc	/^void FactoredTransitionSystem::compute_distances_and_prune($/;"	f	class:merge_and_shrink::FactoredTransitionSystem
compute_eff_pre_neighbors	pdbs/pattern_collection_generator_systematic.cc	/^void PatternCollectionGeneratorSystematic::compute_eff_pre_neighbors($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
compute_eqref_hash	bliss/graph.h	/^  bool compute_eqref_hash;$/;"	m	class:bliss::AbstractGraph
compute_ff_heuristic	landmarks/exploration.cc	/^int Exploration::compute_ff_heuristic(const State &state) {$/;"	f	class:landmarks::Exploration
compute_goal_distances_general_cost	merge_and_shrink/distances.cc	/^void Distances::compute_goal_distances_general_cost() {$/;"	f	class:merge_and_shrink::Distances
compute_goal_distances_unit_cost	merge_and_shrink/distances.cc	/^void Distances::compute_goal_distances_unit_cost() {$/;"	f	class:merge_and_shrink::Distances
compute_h_m_landmarks	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::compute_h_m_landmarks(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkFactoryHM
compute_heuristic	cegar/additive_cartesian_heuristic.cc	/^int AdditiveCartesianHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:cegar::AdditiveCartesianHeuristic
compute_heuristic	cegar/additive_cartesian_heuristic.cc	/^int AdditiveCartesianHeuristic::compute_heuristic(const State &state) {$/;"	f	class:cegar::AdditiveCartesianHeuristic
compute_heuristic	evaluators/const_evaluator.cc	/^int ConstEvaluator::compute_heuristic(const GlobalState &) {$/;"	f	class:const_evaluator::ConstEvaluator
compute_heuristic	heuristics/additive_heuristic.cc	/^int AdditiveHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
compute_heuristic	heuristics/additive_heuristic.cc	/^int AdditiveHeuristic::compute_heuristic(const State &state) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
compute_heuristic	heuristics/blind_search_heuristic.cc	/^int BlindSearchHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:blind_search_heuristic::BlindSearchHeuristic
compute_heuristic	heuristics/cea_heuristic.cc	/^int ContextEnhancedAdditiveHeuristic::compute_heuristic(const GlobalState &g_state) {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
compute_heuristic	heuristics/cg_heuristic.cc	/^int CGHeuristic::compute_heuristic(const GlobalState &g_state) {$/;"	f	class:cg_heuristic::CGHeuristic
compute_heuristic	heuristics/ff_heuristic.cc	/^int FFHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:ff_heuristic::FFHeuristic
compute_heuristic	heuristics/goal_count_heuristic.cc	/^int GoalCountHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:goal_count_heuristic::GoalCountHeuristic
compute_heuristic	heuristics/hm_heuristic.cc	/^int HMHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:hm_heuristic::HMHeuristic
compute_heuristic	heuristics/lm_cut_heuristic.cc	/^int LandmarkCutHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:lm_cut_heuristic::LandmarkCutHeuristic
compute_heuristic	heuristics/lm_cut_heuristic.cc	/^int LandmarkCutHeuristic::compute_heuristic(const State &state) {$/;"	f	class:lm_cut_heuristic::LandmarkCutHeuristic
compute_heuristic	heuristics/max_heuristic.cc	/^int HSPMaxHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:max_heuristic::HSPMaxHeuristic
compute_heuristic	landmarks/exploration.cc	/^int Exploration::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:landmarks::Exploration
compute_heuristic	landmarks/landmark_count_heuristic.cc	/^int LandmarkCountHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:landmarks::LandmarkCountHeuristic
compute_heuristic	merge_and_shrink/merge_and_shrink_heuristic.cc	/^int MergeAndShrinkHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
compute_heuristic	operator_counting/operator_counting_heuristic.cc	/^int OperatorCountingHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:operator_counting::OperatorCountingHeuristic
compute_heuristic	operator_counting/operator_counting_heuristic.cc	/^int OperatorCountingHeuristic::compute_heuristic(const State &state) {$/;"	f	class:operator_counting::OperatorCountingHeuristic
compute_heuristic	pdbs/canonical_pdbs_heuristic.cc	/^int CanonicalPDBsHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:pdbs::CanonicalPDBsHeuristic
compute_heuristic	pdbs/canonical_pdbs_heuristic.cc	/^int CanonicalPDBsHeuristic::compute_heuristic(const State &state) const {$/;"	f	class:pdbs::CanonicalPDBsHeuristic
compute_heuristic	pdbs/pdb_heuristic.cc	/^int PDBHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:pdbs::PDBHeuristic
compute_heuristic	pdbs/pdb_heuristic.cc	/^int PDBHeuristic::compute_heuristic(const State &state) const {$/;"	f	class:pdbs::PDBHeuristic
compute_heuristic	pdbs/zero_one_pdbs_heuristic.cc	/^int ZeroOnePDBsHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:pdbs::ZeroOnePDBsHeuristic
compute_heuristic	pdbs/zero_one_pdbs_heuristic.cc	/^int ZeroOnePDBsHeuristic::compute_heuristic(const State &state) const {$/;"	f	class:pdbs::ZeroOnePDBsHeuristic
compute_heuristic	potentials/potential_heuristic.cc	/^int PotentialHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:potentials::PotentialHeuristic
compute_heuristic	potentials/potential_max_heuristic.cc	/^int PotentialMaxHeuristic::compute_heuristic(const GlobalState &global_state) {$/;"	f	class:potentials::PotentialMaxHeuristic
compute_heuristic_for_cegar	heuristics/additive_heuristic.cc	/^void AdditiveHeuristic::compute_heuristic_for_cegar(const State &state) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
compute_heuristics	landmarks/lama_ff_synergy.cc	/^void LamaFFSynergy::compute_heuristics(EvaluationContext &eval_context) {$/;"	f	class:landmarks::LamaFFSynergy
compute_hsp_add_heuristic	landmarks/exploration.cc	/^int Exploration::compute_hsp_add_heuristic() {$/;"	f	class:landmarks::Exploration
compute_init_distances_general_cost	merge_and_shrink/distances.cc	/^void Distances::compute_init_distances_general_cost() {$/;"	f	class:merge_and_shrink::Distances
compute_init_distances_unit_cost	merge_and_shrink/distances.cc	/^void Distances::compute_init_distances_unit_cost() {$/;"	f	class:merge_and_shrink::Distances
compute_interference_relation	pruning/stubborn_sets_simple.cc	/^void StubbornSetsSimple::compute_interference_relation() {$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
compute_is_unit_cost	tasks/cost_adapted_task.cc	/^bool CostAdaptedTask::compute_is_unit_cost() const {$/;"	f	class:tasks::CostAdaptedTask
compute_label_mapping	merge_and_shrink/label_reduction.cc	/^void LabelReduction::compute_label_mapping($/;"	f	class:merge_and_shrink::LabelReduction
compute_label_ranks	merge_and_shrink/merge_scoring_function_dfp.cc	/^vector<int> MergeScoringFunctionDFP::compute_label_ranks($/;"	f	class:merge_and_shrink::MergeScoringFunctionDFP
compute_landmarks	heuristics/lm_cut_landmarks.cc	/^bool LandmarkCutLandmarks::compute_landmarks($/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
compute_lm_graph	landmarks/landmark_factory.cc	/^shared_ptr<LandmarkGraph> LandmarkFactory::compute_lm_graph($/;"	f	class:landmarks::LandmarkFactory
compute_locally_equivalent_labels	merge_and_shrink/transition_system.cc	/^void TransitionSystem::compute_locally_equivalent_labels() {$/;"	f	class:merge_and_shrink::TransitionSystem
compute_max_additive_subsets	pdbs/max_additive_pdb_sets.cc	/^shared_ptr<MaxAdditivePDBSubsets> compute_max_additive_subsets($/;"	f	namespace:pdbs
compute_max_additive_subsets_with_pattern	pdbs/max_additive_pdb_sets.cc	/^MaxAdditivePDBSubsets compute_max_additive_subsets_with_pattern($/;"	f	namespace:pdbs
compute_max_cliques	algorithms/max_cliques.cc	/^void compute_max_cliques($/;"	f	namespace:max_cliques
compute_mean_finite_h	pdbs/pattern_database.cc	/^double PatternDatabase::compute_mean_finite_h() const {$/;"	f	class:pdbs::PatternDatabase
compute_merge_candidates	merge_and_shrink/merge_selector.cc	/^vector<pair<int, int>> MergeSelector::compute_merge_candidates($/;"	f	class:merge_and_shrink::MergeSelector
compute_merge_strategy	merge_and_shrink/merge_strategy_factory_precomputed.cc	/^unique_ptr<MergeStrategy> MergeStrategyFactoryPrecomputed::compute_merge_strategy($/;"	f	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
compute_merge_strategy	merge_and_shrink/merge_strategy_factory_stateless.cc	/^unique_ptr<MergeStrategy> MergeStrategyFactoryStateless::compute_merge_strategy($/;"	f	class:merge_and_shrink::MergeStrategyFactoryStateless
compute_merge_tree	merge_and_shrink/merge_tree_factory.cc	/^unique_ptr<MergeTree> MergeTreeFactory::compute_merge_tree($/;"	f	class:merge_and_shrink::MergeTreeFactory
compute_merge_tree	merge_and_shrink/merge_tree_factory_linear.cc	/^unique_ptr<MergeTree> MergeTreeFactoryLinear::compute_merge_tree($/;"	f	class:merge_and_shrink::MergeTreeFactoryLinear
compute_noop_landmarks	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::compute_noop_landmarks($/;"	f	class:landmarks::LandmarkFactoryHM
compute_num_blocks	algorithms/dynamic_bitset.h	/^    static int compute_num_blocks(std::size_t num_bits) {$/;"	f	class:dynamic_bitset::DynamicBitset
compute_num_internal_nodes	merge_and_shrink/merge_tree.cc	/^int MergeTreeNode::compute_num_internal_nodes() const {$/;"	f	class:merge_and_shrink::MergeTreeNode
compute_num_internal_nodes	merge_and_shrink/merge_tree.h	/^    int compute_num_internal_nodes() const {$/;"	f	class:merge_and_shrink::MergeTree
compute_operator_preconditions	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::compute_operator_preconditions(const TaskProxy &task_proxy) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
compute_possibly_before_facts	cegar/utils.cc	/^static unordered_set<FactProxy> compute_possibly_before_facts($/;"	f	namespace:cegar
compute_preconditions	merge_and_shrink/fts_factory.cc	/^unordered_map<int, int> FTSFactory::compute_preconditions(OperatorProxy op) {$/;"	f	class:merge_and_shrink::FTSFactory
compute_predecessor_information	landmarks/landmark_factory.cc	/^void LandmarkFactory::compute_predecessor_information($/;"	f	class:landmarks::LandmarkFactory
compute_random_symmetric_state	structural_symmetries/group.cc	/^void Group::compute_random_symmetric_state(const GlobalState &state,$/;"	f	class:Group
compute_reachability_with_excludes	landmarks/exploration.cc	/^void Exploration::compute_reachability_with_excludes(vector<vector<int>> &lvl_var,$/;"	f	class:landmarks::Exploration
compute_relation	causal_graph.cc	/^void IntRelationBuilder::compute_relation(IntRelation &result) const {$/;"	f	class:IntRelationBuilder
compute_required_cache_size	heuristics/cg_cache.cc	/^int CGCache::compute_required_cache_size($/;"	f	class:cg_heuristic::CGCache
compute_result	evaluators/combining_evaluator.cc	/^EvaluationResult CombiningEvaluator::compute_result($/;"	f	class:combining_evaluator::CombiningEvaluator
compute_result	evaluators/g_evaluator.cc	/^EvaluationResult GEvaluator::compute_result(EvaluationContext &eval_context) {$/;"	f	class:g_evaluator::GEvaluator
compute_result	evaluators/pref_evaluator.cc	/^EvaluationResult PrefEvaluator::compute_result($/;"	f	class:pref_evaluator::PrefEvaluator
compute_result	evaluators/weighted_evaluator.cc	/^EvaluationResult WeightedEvaluator::compute_result($/;"	f	class:weighted_evaluator::WeightedEvaluator
compute_result	heuristic.cc	/^EvaluationResult Heuristic::compute_result(EvaluationContext &eval_context) {$/;"	f	class:Heuristic
compute_scores	merge_and_shrink/merge_scoring_function_dfp.cc	/^vector<double> MergeScoringFunctionDFP::compute_scores($/;"	f	class:merge_and_shrink::MergeScoringFunctionDFP
compute_scores	merge_and_shrink/merge_scoring_function_goal_relevance.cc	/^vector<double> MergeScoringFunctionGoalRelevance::compute_scores($/;"	f	class:merge_and_shrink::MergeScoringFunctionGoalRelevance
compute_scores	merge_and_shrink/merge_scoring_function_single_random.cc	/^vector<double> MergeScoringFunctionSingleRandom::compute_scores($/;"	f	class:merge_and_shrink::MergeScoringFunctionSingleRandom
compute_scores	merge_and_shrink/merge_scoring_function_total_order.cc	/^vector<double> MergeScoringFunctionTotalOrder::compute_scores($/;"	f	class:merge_and_shrink::MergeScoringFunctionTotalOrder
compute_shared_preconditions	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::compute_shared_preconditions($/;"	f	class:landmarks::LandmarkFactoryRpgSasp
compute_shrink_sizes	merge_and_shrink/utils.cc	/^pair<int, int> compute_shrink_sizes($/;"	f	namespace:merge_and_shrink
compute_signatures	merge_and_shrink/shrink_bisimulation.cc	/^void ShrinkBisimulation::compute_signatures($/;"	f	class:merge_and_shrink::ShrinkBisimulation
compute_sorted_operators	pruning/stubborn_sets.cc	/^void StubbornSets::compute_sorted_operators(const TaskProxy &task_proxy) {$/;"	f	class:stubborn_sets::StubbornSets
compute_subset_all_symmetric_states	structural_symmetries/group.cc	/^void Group::compute_subset_all_symmetric_states(const GlobalState &state,$/;"	f	class:Group
compute_superset_relation	pdbs/dominance_pruning.cc	/^PDBRelation compute_superset_relation(const PDBCollection &pattern_databases) {$/;"	f	namespace:pdbs
compute_symmetric_states	structural_symmetries/group.cc	/^void Group::compute_symmetric_states(const GlobalState &state,$/;"	f	class:Group
compute_symmetries	structural_symmetries/graph_creator.cc	/^bool GraphCreator::compute_symmetries(Group *group) {$/;"	f	class:GraphCreator
compute_symmetries	structural_symmetries/group.cc	/^void Group::compute_symmetries() {$/;"	f	class:Group
compute_total_transitions	merge_and_shrink/transition_system.cc	/^int TransitionSystem::compute_total_transitions() const {$/;"	f	class:merge_and_shrink::TransitionSystem
compute_triggers	landmarks/landmark_factory_zhu_givan.cc	/^void LandmarkFactoryZhuGivan::compute_triggers(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkFactoryZhuGivan
compute_union_pattern	pdbs/pattern_collection_generator_systematic.cc	/^static void compute_union_pattern($/;"	f	namespace:pdbs
concrete_state	cegar/abstraction.cc	/^    const State concrete_state;$/;"	m	struct:cegar::Flaw	file:
cond_noops	landmarks/landmark_factory_h_m.h	/^    std::vector<std::vector<int>> cond_noops;$/;"	m	struct:landmarks::PMOp
condition_count	axioms.h	/^        int condition_count;$/;"	m	struct:AxiomEvaluator::AxiomRule
condition_of	axioms.h	/^        std::vector<AxiomRule *> condition_of;$/;"	m	struct:AxiomEvaluator::AxiomLiteral
conditional_effects_supported	landmarks/landmark_count_heuristic.h	/^    const bool conditional_effects_supported;$/;"	m	class:landmarks::LandmarkCountHeuristic
conditions	global_operator.h	/^    std::vector<GlobalCondition> conditions;$/;"	m	struct:GlobalEffect
conditions	successor_generator.h	/^    std::vector<Condition> conditions;$/;"	m	class:SuccessorGenerator
conflicting_and_disabling	pruning/stubborn_sets_ec.h	/^    std::vector<std::vector<int>> conflicting_and_disabling;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
conj_lms	landmarks/landmark_graph.h	/^    int conj_lms;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
conjunctive	landmarks/landmark_graph.h	/^    bool conjunctive;$/;"	m	class:landmarks::EdgeType::LandmarkNode
conjunctive_landmarks	landmarks/landmark_factory.h	/^    const bool conjunctive_landmarks;$/;"	m	class:landmarks::LandmarkFactory
const_evaluator	evaluators/const_evaluator.cc	/^namespace const_evaluator {$/;"	n	file:
const_evaluator	evaluators/const_evaluator.h	/^namespace const_evaluator {$/;"	n
const_iterator	per_state_information.h	/^        const_iterator(const PerStateInformation<Entry> &owner_,$/;"	f	class:PerStateInformation::const_iterator
const_iterator	per_state_information.h	/^        const_iterator(const const_iterator &other)$/;"	f	class:PerStateInformation::const_iterator
const_iterator	per_state_information.h	/^    class const_iterator : public std::iterator<std::forward_iterator_tag,$/;"	c	class:PerStateInformation
constraint_generators	operator_counting/operator_counting_heuristic.h	/^    std::vector<std::shared_ptr<ConstraintGenerator>> constraint_generators;$/;"	m	class:operator_counting::OperatorCountingHeuristic
constraint_index	operator_counting/state_equation_constraints.h	/^    int constraint_index;$/;"	m	struct:operator_counting::Proposition
constraint_offset	operator_counting/pho_constraints.h	/^    int constraint_offset;$/;"	m	class:operator_counting::PhOConstraints
construct_lp	potentials/potential_optimizer.cc	/^void PotentialOptimizer::construct_lp() {$/;"	f	class:potentials::PotentialOptimizer
construct_recursive	successor_generator.cc	/^GeneratorBase *SuccessorGenerator::construct_recursive($/;"	f	class:SuccessorGenerator
constructor	ext/tree.hh	/^void constructor(T1* p) $/;"	f	namespace:kp
constructor	ext/tree.hh	/^void constructor(T1* p, T2& val) $/;"	f	namespace:kp
contain_conflicting_fact	pruning/stubborn_sets.cc	/^bool contain_conflicting_fact(const vector<FactPair> &facts1,$/;"	f	namespace:stubborn_sets
contains	algorithms/ordered_set.h	/^    bool contains(const T &item) const {$/;"	f	class:ordered_set::OrderedSet
contains	cegar/abstract_state.cc	/^bool AbstractState::contains(int var, int value) const {$/;"	f	class:cegar::AbstractState
contains	landmarks/landmark_factory_h_m.cc	/^static bool contains(list<T> &alist, const T &val) {$/;"	f	namespace:landmarks
contains	options/doc_store.cc	/^bool DocStore::contains(string k) {$/;"	f	class:options::DocStore
contains	options/options.h	/^    bool contains(std::string key) const {$/;"	f	class:options::Options
contains	options/predefinitions.h	/^    bool contains(const std::string &k) {$/;"	f	class:options::Predefinitions
contains	options/registries.h	/^    bool contains(const std::string &k) {$/;"	f	class:options::Registry
content	options/any.h	/^    std::unique_ptr<Placeholder> content;$/;"	m	class:options::Any
context	heuristics/cea_heuristic.cc	/^    vector<short> context;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
context_variables	heuristics/cea_heuristic.cc	/^    vector<int> *context_variables;$/;"	m	struct:cea_heuristic::LocalProblem	file:
continue_on_fail	search_engines/iterated_search.h	/^    bool continue_on_fail;$/;"	m	class:iterated_search::IteratedSearch
continue_on_solve	search_engines/iterated_search.h	/^    bool continue_on_solve;$/;"	m	class:iterated_search::IteratedSearch
continuing_out_of_memory_handler	utils/memory.cc	/^void continuing_out_of_memory_handler() {$/;"	f	namespace:utils
contradict_effect_of	heuristics/hm_heuristic.cc	/^bool HMHeuristic::contradict_effect_of($/;"	f	class:hm_heuristic::HMHeuristic
convert_ancestor_state	task_proxy.h	/^    State convert_ancestor_state(const State &ancestor_state) const {$/;"	f	class:TaskProxy
convert_global_state	heuristic.cc	/^State Heuristic::convert_global_state(const GlobalState &global_state) const {$/;"	f	class:Heuristic
convert_if_necessary	algorithms/priority_queues.h	/^    virtual AbstractQueue<Value> *convert_if_necessary(int \/*key*\/) {$/;"	f	class:priority_queues::AbstractQueue
convert_if_necessary	algorithms/priority_queues.h	/^    virtual AbstractQueue<Value> *convert_if_necessary(int key) {$/;"	f	class:priority_queues::BucketQueue
convert_state_values	tasks/delegating_task.cc	/^void DelegatingTask::convert_state_values($/;"	f	class:tasks::DelegatingTask
convert_state_values	tasks/root_task.cc	/^void RootTask::convert_state_values($/;"	f	class:tasks::RootTask
convert_state_values_from_parent	tasks/delegating_task.h	/^    virtual void convert_state_values_from_parent(std::vector<int> &) const {$/;"	f	class:tasks::DelegatingTask
convert_state_values_from_parent	tasks/domain_abstracted_task.cc	/^void DomainAbstractedTask::convert_state_values_from_parent($/;"	f	class:extra_tasks::DomainAbstractedTask
convert_state_values_from_parent	tasks/plan_forbid_reformulated_task.cc	/^void PlanForbidReformulatedTask::convert_state_values_from_parent($/;"	f	class:extra_tasks::PlanForbidReformulatedTask
convert_to_landmark_set	landmarks/landmark_count_heuristic.cc	/^LandmarkSet LandmarkCountHeuristic::convert_to_landmark_set($/;"	f	class:landmarks::LandmarkCountHeuristic
copy_	ext/tree.hh	/^void tree<T, tree_node_allocator>::copy_(const tree<T, tree_node_allocator>& other) $/;"	f	class:tree
copy_and_register_state	state_registry.cc	/^GlobalState StateRegistry::copy_and_register_state(const GlobalState &state) {$/;"	f	class:StateRegistry
cost	global_operator.h	/^    int cost;$/;"	m	class:GlobalOperator
cost	heuristics/cea_heuristic.cc	/^    int cost;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
cost	heuristics/lm_cut_landmarks.h	/^    int cost;$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
cost	heuristics/relaxation_heuristic.h	/^    int cost; \/\/ Used for h^max cost or h^add cost$/;"	m	struct:relaxation_heuristic::Proposition
cost	heuristics/relaxation_heuristic.h	/^    int cost; \/\/ Used for h^max cost or h^add cost;$/;"	m	struct:relaxation_heuristic::UnaryOperator
cost	merge_and_shrink/label_equivalence_relation.h	/^    int cost;$/;"	m	class:merge_and_shrink::LabelGroup
cost	merge_and_shrink/labels.h	/^    int cost;$/;"	m	class:merge_and_shrink::Label
cost	pdbs/pattern_database.h	/^    int cost;$/;"	m	class:pdbs::AbstractOperator
cost_of_landmarks	landmarks/landmark_graph.h	/^    inline int cost_of_landmarks() const {return landmarks_cost; }$/;"	f	class:landmarks::EdgeType::LandmarkGraph
cost_sharing_h_value	landmarks/landmark_cost_assignment.cc	/^double LandmarkEfficientOptimalSharedCostAssignment::cost_sharing_h_value() {$/;"	f	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
cost_sharing_h_value	landmarks/landmark_cost_assignment.cc	/^double LandmarkUniformSharedCostAssignment::cost_sharing_h_value() {$/;"	f	class:landmarks::LandmarkUniformSharedCostAssignment
cost_type	search_engine.h	/^    OperatorCost cost_type;$/;"	m	class:SearchEngine
cost_type	search_space.h	/^    OperatorCost cost_type;$/;"	m	class:SearchNode
cost_type	search_space.h	/^    OperatorCost cost_type;$/;"	m	class:SearchSpace
cost_type	tasks/cost_adapted_task.h	/^    const OperatorCost cost_type;$/;"	m	class:tasks::CostAdaptedTask
count	algorithms/dynamic_bitset.h	/^    int count() const {$/;"	f	class:dynamic_bitset::DynamicBitset
count	cegar/abstract_state.cc	/^int AbstractState::count(int var) const {$/;"	f	class:cegar::AbstractState
count	cegar/domains.cc	/^int Domains::count(int var) const {$/;"	f	class:cegar::Domains
count_bits_in_last_block	algorithms/dynamic_bitset.h	/^    int count_bits_in_last_block() const {$/;"	f	class:dynamic_bitset::DynamicBitset
count_costs	landmarks/landmark_graph.cc	/^void LandmarkGraph::count_costs() {$/;"	f	class:landmarks::LandmarkGraph
count_evaluation	evaluation_result.h	/^    bool count_evaluation;$/;"	m	class:EvaluationResult
cover_samples	potentials/diverse_potential_heuristics.cc	/^void DiversePotentialHeuristics::cover_samples($/;"	f	class:potentials::DiversePotentialHeuristics
cr_backtrack_point	bliss/partition.h	/^    unsigned int cr_backtrack_point;$/;"	m	class:bliss::Partition::BacktrackInfo
cr_bt_info	bliss/partition.h	/^  std::vector<CR_BTInfo> cr_bt_info;$/;"	m	class:bliss::Partition
cr_cells	bliss/partition.h	/^  CRCell* cr_cells;$/;"	m	class:bliss::Partition
cr_cep_index	bliss/graph.cc	/^  unsigned int cr_cep_index;$/;"	m	class:bliss::TreeNode	file:
cr_cep_stack	bliss/graph.h	/^  std::vector<CR_CEP> cr_cep_stack;$/;"	m	class:bliss::AbstractGraph
cr_cep_stack_size	bliss/graph.cc	/^  unsigned int cr_cep_stack_size;$/;"	m	class:bliss::TreeNode	file:
cr_component	bliss/graph.h	/^  std::vector<unsigned int> cr_component;$/;"	m	class:bliss::AbstractGraph
cr_component_elements	bliss/graph.h	/^  unsigned int cr_component_elements;$/;"	m	class:bliss::AbstractGraph
cr_create_at_level	bliss/partition.cc	/^Partition::cr_create_at_level(const unsigned int cell_index,$/;"	f	class:bliss::Partition
cr_create_at_level_trailed	bliss/partition.cc	/^Partition::cr_create_at_level_trailed(const unsigned int cell_index,$/;"	f	class:bliss::Partition
cr_created_trail	bliss/partition.h	/^  std::vector<unsigned int> cr_created_trail;$/;"	m	class:bliss::Partition
cr_enabled	bliss/partition.h	/^  bool cr_enabled;$/;"	m	class:bliss::Partition
cr_free	bliss/partition.cc	/^Partition::cr_free()$/;"	f	class:bliss::Partition
cr_get_backtrack_point	bliss/partition.cc	/^Partition::cr_get_backtrack_point()$/;"	f	class:bliss::Partition
cr_get_level	bliss/partition.h	/^Partition::cr_get_level(const unsigned int cell_index) const$/;"	f	class:bliss::Partition
cr_goto_backtrack_point	bliss/partition.cc	/^Partition::cr_goto_backtrack_point(const unsigned int btpoint)$/;"	f	class:bliss::Partition
cr_init	bliss/partition.cc	/^Partition::cr_init()$/;"	f	class:bliss::Partition
cr_level	bliss/graph.cc	/^  unsigned int cr_level;$/;"	m	class:bliss::TreeNode	file:
cr_level	bliss/graph.h	/^  unsigned int cr_level;$/;"	m	class:bliss::AbstractGraph
cr_levels	bliss/partition.h	/^  CRCell** cr_levels;$/;"	m	class:bliss::Partition
cr_max_level	bliss/partition.h	/^  unsigned int cr_max_level;$/;"	m	class:bliss::Partition
cr_split_level	bliss/partition.cc	/^Partition::cr_split_level(const unsigned int level,$/;"	f	class:bliss::Partition
cr_splitted_level_trail	bliss/partition.h	/^  std::vector<unsigned int> cr_splitted_level_trail;$/;"	m	class:bliss::Partition
create	merge_and_shrink/fts_factory.cc	/^FactoredTransitionSystem FTSFactory::create($/;"	f	class:merge_and_shrink::FTSFactory
create_additive_heuristic	cegar/utils.cc	/^unique_ptr<additive_heuristic::AdditiveHeuristic> create_additive_heuristic($/;"	f	namespace:cegar
create_alternation_open_list_factory	search_engines/search_common.cc	/^static shared_ptr<OpenListFactory> create_alternation_open_list_factory($/;"	f	namespace:search_common
create_alternation_open_list_factory_aux	search_engines/search_common.cc	/^static shared_ptr<OpenListFactory> create_alternation_open_list_factory_aux($/;"	f	namespace:search_common
create_astar_open_list_factory_and_f_eval	search_engines/search_common.cc	/^create_astar_open_list_factory_and_f_eval(const Options &opts) {$/;"	f	namespace:search_common
create_bliss_directed_graph	structural_symmetries/graph_creator.cc	/^void GraphCreator::create_bliss_directed_graph(bliss::Digraph &bliss_graph) const {$/;"	f	class:GraphCreator
create_distances	merge_and_shrink/fts_factory.cc	/^vector<unique_ptr<Distances>> FTSFactory::create_distances($/;"	f	class:merge_and_shrink::FTSFactory
create_edge_open_list	open_lists/alternation_open_list.cc	/^AlternationOpenListFactory::create_edge_open_list() {$/;"	f	class:AlternationOpenListFactory
create_edge_open_list	open_lists/epsilon_greedy_open_list.cc	/^EpsilonGreedyOpenListFactory::create_edge_open_list() {$/;"	f	class:EpsilonGreedyOpenListFactory
create_edge_open_list	open_lists/pareto_open_list.cc	/^ParetoOpenListFactory::create_edge_open_list() {$/;"	f	class:ParetoOpenListFactory
create_edge_open_list	open_lists/standard_scalar_open_list.cc	/^StandardScalarOpenListFactory::create_edge_open_list() {$/;"	f	class:StandardScalarOpenListFactory
create_edge_open_list	open_lists/tiebreaking_open_list.cc	/^TieBreakingOpenListFactory::create_edge_open_list() {$/;"	f	class:TieBreakingOpenListFactory
create_edge_open_list	open_lists/type_based_open_list.cc	/^TypeBasedOpenListFactory::create_edge_open_list() {$/;"	f	class:TypeBasedOpenListFactory
create_ehc_open_list_factory	search_engines/enforced_hill_climbing_search.cc	/^static shared_ptr<OpenListFactory> create_ehc_open_list_factory($/;"	f	namespace:enforced_hill_climbing_search
create_factored_transition_system	merge_and_shrink/fts_factory.cc	/^FactoredTransitionSystem create_factored_transition_system($/;"	f	namespace:merge_and_shrink
create_from_sorted_entries_destructively	algorithms/priority_queues.h	/^    static HeapQueue<Value> *create_from_sorted_entries_destructively($/;"	f	class:priority_queues::HeapQueue
create_greedy_open_list_factory	search_engines/search_common.cc	/^shared_ptr<OpenListFactory> create_greedy_open_list_factory($/;"	f	namespace:search_common
create_labels	merge_and_shrink/fts_factory.cc	/^vector<unique_ptr<Label>> FTSFactory::create_labels() {$/;"	f	class:merge_and_shrink::FTSFactory
create_lp_solver	lp/lp_internals.cc	/^unique_ptr<OsiSolverInterface> create_lp_solver(LPSolverType solver_type) {$/;"	f	namespace:lp
create_mas_representations	merge_and_shrink/fts_factory.cc	/^vector<unique_ptr<MergeAndShrinkRepresentation>> FTSFactory::create_mas_representations() {$/;"	f	class:merge_and_shrink::FTSFactory
create_max_additive_subsets_if_missing	pdbs/pattern_collection_information.cc	/^void PatternCollectionInformation::create_max_additive_subsets_if_missing() {$/;"	f	class:pdbs::PatternCollectionInformation
create_open_list	open_lists/open_list_factory.cc	/^unique_ptr<EdgeOpenList> OpenListFactory::create_open_list() {$/;"	f	class:OpenListFactory
create_open_list	open_lists/open_list_factory.cc	/^unique_ptr<StateOpenList> OpenListFactory::create_open_list() {$/;"	f	class:OpenListFactory
create_pdb	pdbs/pattern_database.cc	/^void PatternDatabase::create_pdb($/;"	f	class:pdbs::PatternDatabase
create_pdbs_if_missing	pdbs/pattern_collection_information.cc	/^void PatternCollectionInformation::create_pdbs_if_missing() {$/;"	f	class:pdbs::PatternCollectionInformation
create_permutation_from_state_to_state	structural_symmetries/group.cc	/^Permutation *Group::create_permutation_from_state_to_state($/;"	f	class:Group
create_phase	search_engines/iterated_search.cc	/^unique_ptr<SearchEngine> IteratedSearch::create_phase(int phase) {$/;"	f	class:iterated_search::IteratedSearch
create_potential_function	potentials/single_potential_heuristics.cc	/^static unique_ptr<PotentialFunction> create_potential_function($/;"	f	namespace:potentials
create_sample_based_potential_functions	potentials/sample_based_potential_heuristics.cc	/^static vector<unique_ptr<PotentialFunction>> create_sample_based_potential_functions($/;"	f	namespace:potentials
create_standard_scalar_open_list_factory	search_engines/search_common.cc	/^shared_ptr<OpenListFactory> create_standard_scalar_open_list_factory($/;"	f	namespace:search_common
create_state_open_list	open_lists/alternation_open_list.cc	/^AlternationOpenListFactory::create_state_open_list() {$/;"	f	class:AlternationOpenListFactory
create_state_open_list	open_lists/epsilon_greedy_open_list.cc	/^EpsilonGreedyOpenListFactory::create_state_open_list() {$/;"	f	class:EpsilonGreedyOpenListFactory
create_state_open_list	open_lists/pareto_open_list.cc	/^ParetoOpenListFactory::create_state_open_list() {$/;"	f	class:ParetoOpenListFactory
create_state_open_list	open_lists/standard_scalar_open_list.cc	/^StandardScalarOpenListFactory::create_state_open_list() {$/;"	f	class:StandardScalarOpenListFactory
create_state_open_list	open_lists/tiebreaking_open_list.cc	/^TieBreakingOpenListFactory::create_state_open_list() {$/;"	f	class:TieBreakingOpenListFactory
create_state_open_list	open_lists/type_based_open_list.cc	/^TypeBasedOpenListFactory::create_state_open_list() {$/;"	f	class:TypeBasedOpenListFactory
create_transition_systems	merge_and_shrink/fts_factory.cc	/^vector<unique_ptr<TransitionSystem>> FTSFactory::create_transition_systems() {$/;"	f	class:merge_and_shrink::FTSFactory
create_transitions	domain_transition_graph.cc	/^void DTGFactory::create_transitions(vector<DomainTransitionGraph *> &dtgs) {$/;"	f	class:DTGFactory
create_trivial_abstraction	cegar/abstraction.cc	/^void Abstraction::create_trivial_abstraction() {$/;"	f	class:cegar::Abstraction
create_wastar_eval	search_engines/search_common.cc	/^static ScalarEvaluator *create_wastar_eval($/;"	f	namespace:search_common
create_wastar_open_list_factory	search_engines/search_common.cc	/^shared_ptr<OpenListFactory> create_wastar_open_list_factory($/;"	f	namespace:search_common
created_trail_index	bliss/partition.h	/^    unsigned int created_trail_index;$/;"	m	class:bliss::Partition::CR_BTInfo
creating_operator	search_node_info.h	/^    int creating_operator;$/;"	m	struct:SearchNodeInfo
creation_level	bliss/graph.h	/^    unsigned int creation_level;$/;"	m	class:bliss::AbstractGraph::CR_CEP
current_abstract_state	cegar/abstraction.cc	/^    AbstractState *current_abstract_state;$/;"	m	struct:cegar::Flaw	file:
current_bucket_no	algorithms/priority_queues.h	/^    mutable int current_bucket_no;$/;"	m	class:priority_queues::BucketQueue
current_clock	utils/timer.cc	/^double Timer::current_clock() const {$/;"	f	class:utils::Timer
current_eval_context	search_engines/enforced_hill_climbing_search.h	/^    EvaluationContext current_eval_context;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
current_eval_context	search_engines/lazy_search.h	/^    EvaluationContext current_eval_context;$/;"	m	class:lazy_search::LazySearch
current_g	search_engines/lazy_search.h	/^    int current_g;$/;"	m	class:lazy_search::LazySearch
current_group_id	merge_and_shrink/transition_system.h	/^    int current_group_id;$/;"	m	class:merge_and_shrink::TSConstIterator
current_index	merge_and_shrink/factored_transition_system.h	/^    int current_index;$/;"	m	class:merge_and_shrink::FTSConstIterator
current_max_clique	algorithms/max_cliques.cc	/^    vector<int> current_max_clique;$/;"	m	class:max_cliques::MaxCliqueComputer	file:
current_operator	search_engines/lazy_search.h	/^    const GlobalOperator *current_operator;$/;"	m	class:lazy_search::LazySearch
current_pdbs	pdbs/pattern_collection_generator_hillclimbing.h	/^    std::unique_ptr<IncrementalCanonicalPDBs> current_pdbs;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
current_phase_start_g	search_engines/enforced_hill_climbing_search.h	/^    int current_phase_start_g;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
current_predecessor_id	search_engines/lazy_search.h	/^    StateID current_predecessor_id;$/;"	m	class:lazy_search::LazySearch
current_real_g	search_engines/lazy_search.h	/^    int current_real_g;$/;"	m	class:lazy_search::LazySearch
current_state	search_engines/lazy_search.h	/^    GlobalState current_state;$/;"	m	class:lazy_search::LazySearch
cursor	bliss/kstack.h	/^  Type *cursor;$/;"	m	class:bliss::KStack
d_counts	search_engines/enforced_hill_climbing_search.h	/^    std::map<int, std::pair<int, int>> d_counts;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
data	ext/tree.hh	/^		T data;$/;"	m	class:tree_node_
dcs_count	bliss/partition.h	/^  unsigned int dcs_count[256];$/;"	m	class:bliss::Partition
dcs_cumulate_count	bliss/partition.cc	/^Partition::dcs_cumulate_count(const unsigned int max)$/;"	f	class:bliss::Partition
dcs_start	bliss/partition.h	/^  unsigned int dcs_start[256];$/;"	m	class:bliss::Partition
dead_end_states	search_statistics.h	/^    int dead_end_states;$/;"	m	class:SearchStatistics
dead_ends_are_reliable	evaluators/combining_evaluator.cc	/^bool CombiningEvaluator::dead_ends_are_reliable() const {$/;"	f	class:combining_evaluator::CombiningEvaluator
dead_ends_are_reliable	evaluators/weighted_evaluator.cc	/^bool WeightedEvaluator::dead_ends_are_reliable() const {$/;"	f	class:weighted_evaluator::WeightedEvaluator
dead_ends_are_reliable	heuristics/cea_heuristic.cc	/^bool ContextEnhancedAdditiveHeuristic::dead_ends_are_reliable() const {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
dead_ends_are_reliable	heuristics/cg_heuristic.cc	/^bool CGHeuristic::dead_ends_are_reliable() const {$/;"	f	class:cg_heuristic::CGHeuristic
dead_ends_are_reliable	heuristics/hm_heuristic.cc	/^bool HMHeuristic::dead_ends_are_reliable() const {$/;"	f	class:hm_heuristic::HMHeuristic
dead_ends_are_reliable	heuristics/relaxation_heuristic.cc	/^bool RelaxationHeuristic::dead_ends_are_reliable() const {$/;"	f	class:relaxation_heuristic::RelaxationHeuristic
dead_ends_are_reliable	landmarks/landmark_count_heuristic.cc	/^bool LandmarkCountHeuristic::dead_ends_are_reliable() const {$/;"	f	class:landmarks::LandmarkCountHeuristic
dead_ends_are_reliable	scalar_evaluator.cc	/^bool ScalarEvaluator::dead_ends_are_reliable() const {$/;"	f	class:ScalarEvaluator
dead_ends_reliable	landmarks/landmark_count_heuristic.h	/^    const bool dead_ends_reliable;$/;"	m	class:landmarks::LandmarkCountHeuristic
debug	cegar/abstraction.h	/^    const bool debug;$/;"	m	class:cegar::Abstraction
debug	utils/util.h	/^inline void debug(int index, const char* func = __PRETTY_FUNCTION__,  int line = __LINE__)$/;"	f
decrease_g_value_to	cegar/abstract_state.h	/^    void decrease_g_value_to(int new_g) {$/;"	f	class:cegar::AbstractSearchInfo
default_generator	successor_generator.cc	/^    GeneratorBase *default_generator;$/;"	m	class:GeneratorSwitch	file:
default_options	heuristic.cc	/^Options Heuristic::default_options() {$/;"	f	class:Heuristic
default_value	options/doc_store.h	/^    std::string default_value;$/;"	m	struct:options::ArgumentInfo
default_value	per_state_information.h	/^    const Entry default_value;$/;"	m	class:PerStateInformation
default_values	axioms.h	/^    std::vector<int> default_values;$/;"	m	class:AxiomEvaluator
degree_invariant	bliss/graph.cc	/^Graph::degree_invariant(const Graph* const g, const unsigned int v)$/;"	f	class:bliss::Graph
delete_generators	structural_symmetries/group.cc	/^void Group::delete_generators() {$/;"	f	class:Group
delta	search_engines/top_k_eager_search.h	/^	int delta = -1; $/;"	m	struct:top_k_eager_search::StateActionPair
depends_on	heuristics/cg_cache.h	/^    std::vector<std::vector<int>> depends_on;$/;"	m	class:cg_heuristic::CGCache
depth	ext/tree.hh	/^int tree<T, tree_node_allocator>::depth(const iterator_base& it) $/;"	f	class:tree
depth	ext/tree.hh	/^int tree<T, tree_node_allocator>::depth(const iterator_base& it, const iterator_base& root) $/;"	f	class:tree
depth	landmarks/exploration.h	/^    int depth;$/;"	m	struct:landmarks::ExProposition
depth	landmarks/exploration.h	/^    int depth;$/;"	m	struct:landmarks::ExUnaryOperator
descend_all	ext/tree.hh	/^void tree<T, tree_node_allocator>::post_order_iterator::descend_all()$/;"	f	class:tree::post_order_iterator
description	heuristic.h	/^    std::string description;$/;"	m	class:Heuristic
description	options/doc_store.h	/^    std::string description;$/;"	m	struct:options::LanguageSupportInfo
description	options/doc_store.h	/^    std::string description;$/;"	m	struct:options::NoteInfo
description	options/doc_store.h	/^    std::string description;$/;"	m	struct:options::PropertyInfo
desired_abstract_state	cegar/abstraction.cc	/^    const AbstractState desired_abstract_state;$/;"	m	struct:cegar::Flaw	file:
destructor	ext/tree.hh	/^void destructor(T1* p)$/;"	f	namespace:kp
detach	bliss/partition.h	/^    void detach() {$/;"	f	class:bliss::Partition::CRCell
deviations	cegar/abstraction.h	/^    int deviations;$/;"	m	class:cegar::Abstraction
did_write_overflow_warning	heuristics/additive_heuristic.h	/^    bool did_write_overflow_warning;$/;"	m	class:additive_heuristic::AdditiveHeuristic
did_write_overflow_warning	landmarks/exploration.h	/^    bool did_write_overflow_warning;$/;"	m	class:landmarks::Exploration
difference_type	ext/tree.hh	/^				typedef ptrdiff_t                       difference_type;$/;"	t	class:tree::iterator_base
dijkstra_search	merge_and_shrink/distances.cc	/^static void dijkstra_search($/;"	f	namespace:merge_and_shrink
dimension	open_lists/tiebreaking_open_list.cc	/^int TieBreakingOpenList<Entry>::dimension() const {$/;"	f	class:TieBreakingOpenList
dirty	heuristic.h	/^        unsigned int dirty : 1;$/;"	m	struct:Heuristic::HEntry
disabled	pruning/stubborn_sets_ec.h	/^    std::vector<std::vector<int>> disabled;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
discard_all_orderings	landmarks/landmark_factory.cc	/^void LandmarkFactory::discard_all_orderings() {$/;"	f	class:landmarks::LandmarkFactory
discard_conjunctive_landmarks	landmarks/landmark_factory.cc	/^void LandmarkFactory::discard_conjunctive_landmarks() {$/;"	f	class:landmarks::LandmarkFactory
discard_disjunctive_landmarks	landmarks/landmark_factory.cc	/^void LandmarkFactory::discard_disjunctive_landmarks() {$/;"	f	class:landmarks::LandmarkFactory
discard_noncausal_landmarks	landmarks/landmark_factory.cc	/^void LandmarkFactory::discard_noncausal_landmarks(const TaskProxy &task_proxy, Exploration &exploration) {$/;"	f	class:landmarks::LandmarkFactory
discard_states	merge_and_shrink/factored_transition_system.cc	/^void FactoredTransitionSystem::discard_states($/;"	f	class:merge_and_shrink::FactoredTransitionSystem
discrete_cell_count	bliss/partition.h	/^  unsigned int discrete_cell_count;$/;"	m	class:bliss::Partition
discrete_cell_limit	bliss/graph.h	/^    unsigned int discrete_cell_limit;$/;"	m	class:bliss::AbstractGraph::CR_CEP
disj_landmark_exists	landmarks/landmark_graph.cc	/^bool LandmarkGraph::disj_landmark_exists(const set<FactPair> &lm) const {$/;"	f	class:landmarks::LandmarkGraph
disj_lms_to_nodes	landmarks/landmark_graph.h	/^    std::unordered_map<FactPair, LandmarkNode *> disj_lms_to_nodes;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
disjoint_patterns	pdbs/pattern_collection_generator_genetic.h	/^    const bool disjoint_patterns;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
disjunction_classes	landmarks/landmark_factory_rpg_sasp.h	/^    std::vector<std::vector<int>> disjunction_classes;$/;"	m	class:landmarks::LandmarkFactoryRpgSasp
disjunctive	landmarks/landmark_graph.h	/^    bool disjunctive;$/;"	m	class:landmarks::EdgeType::LandmarkNode
disjunctive_landmarks	landmarks/landmark_factory.h	/^    const bool disjunctive_landmarks;$/;"	m	class:landmarks::LandmarkFactory
distances	domain_transition_graph.h	/^    std::vector<int> distances;$/;"	m	struct:ValueNode
distances	merge_and_shrink/factored_transition_system.h	/^    std::vector<std::unique_ptr<Distances>> distances;$/;"	m	class:merge_and_shrink::FactoredTransitionSystem
distances	pdbs/pattern_database.h	/^    std::vector<int> distances;$/;"	m	class:pdbs::PatternDatabase
diverse_functions	potentials/diverse_potential_heuristics.h	/^    std::vector<std::unique_ptr<PotentialFunction>> diverse_functions;$/;"	m	class:potentials::DiversePotentialHeuristics
djkstra_search	search_engines/kstar.cc	/^void KStar::djkstra_search() {$/;"	f	class:kstar::KStar
do_insertion	open_lists/alternation_open_list.cc	/^void AlternationOpenList<Entry>::do_insertion($/;"	f	class:AlternationOpenList
do_insertion	open_lists/epsilon_greedy_open_list.cc	/^void EpsilonGreedyOpenList<Entry>::do_insertion($/;"	f	class:EpsilonGreedyOpenList
do_insertion	open_lists/pareto_open_list.cc	/^void ParetoOpenList<Entry>::do_insertion($/;"	f	class:ParetoOpenList
do_insertion	open_lists/standard_scalar_open_list.cc	/^void StandardScalarOpenList<Entry>::do_insertion($/;"	f	class:StandardScalarOpenList
do_insertion	open_lists/tiebreaking_open_list.cc	/^void TieBreakingOpenList<Entry>::do_insertion($/;"	f	class:TieBreakingOpenList
do_insertion	open_lists/type_based_open_list.cc	/^void TypeBasedOpenList<Entry>::do_insertion($/;"	f	class:TypeBasedOpenList
do_intersection	landmarks/landmark_status_manager.h	/^    const bool do_intersection;$/;"	m	class:landmarks::LandmarkStatusManager
do_refine_to_equitable	bliss/graph.cc	/^AbstractGraph::do_refine_to_equitable()$/;"	f	class:bliss::AbstractGraph
document_hide	options/option_parser.cc	/^void OptionParser::document_hide() const {$/;"	f	class:options::OptionParser
document_language_support	options/option_parser.cc	/^void OptionParser::document_language_support(string feature,$/;"	f	class:options::OptionParser
document_note	options/option_parser.cc	/^void OptionParser::document_note(string name,$/;"	f	class:options::OptionParser
document_property	options/option_parser.cc	/^void OptionParser::document_property(string property, string note) const {$/;"	f	class:options::OptionParser
document_synopsis	options/option_parser.cc	/^void OptionParser::document_synopsis(string name, string note) const {$/;"	f	class:options::OptionParser
document_values	options/option_parser.cc	/^void OptionParser::document_values(string argument,$/;"	f	class:options::OptionParser
documentation	options/registries.h	/^    std::string documentation;$/;"	m	class:options::PluginTypeInfo
does_fire	global_operator.h	/^    bool does_fire(const GlobalState &state) const {$/;"	f	struct:GlobalEffect
does_fire	task_proxy.h	/^inline bool does_fire(EffectProxy effect, const State &state) {$/;"	f
dom_sum_by_var	structural_symmetries/permutation.cc	/^vector<int> Permutation::dom_sum_by_var;$/;"	m	class:Permutation	file:
dom_sum_by_var	structural_symmetries/permutation.h	/^    static std::vector<int> dom_sum_by_var;$/;"	m	class:Permutation
domain_connectivity	landmarks/landmark_factory_rpg_sasp.cc	/^bool LandmarkFactoryRpgSasp::domain_connectivity(const State &initial_state,$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
domain_size	merge_and_shrink/merge_and_shrink_representation.h	/^    int domain_size;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentation
domain_size	tasks/domain_abstracted_task.h	/^    const std::vector<int> domain_size;$/;"	m	class:extra_tasks::DomainAbstractedTask
domain_size	tasks/domain_abstracted_task_factory.cc	/^    vector<int> domain_size;$/;"	m	class:extra_tasks::DomainAbstractedTaskFactory	file:
domain_subsets	cegar/domains.h	/^    std::vector<Bitset> domain_subsets;$/;"	m	class:cegar::Domains
domains	cegar/abstract_state.h	/^    Domains domains;$/;"	m	class:cegar::AbstractState
domains_intersect	cegar/abstract_state.cc	/^bool AbstractState::domains_intersect(const AbstractState *other, int var) const {$/;"	f	class:cegar::AbstractState
dominates	open_lists/pareto_open_list.cc	/^bool ParetoOpenList<Entry>::dominates($/;"	f	class:ParetoOpenList
done	merge_and_shrink/merge_tree.h	/^    bool done() const {$/;"	f	class:merge_and_shrink::MergeTree
done	variable_order_finder.cc	/^bool VariableOrderFinder::done() const {$/;"	f	class:VariableOrderFinder
downheap	bliss/heap.cc	/^void Heap::downheap(unsigned int index)$/;"	f	class:bliss::Heap
dry_run	options/option_parser.cc	/^bool OptionParser::dry_run() const {$/;"	f	class:options::OptionParser
dry_run_	options/option_parser.h	/^    bool dry_run_;$/;"	m	class:options::OptionParser
dtg_successors	landmarks/landmark_factory_rpg_sasp.h	/^    std::vector<std::vector<std::unordered_set<int>>> dtg_successors;$/;"	m	class:landmarks::LandmarkFactoryRpgSasp
dump	bliss/defs.h	/^    virtual void dump() const {$/;"	f	struct:bliss::BlissMemoryOut
dump	bliss/defs.h	/^    virtual void dump() const {$/;"	f	struct:bliss::BlissTimeOut
dump	causal_graph.cc	/^void CausalGraph::dump(const TaskProxy &task_proxy) const {$/;"	f	class:CausalGraph
dump	global_operator.cc	/^void GlobalCondition::dump() const {$/;"	f	class:GlobalCondition
dump	global_operator.cc	/^void GlobalEffect::dump() const {$/;"	f	class:GlobalEffect
dump	global_operator.cc	/^void GlobalOperator::dump() const {$/;"	f	class:GlobalOperator
dump	landmarks/landmark_graph.cc	/^void LandmarkGraph::dump(const VariablesProxy &variables) const {$/;"	f	class:landmarks::LandmarkGraph
dump	merge_and_shrink/distances.cc	/^void Distances::dump() const {$/;"	f	class:merge_and_shrink::Distances
dump	merge_and_shrink/factored_transition_system.cc	/^void FactoredTransitionSystem::dump(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
dump	merge_and_shrink/merge_and_shrink_representation.cc	/^void MergeAndShrinkRepresentationLeaf::dump() const {$/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
dump	merge_and_shrink/merge_and_shrink_representation.cc	/^void MergeAndShrinkRepresentationMerge::dump() const {$/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
dump	merge_and_shrink/shrink_bisimulation.cc	/^    void dump() const {$/;"	f	struct:merge_and_shrink::Signature
dump	pdbs/match_tree.cc	/^void MatchTree::dump() const {$/;"	f	class:pdbs::MatchTree
dump	pdbs/pattern_database.cc	/^void AbstractOperator::dump(const Pattern &pattern,$/;"	f	class:pdbs::AbstractOperator
dump	pdbs/zero_one_pdbs.cc	/^void ZeroOnePDBs::dump() const {$/;"	f	class:pdbs::ZeroOnePDBs
dump	search_space.cc	/^void SearchNode::dump() const {$/;"	f	class:SearchNode
dump	search_space.cc	/^void SearchSpace::dump() const {$/;"	f	class:SearchSpace
dump	structural_symmetries/group.h	/^    bool dump;$/;"	m	class:Group
dump	structural_symmetries/permutation.cc	/^void Permutation::dump() const {$/;"	f	class:Permutation
dump_SAS	global_operator.cc	/^void GlobalOperator::dump_SAS(ofstream& os, const vector<GlobalCondition>& extra_pre,$/;"	f	class:GlobalOperator
dump_SAS	global_operator.h	/^    void dump_SAS(std::ofstream& os) const {$/;"	f	struct:GlobalCondition
dump_astar_search_space	search_engines/kstar.cc	/^void KStar::dump_astar_search_space() {$/;"	f	class:kstar::KStar
dump_axiom_to_SAS	abstract_task.cc	/^void AbstractTask::dump_axiom_to_SAS(std::ostream &os, int op_no) const {$/;"	f	class:AbstractTask
dump_axioms_to_SAS	abstract_task.cc	/^void AbstractTask::dump_axioms_to_SAS(std::ostream &os) const {$/;"	f	class:AbstractTask
dump_condition_SAS	globals.cc	/^void dump_condition_SAS(std::ostream& os, GlobalCondition cond) {$/;"	f
dump_djkstra_search	search_engines/kstar.cc	/^void KStar::dump_djkstra_search() {$/;"	f	class:kstar::KStar
dump_dot	search_space.cc	/^void SearchSpace::dump_dot() const {$/;"	f	class:SearchSpace
dump_dot_graph	merge_and_shrink/transition_system.cc	/^void TransitionSystem::dump_dot_graph() const {$/;"	f	class:merge_and_shrink::TransitionSystem
dump_everything	globals.cc	/^void dump_everything() {$/;"	f
dump_fdr	global_state.cc	/^void GlobalState::dump_fdr() const {$/;"	f	class:GlobalState
dump_fdr	structural_symmetries/permutation.cc	/^void Permutation::dump_fdr() const {$/;"	f	class:Permutation
dump_fdr	task_proxy.cc	/^void State::dump_fdr() const {$/;"	f	class:State
dump_forbid_plan_reformulation	search_engines/eager_search.h	/^    bool dump_forbid_plan_reformulation;$/;"	m	class:eager_search::EagerSearch
dump_function_specific_options	merge_and_shrink/merge_scoring_function.h	/^    virtual void dump_function_specific_options() const {}$/;"	f	class:merge_and_shrink::MergeScoringFunction
dump_function_specific_options	merge_and_shrink/merge_scoring_function_single_random.cc	/^void MergeScoringFunctionSingleRandom::dump_function_specific_options() const {$/;"	f	class:merge_and_shrink::MergeScoringFunctionSingleRandom
dump_function_specific_options	merge_and_shrink/merge_scoring_function_total_order.cc	/^void MergeScoringFunctionTotalOrder::dump_function_specific_options() const {$/;"	f	class:merge_and_shrink::MergeScoringFunctionTotalOrder
dump_generators	structural_symmetries/group.cc	/^void Group::dump_generators() const {$/;"	f	class:Group
dump_goal	globals.cc	/^void dump_goal() {$/;"	f
dump_goal_to_SAS	abstract_task.cc	/^void AbstractTask::dump_goal_to_SAS(std::ostream &os) const {$/;"	f	class:AbstractTask
dump_initial_state_to_SAS	abstract_task.cc	/^void AbstractTask::dump_initial_state_to_SAS(std::ostream &os) const {$/;"	f	class:AbstractTask
dump_labels	merge_and_shrink/labels.cc	/^void Labels::dump_labels() const {$/;"	f	class:merge_and_shrink::Labels
dump_labels_and_transitions	merge_and_shrink/transition_system.cc	/^void TransitionSystem::dump_labels_and_transitions() const {$/;"	f	class:merge_and_shrink::TransitionSystem
dump_metric	globals.cc	/^void dump_metric(std::ostream& os) {$/;"	f
dump_mutexes	globals.cc	/^void dump_mutexes(std::ostream& os) {$/;"	f
dump_node	landmarks/landmark_graph.cc	/^void LandmarkGraph::dump_node(const VariablesProxy &variables, const LandmarkNode *node_p) const {$/;"	f	class:landmarks::LandmarkGraph
dump_operator_pre_post_to_SAS	abstract_task.cc	/^void AbstractTask::dump_operator_pre_post_to_SAS(std::ostream& os, int pre, const GlobalEffect& eff) const {$/;"	f	class:AbstractTask
dump_operator_to_SAS	abstract_task.cc	/^void AbstractTask::dump_operator_to_SAS(std::ostream &os, int op_no) const {$/;"	f	class:AbstractTask
dump_operators_to_SAS	abstract_task.cc	/^void AbstractTask::dump_operators_to_SAS(std::ostream &os) const {$/;"	f	class:AbstractTask
dump_options	merge_and_shrink/label_reduction.cc	/^void LabelReduction::dump_options() const {$/;"	f	class:merge_and_shrink::LabelReduction
dump_options	merge_and_shrink/merge_and_shrink_heuristic.cc	/^void MergeAndShrinkHeuristic::dump_options() const {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
dump_options	merge_and_shrink/merge_scoring_function.cc	/^void MergeScoringFunction::dump_options() const {$/;"	f	class:merge_and_shrink::MergeScoringFunction
dump_options	merge_and_shrink/merge_selector.cc	/^void MergeSelector::dump_options() const {$/;"	f	class:merge_and_shrink::MergeSelector
dump_options	merge_and_shrink/merge_strategy_factory.cc	/^void MergeStrategyFactory::dump_options() const {$/;"	f	class:merge_and_shrink::MergeStrategyFactory
dump_options	merge_and_shrink/merge_tree_factory.cc	/^void MergeTreeFactory::dump_options() const {$/;"	f	class:merge_and_shrink::MergeTreeFactory
dump_options	merge_and_shrink/shrink_strategy.cc	/^void ShrinkStrategy::dump_options() const {$/;"	f	class:merge_and_shrink::ShrinkStrategy
dump_path_graph	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::dump_path_graph() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
dump_pddl	global_state.cc	/^void GlobalState::dump_pddl() const {$/;"	f	class:GlobalState
dump_pddl	task_proxy.cc	/^void State::dump_pddl() const {$/;"	f	class:State
dump_plan_forbid_reformulation_sas	globals.cc	/^void dump_plan_forbid_reformulation_sas(const char* filename,$/;"	f
dump_pre_post_SAS	global_operator.cc	/^void GlobalOperator::dump_pre_post_SAS(std::ofstream& os, int pre, GlobalEffect eff) const {$/;"	f	class:GlobalOperator
dump_pre_post_SAS	globals.cc	/^void dump_pre_post_SAS(std::ostream& os, int pre, GlobalEffect eff) {$/;"	f
dump_recursive	pdbs/match_tree.cc	/^void MatchTree::dump_recursive(Node *node) const {$/;"	f	class:pdbs::MatchTree
dump_search_space	search_engines/eager_search.cc	/^void EagerSearch::dump_search_space() const {$/;"	f	class:eager_search::EagerSearch
dump_specific_options	merge_and_shrink/merge_selector.h	/^    virtual void dump_specific_options() const {}$/;"	f	class:merge_and_shrink::MergeSelector
dump_specific_options	merge_and_shrink/merge_selector_score_based_filtering.cc	/^void MergeSelectorScoreBasedFiltering::dump_specific_options() const {$/;"	f	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
dump_strategy_specific_options	merge_and_shrink/merge_strategy_factory_precomputed.cc	/^void MergeStrategyFactoryPrecomputed::dump_strategy_specific_options() const {$/;"	f	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
dump_strategy_specific_options	merge_and_shrink/merge_strategy_factory_stateless.cc	/^void MergeStrategyFactoryStateless::dump_strategy_specific_options() const {$/;"	f	class:merge_and_shrink::MergeStrategyFactoryStateless
dump_strategy_specific_options	merge_and_shrink/shrink_bisimulation.cc	/^void ShrinkBisimulation::dump_strategy_specific_options() const {$/;"	f	class:merge_and_shrink::ShrinkBisimulation
dump_strategy_specific_options	merge_and_shrink/shrink_fh.cc	/^void ShrinkFH::dump_strategy_specific_options() const {$/;"	f	class:merge_and_shrink::ShrinkFH
dump_table	heuristics/hm_heuristic.cc	/^void HMHeuristic::dump_table() const {$/;"	f	class:hm_heuristic::HMHeuristic
dump_to_SAS	abstract_task.cc	/^void AbstractTask::dump_to_SAS(ostream &os) const {$/;"	f	class:AbstractTask
dump_tree_specific_options	merge_and_shrink/merge_tree_factory.h	/^    virtual void dump_tree_specific_options() const {}$/;"	f	class:merge_and_shrink::MergeTreeFactory
dump_tree_specific_options	merge_and_shrink/merge_tree_factory_linear.cc	/^void MergeTreeFactoryLinear::dump_tree_specific_options() const {$/;"	f	class:merge_and_shrink::MergeTreeFactoryLinear
dump_var_vals	structural_symmetries/permutation.cc	/^void Permutation::dump_var_vals() const {$/;"	f	class:Permutation
dump_variable	globals.cc	/^void dump_variable(std::ostream& os, std::string name, int axiom_layer, int domain, const std::vector<std::string>& values) {$/;"	f
dump_variable_order_type	variable_order_finder.cc	/^void dump_variable_order_type(VariableOrderType variable_order_type) {$/;"	f
dump_variables_equivalence_classes	structural_symmetries/group.cc	/^void Group::dump_variables_equivalence_classes() const {$/;"	f	class:Group
dump_variables_to_SAS	abstract_task.cc	/^void AbstractTask::dump_variables_to_SAS(std::ostream &os) const {$/;"	f	class:AbstractTask
dump_version	globals.cc	/^void dump_version(std::ostream& os) {$/;"	f
dynamic_bitset	algorithms/dynamic_bitset.h	/^namespace dynamic_bitset {$/;"	n
eager_search	search_engines/eager_search.cc	/^namespace eager_search {$/;"	n	file:
eager_search	search_engines/eager_search.h	/^namespace eager_search {$/;"	n
edge_add	landmarks/landmark_factory.cc	/^void LandmarkFactory::edge_add(LandmarkNode &from, LandmarkNode &to,$/;"	f	class:landmarks::LandmarkFactory
edges	bliss/graph.h	/^    std::vector<unsigned int> edges;$/;"	m	class:bliss::Graph::Vertex
edges_in	bliss/graph.h	/^    std::vector<unsigned int> edges_in;$/;"	m	class:bliss::Digraph::Vertex
edges_out	bliss/graph.h	/^    std::vector<unsigned int> edges_out;$/;"	m	class:bliss::Digraph::Vertex
eff	landmarks/landmark_factory_h_m.h	/^    std::vector<int> eff;$/;"	m	struct:landmarks::PMOp
eff_eff_builder	causal_graph.cc	/^    IntRelationBuilder eff_eff_builder;$/;"	m	struct:CausalGraphBuilder	file:
eff_index	task_proxy.h	/^    int eff_index;$/;"	m	class:EffectConditionsProxy
eff_index	task_proxy.h	/^    int eff_index;$/;"	m	class:EffectProxy
eff_pre_builder	causal_graph.cc	/^    IntRelationBuilder eff_pre_builder;$/;"	m	struct:CausalGraphBuilder	file:
eff_to_eff	causal_graph.h	/^    IntRelation eff_to_eff;$/;"	m	class:CausalGraph
eff_to_pre	causal_graph.h	/^    IntRelation eff_to_pre;$/;"	m	class:CausalGraph
effect	domain_transition_graph.h	/^    std::vector<LocalAssignment> effect;$/;"	m	struct:ValueTransitionLabel
effect	heuristics/relaxation_heuristic.h	/^    Proposition *effect;$/;"	m	struct:relaxation_heuristic::UnaryOperator
effect	landmarks/exploration.h	/^    ExProposition *effect;$/;"	m	struct:landmarks::ExUnaryOperator
effect_always_happens	landmarks/landmark_factory.cc	/^bool LandmarkFactory::effect_always_happens(const VariablesProxy &variables,$/;"	f	class:landmarks::LandmarkFactory
effect_can_be_overwritten	structural_symmetries/graph_creator.cc	/^bool GraphCreator::effect_can_be_overwritten(int ind, const std::vector<GlobalEffect> &effects) const {$/;"	f	class:GraphCreator
effect_literal	axioms.h	/^        AxiomLiteral *effect_literal;$/;"	m	struct:AxiomEvaluator::AxiomRule
effect_of	heuristics/lm_cut_landmarks.h	/^    std::vector<RelaxedOperator *> effect_of;$/;"	m	struct:lm_cut_heuristic::RelaxedProposition
effect_val	axioms.h	/^        int effect_val;$/;"	m	struct:AxiomEvaluator::AxiomRule
effect_var	axioms.h	/^        int effect_var;$/;"	m	struct:AxiomEvaluator::AxiomRule
effects	global_operator.h	/^    std::vector<GlobalEffect> effects;$/;"	m	class:GlobalOperator
effects	heuristics/lm_cut_landmarks.h	/^    std::vector<RelaxedProposition *> effects;$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
ehc	search_engines/enforced_hill_climbing_search.cc	/^SearchStatus EnforcedHillClimbingSearch::ehc() {$/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
element	bliss/orbit.h	/^    unsigned int element;$/;"	m	class:bliss::Orbit::OrbitEntry
element_allocator	algorithms/segmented_vector.h	/^    ElementAllocator element_allocator;$/;"	m	class:segmented_vector::SegmentedArrayVector
element_at	bliss/kstack.h	/^  Type element_at(unsigned int i)$/;"	f	class:bliss::KStack
element_positions	algorithms/equivalence_relation.h	/^    ElementPositionMap element_positions;$/;"	m	class:equivalence_relation::EquivalenceRelation
element_to_cell_map	bliss/partition.h	/^  Cell **element_to_cell_map;$/;"	m	class:bliss::Partition
elements	algorithms/equivalence_relation.h	/^    std::list<int> elements;$/;"	m	class:equivalence_relation::Block
elements	bliss/partition.h	/^  unsigned int *elements;$/;"	m	class:bliss::Partition
elements	lp/lp_solver.h	/^    std::vector<double> elements;$/;"	m	class:lp::LPSolver
elements_per_array	algorithms/segmented_vector.h	/^    const size_t elements_per_array;$/;"	m	class:segmented_vector::SegmentedArrayVector
elements_per_segment	algorithms/segmented_vector.h	/^    const size_t elements_per_segment;$/;"	m	class:segmented_vector::SegmentedArrayVector
empty	algorithms/equivalence_relation.cc	/^bool Block::empty() const {$/;"	f	class:equivalence_relation::Block
empty	algorithms/ordered_set.h	/^    bool empty() const {$/;"	f	class:ordered_set::OrderedSet
empty	algorithms/priority_queues.h	/^    bool empty() const {$/;"	f	class:priority_queues::AdaptiveQueue
empty	algorithms/priority_queues.h	/^    virtual bool empty() const {$/;"	f	class:priority_queues::BucketQueue
empty	algorithms/priority_queues.h	/^    virtual bool empty() const {$/;"	f	class:priority_queues::HeapQueue
empty	ext/tree.hh	/^bool tree<T, tree_node_allocator>::empty() const$/;"	f	class:tree
empty	landmarks/landmark_cost_assignment.h	/^    const std::set<int> empty;$/;"	m	class:landmarks::LandmarkCostAssignment
empty	lp/lp_solver.cc	/^bool LPConstraint::empty() const {$/;"	f	class:lp::LPConstraint
empty	merge_and_shrink/label_equivalence_relation.h	/^    bool empty() const {$/;"	f	class:merge_and_shrink::LabelGroup
empty	open_lists/alternation_open_list.cc	/^bool AlternationOpenList<Entry>::empty() const {$/;"	f	class:AlternationOpenList
empty	open_lists/epsilon_greedy_open_list.cc	/^bool EpsilonGreedyOpenList<Entry>::empty() const {$/;"	f	class:EpsilonGreedyOpenList
empty	open_lists/pareto_open_list.cc	/^bool ParetoOpenList<Entry>::empty() const {$/;"	f	class:ParetoOpenList
empty	open_lists/standard_scalar_open_list.cc	/^bool StandardScalarOpenList<Entry>::empty() const {$/;"	f	class:StandardScalarOpenList
empty	open_lists/tiebreaking_open_list.cc	/^bool TieBreakingOpenList<Entry>::empty() const {$/;"	f	class:TieBreakingOpenList
empty	open_lists/type_based_open_list.cc	/^bool TypeBasedOpenList<Entry>::empty() const {$/;"	f	class:TypeBasedOpenList
empty	task_proxy.h	/^    bool empty() const {$/;"	f	class:AxiomsProxy
empty	task_proxy.h	/^    bool empty() const {$/;"	f	class:ConditionsProxy
empty	task_proxy.h	/^    bool empty() const {$/;"	f	class:OperatorsProxy
end	algorithms/equivalence_relation.h	/^    BlockListConstIter end() const {return blocks.end(); }$/;"	f	class:equivalence_relation::EquivalenceRelation
end	algorithms/equivalence_relation.h	/^    ElementListConstIter end() const {return elements.end(); }$/;"	f	class:equivalence_relation::Block
end	algorithms/equivalence_relation.h	/^    ElementListIter end() {return elements.end(); }$/;"	f	class:equivalence_relation::Block
end	algorithms/ordered_set.h	/^    typename std::vector<T>::const_iterator end() const {$/;"	f	class:ordered_set::OrderedSet
end	bliss/kqueue.h	/^  Type *entries, *end;$/;"	m	class:bliss::KQueue
end	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::end() const$/;"	f	class:tree
end	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::end(const iterator_base& pos) const$/;"	f	class:tree
end	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::iterator_base::end() const$/;"	f	class:tree::iterator_base
end	merge_and_shrink/factored_transition_system.h	/^    FTSConstIterator end() const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
end	merge_and_shrink/label_equivalence_relation.h	/^    LabelConstIter end() const {$/;"	f	class:merge_and_shrink::LabelGroup
end	merge_and_shrink/transition_system.h	/^    TSConstIterator end() const {$/;"	f	class:merge_and_shrink::TransitionSystem
end	options/registries.h	/^    Map::const_iterator end() const {$/;"	f	class:options::PluginTypeRegistry
end	per_state_information.h	/^    const_iterator end(const StateRegistry *registry) const {$/;"	f	class:PerStateInformation
end	task_proxy.h	/^    FactsProxyIterator end() const {$/;"	f	class:FactsProxy
end	task_proxy.h	/^inline ProxyIterator<ProxyCollection> end(ProxyCollection &collection) {$/;"	f
end_breadth_first	ext/tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::end_breadth_first() const$/;"	f	class:tree
end_fixed	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::end_fixed(const iterator_base& pos, unsigned int dp) const$/;"	f	class:tree
end_leaf	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::end_leaf() const$/;"	f	class:tree
end_leaf	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::end_leaf(const iterator_base& top) const$/;"	f	class:tree
end_of_roots_children	options/parse_tree.h	/^typename tree<T>::sibling_iterator end_of_roots_children(const tree<T> &tr) {$/;"	f	namespace:options
end_post	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::end_post() const$/;"	f	class:tree
enforced_hill_climbing_search	search_engines/enforced_hill_climbing_search.cc	/^namespace enforced_hill_climbing_search {$/;"	n	file:
enforced_hill_climbing_search	search_engines/enforced_hill_climbing_search.h	/^namespace enforced_hill_climbing_search {$/;"	n
engine_configs	search_engines/iterated_search.h	/^    const std::vector<options::ParseTree> engine_configs;$/;"	m	class:iterated_search::IteratedSearch
enqueue_if_necessary	heuristics/additive_heuristic.h	/^    void enqueue_if_necessary(Proposition *prop, int cost, UnaryOperator *op) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
enqueue_if_necessary	heuristics/lm_cut_landmarks.h	/^    void enqueue_if_necessary(RelaxedProposition *prop, int cost) {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
enqueue_if_necessary	heuristics/max_heuristic.h	/^    void enqueue_if_necessary(Proposition *prop, int cost) {$/;"	f	class:max_heuristic::HSPMaxHeuristic
enqueue_if_necessary	landmarks/exploration.cc	/^void Exploration::enqueue_if_necessary(ExProposition *prop, int cost, int depth,$/;"	f	class:landmarks::Exploration
enqueue_pattern_if_new	pdbs/pattern_collection_generator_systematic.cc	/^void PatternCollectionGeneratorSystematic::enqueue_pattern_if_new($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
enter_block	utils/logging.cc	/^void MemoryTracer::enter_block(const string &block_name) {$/;"	f	class:utils::MemoryTracer
entries	bliss/kqueue.h	/^  Type *entries, *end;$/;"	m	class:bliss::KQueue
entries	bliss/kstack.h	/^  Type *entries;$/;"	m	class:bliss::KStack
entries_by_registry	per_state_information.h	/^    EntryVectorMap entries_by_registry;$/;"	m	class:PerStateInformation
entry	open_lists/epsilon_greedy_open_list.cc	/^        Entry entry;$/;"	m	struct:EpsilonGreedyOpenList::HeapNode	file:
entry_allocator	algorithms/segmented_vector.h	/^    EntryAllocator entry_allocator;$/;"	m	class:segmented_vector::SegmentedVector
epsilon	open_lists/epsilon_greedy_open_list.cc	/^    double epsilon;$/;"	m	class:EpsilonGreedyOpenList	file:
eqref_hash	bliss/graph.cc	/^  UintSeqHash eqref_hash;$/;"	m	class:bliss::TreeNode	file:
eqref_hash	bliss/graph.cc	/^  UintSeqHash eqref_hash;$/;"	m	struct:bliss::__anon3	file:
eqref_hash	bliss/graph.h	/^  UintSeqHash eqref_hash;$/;"	m	class:bliss::AbstractGraph
eqref_max_certificate_index	bliss/graph.h	/^  unsigned int eqref_max_certificate_index;$/;"	m	class:bliss::AbstractGraph
equal	ext/tree.hh	/^bool tree<T, tree_node_allocator>::equal(const iter& one_, const iter& two, const iter& three_) const$/;"	f	class:tree
equal	ext/tree.hh	/^bool tree<T, tree_node_allocator>::equal(const iter& one_, const iter& two, const iter& three_, BinaryPredicate fun) const$/;"	f	class:tree
equal_subtree	ext/tree.hh	/^bool tree<T, tree_node_allocator>::equal_subtree(const iter& one_, const iter& two_) const$/;"	f	class:tree
equal_subtree	ext/tree.hh	/^bool tree<T, tree_node_allocator>::equal_subtree(const iter& one_, const iter& two_, BinaryPredicate fun) const$/;"	f	class:tree
equivalence_relation	algorithms/equivalence_relation.cc	/^namespace equivalence_relation {$/;"	n	file:
equivalence_relation	algorithms/equivalence_relation.h	/^namespace equivalence_relation {$/;"	n
equivalence_relation	merge_and_shrink/label_reduction.h	/^namespace equivalence_relation {$/;"	n
erase	algorithms/equivalence_relation.cc	/^void Block::erase(ElementListIter it) {$/;"	f	class:equivalence_relation::Block
erase	ext/tree.hh	/^iter tree<T, tree_node_allocator>::erase(iter it)$/;"	f	class:tree
erase	merge_and_shrink/label_equivalence_relation.h	/^    void erase(LabelIter pos) {$/;"	f	class:merge_and_shrink::LabelGroup
erase_children	ext/tree.hh	/^void tree<T, tree_node_allocator>::erase_children(const iterator_base& it)$/;"	f	class:tree
erase_children_and_set_index	merge_and_shrink/merge_tree.cc	/^pair<int, int> MergeTreeNode::erase_children_and_set_index(int new_index) {$/;"	f	class:merge_and_shrink::MergeTreeNode
error	options/option_parser.cc	/^void OptionParser::error(string msg) {$/;"	f	class:options::OptionParser
estimate_heuristics	search_engines/lazy_search.h	/^    std::vector<Heuristic *> estimate_heuristics;$/;"	m	class:lazy_search::LazySearch
eval	heuristics/hm_heuristic.cc	/^int HMHeuristic::eval(const Tuple &t) const {$/;"	f	class:hm_heuristic::HMHeuristic
eval_results	heuristic_cache.h	/^    EvaluationResults eval_results;$/;"	m	class:HeuristicCache
evaluate	axioms.cc	/^void AxiomEvaluator::evaluate(PackedStateBin *buffer,$/;"	f	class:AxiomEvaluator
evaluate	pdbs/pattern_collection_generator_genetic.cc	/^void PatternCollectionGeneratorGenetic::evaluate(vector<double> &fitness_values) {$/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
evaluated_states	search_statistics.h	/^    int evaluated_states; \/\/ no states for which h fn was computed$/;"	m	class:SearchStatistics
evaluations	search_statistics.h	/^    int evaluations;      \/\/ no of heuristic evaluations performed$/;"	m	class:SearchStatistics
evaluator	evaluators/weighted_evaluator.h	/^    ScalarEvaluator *evaluator;$/;"	m	class:weighted_evaluator::WeightedEvaluator
evaluator	open_lists/epsilon_greedy_open_list.cc	/^    ScalarEvaluator *evaluator;$/;"	m	class:EpsilonGreedyOpenList	file:
evaluator	open_lists/standard_scalar_open_list.cc	/^    ScalarEvaluator *evaluator;$/;"	m	class:StandardScalarOpenList	file:
evaluators	open_lists/pareto_open_list.cc	/^    vector<ScalarEvaluator *> evaluators;$/;"	m	class:ParetoOpenList	file:
evaluators	open_lists/tiebreaking_open_list.cc	/^    vector<ScalarEvaluator *> evaluators;$/;"	m	class:TieBreakingOpenList	file:
evaluators	open_lists/type_based_open_list.cc	/^    vector<ScalarEvaluator *> evaluators;$/;"	m	class:TypeBasedOpenList	file:
exact_same_disj_landmark_exists	landmarks/landmark_graph.cc	/^bool LandmarkGraph::exact_same_disj_landmark_exists(const set<FactPair> &lm) const {$/;"	f	class:landmarks::LandmarkGraph
exit_handler	utils/system_unix.cc	/^void exit_handler(int, void *) {$/;"	f	namespace:utils
exit_with	utils/system.cc	/^void exit_with(ExitCode exitcode) {$/;"	f	namespace:utils
expand	algorithms/max_cliques.cc	/^    void expand(vector<int> &subg, vector<int> &cand) {$/;"	f	class:max_cliques::MaxCliqueComputer	file:
expand	search_engines/enforced_hill_climbing_search.cc	/^void EnforcedHillClimbingSearch::expand(EvaluationContext &eval_context) {$/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
expand_node	heuristics/cea_heuristic.cc	/^void ContextEnhancedAdditiveHeuristic::expand_node(LocalProblemNode *node) {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
expand_transition	heuristics/cea_heuristic.cc	/^void ContextEnhancedAdditiveHeuristic::expand_transition($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
expanded	heuristics/cea_heuristic.cc	/^    bool expanded;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
expanded_states	search_statistics.h	/^    int expanded_states;  \/\/ no states for which successors were generated$/;"	m	class:SearchStatistics
exploration	landmarks/landmark_count_heuristic.h	/^    Exploration exploration;$/;"	m	class:landmarks::LandmarkCountHeuristic
exported_op_ids	landmarks/exploration.h	/^    std::vector<int> exported_op_ids;$/;"	m	class:landmarks::Exploration
extend_global_to_local_mapping_if_necessary	domain_transition_graph.cc	/^void DTGFactory::extend_global_to_local_mapping_if_necessary($/;"	f	class:DTGFactory
extend_tuple	heuristics/hm_heuristic.cc	/^void HMHeuristic::extend_tuple(const Tuple &t, const OperatorProxy &op) {$/;"	f	class:hm_heuristic::HMHeuristic
extra_memory_padding	utils/memory.cc	/^static char *extra_memory_padding = nullptr;$/;"	m	namespace:utils	file:
extra_memory_padding_is_reserved	utils/memory.cc	/^bool extra_memory_padding_is_reserved() {$/;"	f	namespace:utils
extra_tasks	tasks/domain_abstracted_task.cc	/^namespace extra_tasks {$/;"	n	file:
extra_tasks	tasks/domain_abstracted_task.h	/^namespace extra_tasks {$/;"	n
extra_tasks	tasks/domain_abstracted_task_factory.cc	/^namespace extra_tasks {$/;"	n	file:
extra_tasks	tasks/domain_abstracted_task_factory.h	/^namespace extra_tasks {$/;"	n
extra_tasks	tasks/modified_goals_task.cc	/^namespace extra_tasks {$/;"	n	file:
extra_tasks	tasks/modified_goals_task.h	/^namespace extra_tasks {$/;"	n
extra_tasks	tasks/modified_operator_costs_task.cc	/^namespace extra_tasks {$/;"	n	file:
extra_tasks	tasks/modified_operator_costs_task.h	/^namespace extra_tasks {$/;"	n
extra_tasks	tasks/plan_forbid_reformulated_task.cc	/^namespace extra_tasks {$/;"	n	file:
extra_tasks	tasks/plan_forbid_reformulated_task.h	/^namespace extra_tasks {$/;"	n
extract_landmarks	landmarks/landmark_factory_zhu_givan.cc	/^void LandmarkFactoryZhuGivan::extract_landmarks($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
extract_lp_solution	potentials/potential_optimizer.cc	/^void PotentialOptimizer::extract_lp_solution() {$/;"	f	class:potentials::PotentialOptimizer
extract_refinement_hierarchy	cegar/abstraction.h	/^    RefinementHierarchy extract_refinement_hierarchy() {$/;"	f	class:cegar::Abstraction
extract_solution	cegar/abstract_search.cc	/^void AbstractSearch::extract_solution($/;"	f	class:cegar::AbstractSearch
extract_solution	lp/lp_solver.cc	/^vector<double> LPSolver::extract_solution() const {$/;"	f	class:lp::LPSolver
extract_sorted_entries	algorithms/priority_queues.h	/^    void extract_sorted_entries(std::vector<Entry> &result) {$/;"	f	class:priority_queues::BucketQueue
f_evaluator	search_engines/eager_search.h	/^    ScalarEvaluator *f_evaluator;$/;"	m	class:eager_search::EagerSearch
f_evaluator	search_engines/top_k_eager_search.h	/^    ScalarEvaluator *f_evaluator;$/;"	m	class:top_k_eager_search::TopKEagerSearch
f_start	merge_and_shrink/shrink_fh.h	/^    const HighLow f_start;$/;"	m	class:merge_and_shrink::ShrinkFH
fact	landmarks/exploration.h	/^    FactPair fact;$/;"	m	struct:landmarks::ExProposition
fact	task_proxy.h	/^    FactPair fact;$/;"	m	class:FactProxy
fact_names	tasks/domain_abstracted_task.h	/^    const std::vector<std::vector<std::string>> fact_names;$/;"	m	class:extra_tasks::DomainAbstractedTask
fact_names	tasks/domain_abstracted_task_factory.cc	/^    vector<vector<string>> fact_names;$/;"	m	class:extra_tasks::DomainAbstractedTaskFactory	file:
fact_order	cegar/subtask_generators.h	/^    FactOrder fact_order;$/;"	m	class:cegar::GoalDecomposition
fact_order	cegar/subtask_generators.h	/^    FactOrder fact_order;$/;"	m	class:cegar::LandmarkDecomposition
fact_potentials	potentials/potential_function.h	/^    const std::vector<std::vector<double>> fact_potentials;$/;"	m	class:potentials::PotentialFunction
fact_potentials	potentials/potential_optimizer.h	/^    std::vector<std::vector<double>> fact_potentials;$/;"	m	class:potentials::PotentialOptimizer
facts	landmarks/landmark_graph.h	/^    std::vector<FactPair> facts;$/;"	m	class:landmarks::EdgeType::LandmarkNode
failure_recording_fp_deviation	bliss/graph.h	/^  unsigned int failure_recording_fp_deviation;$/;"	m	class:bliss::AbstractGraph
failure_recording_ival	bliss/graph.cc	/^  unsigned int failure_recording_ival;$/;"	m	class:bliss::TreeNode	file:
fatal_error	bliss/defs.cc	/^fatal_error(const char* fmt, ...)$/;"	f	namespace:bliss
feature	options/doc_store.h	/^    std::string feature;$/;"	m	struct:options::LanguageSupportInfo
feet	ext/tree.hh	/^		tree_node *head, *feet;    \/\/ head\/feet are always dummy; if an iterator points to them it is invalid$/;"	m	class:tree
fetch_next_node	search_engines/eager_search.cc	/^pair<SearchNode, bool> EagerSearch::fetch_next_node() {$/;"	f	class:eager_search::EagerSearch
fetch_next_node	search_engines/top_k_eager_search.cc	/^pair<SearchNode, bool> TopKEagerSearch::fetch_next_node() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
fetch_next_state	search_engines/lazy_search.cc	/^SearchStatus LazySearch::fetch_next_state() {$/;"	f	class:lazy_search::LazySearch
ff_heuristic	heuristics/ff_heuristic.cc	/^namespace ff_heuristic {$/;"	n	file:
ff_heuristic	heuristics/ff_heuristic.h	/^namespace ff_heuristic {$/;"	n
ff_result	landmarks/lama_ff_synergy.h	/^    EvaluationResult ff_result;$/;"	m	class:landmarks::LamaFFSynergy
ff_search_disjunctive_lms	landmarks/landmark_count_heuristic.h	/^    const bool ff_search_disjunctive_lms;$/;"	m	class:landmarks::LandmarkCountHeuristic
ff_slave_heuristic	landmarks/lama_ff_synergy.h	/^    std::unique_ptr<FFSlaveHeuristic> ff_slave_heuristic;$/;"	m	class:landmarks::LamaFFSynergy
filter_and_order_facts	cegar/subtask_generators.cc	/^static Facts filter_and_order_facts($/;"	f	namespace:cegar
filter_dead_ends	potentials/sample_based_potential_heuristics.cc	/^static void filter_dead_ends(PotentialOptimizer &optimizer, vector<State> &samples) {$/;"	f	namespace:potentials
filter_samples_and_compute_functions	potentials/diverse_potential_heuristics.cc	/^DiversePotentialHeuristics::filter_samples_and_compute_functions($/;"	f	class:potentials::DiversePotentialHeuristics
finalize	structural_symmetries/operator_permutation.cc	/^void OperatorPermutation::finalize(){$/;"	f	class:OperatorPermutation
finalize	structural_symmetries/permutation.cc	/^void Permutation::finalize(){$/;"	f	class:Permutation
find_automorphisms	bliss/graph.cc	/^AbstractGraph::find_automorphisms(Stats& stats,$/;"	f	class:bliss::AbstractGraph
find_best_improving_pdb	pdbs/pattern_collection_generator_hillclimbing.cc	/^pair<int, int> PatternCollectionGeneratorHillclimbing::find_best_improving_pdb($/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
find_flaw	cegar/abstraction.cc	/^unique_ptr<Flaw> Abstraction::find_flaw(const Solution &solution) {$/;"	f	class:cegar::Abstraction
find_forward_orders	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::find_forward_orders(const VariablesProxy &variables,$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
find_function_and_remove_covered_samples	potentials/diverse_potential_heuristics.cc	/^DiversePotentialHeuristics::find_function_and_remove_covered_samples($/;"	f	class:potentials::DiversePotentialHeuristics
find_functions	potentials/diverse_potential_heuristics.cc	/^DiversePotentialHeuristics::find_functions() {$/;"	f	class:potentials::DiversePotentialHeuristics
find_next_cell_to_be_splitted	bliss/graph.cc	/^Digraph::find_next_cell_to_be_splitted()$/;"	f	class:bliss::Digraph
find_next_cell_to_be_splitted	bliss/graph.cc	/^Graph::find_next_cell_to_be_splitted()$/;"	f	class:bliss::Graph
find_solution	cegar/abstract_search.cc	/^bool AbstractSearch::find_solution(AbstractState *init, AbstractStates &goals) {$/;"	f	class:cegar::AbstractSearch
find_symmetric_op_no	structural_symmetries/operator_permutation.cc	/^int OperatorPermutation::find_symmetric_op_no(const Permutation& \/*permutation*\/, int op_no) const {$/;"	f	class:OperatorPermutation
find_unsatisfied_condition	pruning/stubborn_sets.h	/^inline FactPair find_unsatisfied_condition($/;"	f	namespace:stubborn_sets
find_unsatisfied_goal	pruning/stubborn_sets.h	/^    FactPair find_unsatisfied_goal(const State &state) const {$/;"	f	class:stubborn_sets::StubbornSets
find_unsatisfied_precondition	pruning/stubborn_sets.h	/^    FactPair find_unsatisfied_precondition(int op_no, const State &state) const {$/;"	f	class:stubborn_sets::StubbornSets
first	bliss/partition.h	/^    unsigned int first;$/;"	m	class:bliss::Partition::Cell
first_achievers	landmarks/landmark_factory_h_m.h	/^    std::list<int> first_achievers;$/;"	m	struct:landmarks::HMEntry
first_achievers	landmarks/landmark_graph.h	/^    std::set<int> first_achievers;$/;"	m	class:landmarks::EdgeType::LandmarkNode
first_cell	bliss/partition.h	/^  Cell* first_cell;$/;"	m	class:bliss::Partition
first_checked	bliss/graph.h	/^    bool first_checked;$/;"	m	class:bliss::AbstractGraph::CR_CEP
first_child	ext/tree.hh	/^	   tree_node_<T> *first_child, *last_child;$/;"	m	class:tree_node_
first_child	options/parse_tree.h	/^typename tree<T>::sibling_iterator first_child($/;"	f	namespace:options
first_child_of_root	options/parse_tree.h	/^typename tree<T>::sibling_iterator first_child_of_root(const tree<T> &tr) {$/;"	f	namespace:options
first_exploration	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::first_exploration(const State &state) {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
first_exploration_incremental	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::first_exploration_incremental($/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
first_nonsingleton_cell	bliss/partition.h	/^  Cell* first_nonsingleton_cell;$/;"	m	class:bliss::Partition
first_path_automorphism	bliss/graph.h	/^  unsigned int *first_path_automorphism;$/;"	m	class:bliss::AbstractGraph
first_path_labeling	bliss/graph.h	/^  unsigned int *first_path_labeling;$/;"	m	class:bliss::AbstractGraph
first_path_labeling_inv	bliss/graph.h	/^  unsigned int *first_path_labeling_inv;$/;"	m	class:bliss::AbstractGraph
first_path_orbits	bliss/graph.h	/^  Orbit         first_path_orbits;$/;"	m	class:bliss::AbstractGraph
first_plan_found	search_engines/kstar.h	/^	bool first_plan_found;$/;"	m	class:kstar::KStar
fixed_depth_iterator	ext/tree.hh	/^		class fixed_depth_iterator : public iterator_base {$/;"	c	class:tree
fixed_depth_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator()$/;"	f	class:tree::fixed_depth_iterator
fixed_depth_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const fixed_depth_iterator& other)$/;"	f	class:tree::fixed_depth_iterator
fixed_depth_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const iterator_base& other)$/;"	f	class:tree::fixed_depth_iterator
fixed_depth_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(const sibling_iterator& other)$/;"	f	class:tree::fixed_depth_iterator
fixed_depth_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::fixed_depth_iterator::fixed_depth_iterator(tree_node *tn)$/;"	f	class:tree::fixed_depth_iterator
flatten	ext/tree.hh	/^iter tree<T, tree_node_allocator>::flatten(iter position)$/;"	f	class:tree
fluents	landmarks/landmark_factory_h_m.h	/^    FluentSet fluents;$/;"	m	struct:landmarks::HMEntry
for_each_heuristic_value	heuristic_cache.h	/^    void for_each_heuristic_value(const Callback &callback) const {$/;"	f	class:HeuristicCache
forbidding_plan	tasks/plan_forbid_reformulated_task.h	/^	const std::vector<int> forbidding_plan;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
format_authors	utils/markup.cc	/^static string format_authors(const vector<string> &authors) {$/;"	f	namespace:utils
format_paper_reference	utils/markup.cc	/^string format_paper_reference($/;"	f	namespace:utils
forward_dijkstra	cegar/abstract_search.cc	/^void AbstractSearch::forward_dijkstra(AbstractState *init) {$/;"	f	class:cegar::AbstractSearch
forward_orders	landmarks/landmark_graph.h	/^    std::unordered_set<FactPair> forward_orders;$/;"	m	class:landmarks::EdgeType::LandmarkNode
found_disj_lm_and_order	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::found_disj_lm_and_order($/;"	f	class:landmarks::LandmarkFactoryRpgSasp
found_simple_lm_and_order	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::found_simple_lm_and_order(const FactPair &a,$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
found_solution	search_engine.cc	/^bool SearchEngine::found_solution() const {$/;"	f	class:SearchEngine
fp_cert_equal	bliss/graph.cc	/^  bool fp_cert_equal;$/;"	m	class:bliss::TreeNode	file:
fp_extendable	bliss/graph.cc	/^  char fp_extendable;$/;"	m	class:bliss::TreeNode	file:
fp_on	bliss/graph.cc	/^  bool fp_on;$/;"	m	class:bliss::TreeNode	file:
free_cells	bliss/partition.h	/^  Cell* free_cells;$/;"	m	class:bliss::Partition
free_unneeded_memory	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::free_unneeded_memory() {$/;"	f	class:landmarks::LandmarkFactoryHM
frequency	utils/timer.h	/^    LARGE_INTEGER frequency;$/;"	m	class:utils::Timer
from	search_engines/top_k_eager_search.h	/^	StateID from = StateID::no_state;	$/;"	m	struct:top_k_eager_search::StateActionPair
from_annotated_elements	algorithms/equivalence_relation.h	/^EquivalenceRelation *EquivalenceRelation::from_annotated_elements(int n,$/;"	f	class:equivalence_relation::EquivalenceRelation
from_vars	structural_symmetries/permutation.h	/^    std::vector<int> from_vars;$/;"	m	class:Permutation
front	bliss/kqueue.h	/^Type KQueue<Type>::front() const$/;"	f	class:bliss::KQueue
fts	merge_and_shrink/factored_transition_system.h	/^    const FactoredTransitionSystem &fts;$/;"	m	class:merge_and_shrink::FTSConstIterator
fts	merge_and_shrink/merge_strategy.h	/^    FactoredTransitionSystem &fts;$/;"	m	class:merge_and_shrink::MergeStrategy
full_name	options/doc_store.h	/^    std::string full_name;$/;"	m	struct:options::DocStruct
function	potentials/potential_heuristic.h	/^    std::unique_ptr<PotentialFunction> function;$/;"	m	class:potentials::PotentialHeuristic
functions	potentials/potential_max_heuristic.h	/^    std::vector<std::unique_ptr<PotentialFunction>> functions;$/;"	m	class:potentials::PotentialMaxHeuristic
g	cegar/abstract_state.h	/^    int g;$/;"	m	class:cegar::AbstractSearchInfo
g	search_node_info.h	/^    int g : 30;$/;"	m	struct:SearchNodeInfo
g_axiom_evaluator	globals.cc	/^AxiomEvaluator *g_axiom_evaluator;$/;"	v
g_axiom_layers	globals.cc	/^vector<int> g_axiom_layers;$/;"	v
g_axioms	globals.cc	/^vector<GlobalOperator> g_axioms;$/;"	v
g_default_axiom_values	globals.cc	/^vector<int> g_default_axiom_values;$/;"	v
g_evaluator	evaluators/g_evaluator.cc	/^namespace g_evaluator {$/;"	n	file:
g_evaluator	evaluators/g_evaluator.h	/^namespace g_evaluator {$/;"	n
g_fact_names	globals.cc	/^vector<vector<string>> g_fact_names;$/;"	v
g_goal	globals.cc	/^vector<pair<int, int>> g_goal;$/;"	v
g_improving_symmetrical_states	globals.cc	/^int g_improving_symmetrical_states;$/;"	v
g_inconsistent_facts	globals.cc	/^static vector<vector<set<FactPair>>> g_inconsistent_facts;$/;"	v	file:
g_initial_state_data	globals.cc	/^vector<int> g_initial_state_data;$/;"	v
g_invariant_groups	globals.cc	/^vector<vector<FactPair>> g_invariant_groups;$/;"	v
g_is_part_of_anytime_portfolio	globals.cc	/^bool g_is_part_of_anytime_portfolio = false;$/;"	v
g_log	globals.cc	/^utils::Log g_log;$/;"	v
g_max_action_cost	globals.cc	/^int g_max_action_cost = 0;$/;"	v
g_min_action_cost	globals.cc	/^int g_min_action_cost = numeric_limits<int>::max();$/;"	v
g_num_previously_generated_plans	globals.cc	/^int g_num_previously_generated_plans = 0;$/;"	v
g_operators	globals.cc	/^vector<GlobalOperator> g_operators;$/;"	v
g_plan_filename	globals.cc	/^string g_plan_filename = "sas_plan";$/;"	v
g_root_task	globals.cc	/^const shared_ptr<AbstractTask> g_root_task() {$/;"	f
g_state_packer	globals.cc	/^int_packer::IntPacker *g_state_packer;$/;"	v
g_successor_generator	globals.cc	/^SuccessorGenerator *g_successor_generator;$/;"	v
g_symmetrical_states_generated	globals.cc	/^int g_symmetrical_states_generated;$/;"	v
g_symmetry_improved_evaluations	globals.cc	/^int g_symmetry_improved_evaluations;$/;"	v
g_timer	utils/timer.cc	/^Timer g_timer;$/;"	m	namespace:utils	file:
g_use_metric	globals.cc	/^bool g_use_metric;$/;"	v
g_value	evaluation_context.h	/^    int g_value;$/;"	m	class:EvaluationContext
g_variable_domain	globals.cc	/^vector<int> g_variable_domain;$/;"	v
g_variable_name	globals.cc	/^vector<string> g_variable_name;$/;"	v
gcd	structural_symmetries/permutation.cc	/^int gcd(int m, int n) {$/;"	f
generate	landmarks/landmark_factory.cc	/^void LandmarkFactory::generate(const TaskProxy &task_proxy, Exploration &exploration) {$/;"	f	class:landmarks::LandmarkFactory
generate	pdbs/pattern_collection_generator_combo.cc	/^PatternCollectionInformation PatternCollectionGeneratorCombo::generate($/;"	f	class:pdbs::PatternCollectionGeneratorCombo
generate	pdbs/pattern_collection_generator_genetic.cc	/^PatternCollectionInformation PatternCollectionGeneratorGenetic::generate($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
generate	pdbs/pattern_collection_generator_hillclimbing.cc	/^PatternCollectionInformation PatternCollectionGeneratorHillclimbing::generate($/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
generate	pdbs/pattern_collection_generator_manual.cc	/^PatternCollectionInformation PatternCollectionGeneratorManual::generate($/;"	f	class:pdbs::PatternCollectionGeneratorManual
generate	pdbs/pattern_collection_generator_systematic.cc	/^PatternCollectionInformation PatternCollectionGeneratorSystematic::generate($/;"	f	class:pdbs::PatternCollectionGeneratorSystematic
generate	pdbs/pattern_generator_greedy.cc	/^Pattern PatternGeneratorGreedy::generate(const shared_ptr<AbstractTask> &task) {$/;"	f	class:pdbs::PatternGeneratorGreedy
generate	pdbs/pattern_generator_manual.cc	/^Pattern PatternGeneratorManual::generate(const shared_ptr<AbstractTask> &task) {$/;"	f	class:pdbs::PatternGeneratorManual
generate_all_partial_tuples	heuristics/hm_heuristic.cc	/^void HMHeuristic::generate_all_partial_tuples($/;"	f	class:hm_heuristic::HMHeuristic
generate_all_partial_tuples_aux	heuristics/hm_heuristic.cc	/^void HMHeuristic::generate_all_partial_tuples_aux($/;"	f	class:hm_heuristic::HMHeuristic
generate_all_tuples	heuristics/hm_heuristic.cc	/^void HMHeuristic::generate_all_tuples() {$/;"	f	class:hm_heuristic::HMHeuristic
generate_all_tuples_aux	heuristics/hm_heuristic.cc	/^void HMHeuristic::generate_all_tuples_aux(int var, int sz, const Tuple &base) {$/;"	f	class:hm_heuristic::HMHeuristic
generate_applicable_ops	successor_generator.cc	/^void GeneratorEmpty::generate_applicable_ops($/;"	f	class:GeneratorEmpty
generate_applicable_ops	successor_generator.cc	/^void GeneratorLeaf::generate_applicable_ops($/;"	f	class:GeneratorLeaf
generate_applicable_ops	successor_generator.cc	/^void GeneratorSwitch::generate_applicable_ops($/;"	f	class:GeneratorSwitch
generate_applicable_ops	successor_generator.cc	/^void SuccessorGenerator::generate_applicable_ops($/;"	f	class:SuccessorGenerator
generate_candidate_pdbs	pdbs/pattern_collection_generator_hillclimbing.cc	/^int PatternCollectionGeneratorHillclimbing::generate_candidate_pdbs($/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
generate_helpful_actions	landmarks/landmark_count_heuristic.cc	/^bool LandmarkCountHeuristic::generate_helpful_actions(const State &state,$/;"	f	class:landmarks::LandmarkCountHeuristic
generate_heuristic_functions	cegar/additive_cartesian_heuristic.cc	/^static vector<CartesianHeuristicFunction> generate_heuristic_functions($/;"	f	namespace:cegar
generate_heuristic_functions	cegar/cost_saturation.cc	/^vector<CartesianHeuristicFunction> CostSaturation::generate_heuristic_functions($/;"	f	class:cegar::CostSaturation
generate_landmarks	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::generate_landmarks($/;"	f	class:landmarks::LandmarkFactoryHM
generate_landmarks	landmarks/landmark_factory_merged.cc	/^void LandmarkFactoryMerged::generate_landmarks($/;"	f	class:landmarks::LandmarkFactoryMerged
generate_landmarks	landmarks/landmark_factory_rpg_exhaust.cc	/^void LandmarkFactoryRpgExhaust::generate_landmarks($/;"	f	class:landmarks::LandmarkFactoryRpgExhaust
generate_landmarks	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::generate_landmarks($/;"	f	class:landmarks::LandmarkFactoryRpgSasp
generate_landmarks	landmarks/landmark_factory_zhu_givan.cc	/^void LandmarkFactoryZhuGivan::generate_landmarks($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
generate_operators_lookups	landmarks/landmark_graph.cc	/^void LandmarkGraph::generate_operators_lookups(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkGraph
generate_parse_tree	options/option_parser.cc	/^static ParseTree generate_parse_tree(string config) {$/;"	f	namespace:options
generate_successors	search_engines/lazy_search.cc	/^void LazySearch::generate_successors() {$/;"	f	class:lazy_search::LazySearch
generated_ops	search_statistics.h	/^    int generated_ops;    \/\/ no of operators that were returned as applicable$/;"	m	class:SearchStatistics
generated_states	search_statistics.h	/^    int generated_states; \/\/ no states created in total (plus those removed since already in close list)$/;"	m	class:SearchStatistics
generator_for_value	successor_generator.cc	/^    vector<GeneratorBase *> generator_for_value;$/;"	m	class:GeneratorSwitch	file:
generators	structural_symmetries/group.h	/^    std::vector<const Permutation *> generators;$/;"	m	class:Group
genetic_algorithm	pdbs/pattern_collection_generator_genetic.cc	/^void PatternCollectionGeneratorGenetic::genetic_algorithm($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
get	algorithms/int_packer.cc	/^    int get(const Bin *buffer) const {$/;"	f	class:int_packer::IntPacker::VariableInfo
get	algorithms/int_packer.cc	/^int IntPacker::get(const Bin *buffer, int var) const {$/;"	f	class:int_packer::IntPacker
get	options/doc_store.cc	/^DocStruct DocStore::get(string k) {$/;"	f	class:options::DocStore
get	options/options.h	/^    T get(std::string key) const {$/;"	f	class:options::Options
get	options/options.h	/^    T get(std::string key, const T &default_value) const {$/;"	f	class:options::Options
get	options/predefinitions.h	/^    T get(const std::string &k) {$/;"	f	class:options::Predefinitions
get	options/registries.cc	/^const PluginTypeInfo &PluginTypeRegistry::get(const type_index &type) const {$/;"	f	class:options::PluginTypeRegistry
get	options/registries.h	/^    Factory get(const std::string &k) {$/;"	f	class:options::Registry
get_abstract_fact	tasks/domain_abstracted_task.h	/^    FactPair get_abstract_fact(const FactPair &fact) const {$/;"	f	class:extra_tasks::DomainAbstractedTask
get_abstract_state	cegar/abstract_state.cc	/^AbstractState AbstractState::get_abstract_state($/;"	f	class:cegar::AbstractState
get_abstract_value	tasks/domain_abstracted_task.h	/^    int get_abstract_value(const FactPair &fact) const {$/;"	f	class:extra_tasks::DomainAbstractedTask
get_achievers	landmarks/landmark_cost_assignment.cc	/^const set<int> &LandmarkCostAssignment::get_achievers($/;"	f	class:landmarks::LandmarkCostAssignment
get_adjusted_action_cost	operator_cost.cc	/^int get_adjusted_action_cost(const GlobalOperator &op, OperatorCost cost_type) {$/;"	f
get_adjusted_action_cost	operator_cost.cc	/^int get_adjusted_action_cost(int cost, OperatorCost cost_type) {$/;"	f
get_adjusted_cost	search_engine.cc	/^int SearchEngine::get_adjusted_cost(const GlobalOperator &op) const {$/;"	f	class:SearchEngine
get_admissible_potentials_reference	potentials/util.cc	/^string get_admissible_potentials_reference() {$/;"	f	namespace:potentials
get_affected_operators_no	structural_symmetries/operator_permutation.h	/^    const std::vector<int>& get_affected_operators_no() const { return ops_affected; }$/;"	f	class:OperatorPermutation
get_affected_vars	structural_symmetries/permutation.h	/^    const std::vector<int>& get_affected_vars() const { return vars_affected; }$/;"	f	class:Permutation
get_applicable_operators	pdbs/match_tree.cc	/^void MatchTree::get_applicable_operators($/;"	f	class:pdbs::MatchTree
get_applicable_operators_recursive	pdbs/match_tree.cc	/^void MatchTree::get_applicable_operators_recursive($/;"	f	class:pdbs::MatchTree
get_as_vector	algorithms/ordered_set.h	/^    const std::vector<T> &get_as_vector() const {$/;"	f	class:ordered_set::OrderedSet
get_average_operator_cost	task_tools.cc	/^double get_average_operator_cost(TaskProxy task_proxy) {$/;"	f
get_axiom_layer	task_proxy.h	/^    int get_axiom_layer() const {$/;"	f	class:VariableProxy
get_axioms	task_proxy.h	/^    AxiomsProxy get_axioms() const {$/;"	f	class:TaskProxy
get_bins_per_state	state_registry.cc	/^int StateRegistry::get_bins_per_state() const {$/;"	f	class:StateRegistry
get_bit_mask	algorithms/int_packer.cc	/^static IntPacker::Bin get_bit_mask(int from, int to) {$/;"	f	namespace:int_packer
get_bit_size_for_range	algorithms/int_packer.cc	/^static int get_bit_size_for_range(int range) {$/;"	f	namespace:int_packer
get_bound	search_engine.h	/^    int get_bound() {return bound; }$/;"	f	class:SearchEngine
get_cache	evaluation_context.cc	/^const HeuristicCache &EvaluationContext::get_cache() const {$/;"	f	class:EvaluationContext
get_calculate_preferred	evaluation_context.cc	/^bool EvaluationContext::get_calculate_preferred() const {$/;"	f	class:EvaluationContext
get_canonical_pdbs_from_options	pdbs/canonical_pdbs_heuristic.cc	/^CanonicalPDBs get_canonical_pdbs_from_options($/;"	f	namespace:pdbs
get_canonical_representative	structural_symmetries/group.cc	/^int *Group::get_canonical_representative(const GlobalState &state) const {$/;"	f	class:Group
get_causal_graph	causal_graph.cc	/^const CausalGraph &get_causal_graph(const AbstractTask *task) {$/;"	f
get_causal_graph	task_proxy.cc	/^const CausalGraph &TaskProxy::get_causal_graph() const {$/;"	f	class:TaskProxy
get_cell	bliss/partition.h	/^  Cell* get_cell(const unsigned int e) const {$/;"	f	class:bliss::Partition
get_child	cegar/refinement_hierarchy.cc	/^Node *Node::get_child(int value) const {$/;"	f	class:cegar::Node
get_coefficients	lp/lp_solver.h	/^    const std::vector<double> &get_coefficients() const {return coefficients; }$/;"	f	class:lp::LPConstraint
get_combined_fact_name	tasks/domain_abstracted_task_factory.cc	/^string DomainAbstractedTaskFactory::get_combined_fact_name($/;"	f	class:extra_tasks::DomainAbstractedTaskFactory
get_conditions	task_proxy.h	/^    EffectConditionsProxy get_conditions() const {$/;"	f	class:EffectProxy
get_conflicting_vars	pruning/stubborn_sets_ec.cc	/^void get_conflicting_vars(const vector<FactPair> &facts1,$/;"	f	namespace:stubborn_sets_ec
get_cost	cegar/subtask_generators.cc	/^    int get_cost(const FactPair &fact) {$/;"	f	class:cegar::SortFactsByIncreasingHaddValues	file:
get_cost	global_operator.h	/^    int get_cost() const {return cost; }$/;"	f	class:GlobalOperator
get_cost	merge_and_shrink/label_equivalence_relation.h	/^    int get_cost() const {$/;"	f	class:merge_and_shrink::LabelGroup
get_cost	merge_and_shrink/labels.h	/^    int get_cost() const {$/;"	f	class:merge_and_shrink::Label
get_cost	pdbs/pattern_database.h	/^    int get_cost() const {return cost; }$/;"	f	class:pdbs::AbstractOperator
get_cost	task_proxy.h	/^    int get_cost() const {$/;"	f	class:OperatorProxy
get_cost_for_cegar	heuristics/additive_heuristic.h	/^    int get_cost_for_cegar(int var, int value) const {$/;"	f	class:additive_heuristic::AdditiveHeuristic
get_count_evaluation	evaluation_result.cc	/^bool EvaluationResult::get_count_evaluation() const {$/;"	f	class:EvaluationResult
get_default_axiom_value	task_proxy.h	/^    int get_default_axiom_value() const {$/;"	f	class:VariableProxy
get_description	heuristic.cc	/^string Heuristic::get_description() const {$/;"	f	class:Heuristic
get_description	merge_and_shrink/transition_system.cc	/^string TransitionSystem::get_description() const {$/;"	f	class:merge_and_shrink::TransitionSystem
get_disabled_vars	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::get_disabled_vars($/;"	f	class:stubborn_sets_ec::StubbornSetsEC
get_disj_lm_node	landmarks/landmark_graph.h	/^    inline LandmarkNode &get_disj_lm_node(const FactPair &a) const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
get_dist	merge_and_shrink/factored_transition_system.h	/^    const Distances &get_dist(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
get_documentation	options/registries.h	/^    const std::string &get_documentation() const {$/;"	f	class:options::PluginTypeInfo
get_domain_size	merge_and_shrink/merge_and_shrink_representation.cc	/^int MergeAndShrinkRepresentation::get_domain_size() const {$/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentation
get_domain_size	task_proxy.h	/^    int get_domain_size() const {$/;"	f	class:VariableProxy
get_domain_sizes	cegar/utils.cc	/^vector<int> get_domain_sizes(const TaskProxy &task) {$/;"	f	namespace:cegar
get_duration	bliss/timer.cc	/^double Timer::get_duration()$/;"	f	class:bliss::Timer
get_eff_to_eff	causal_graph.h	/^    const std::vector<int> &get_eff_to_eff(int var) const {$/;"	f	class:CausalGraph
get_eff_to_pre	causal_graph.h	/^    const std::vector<int> &get_eff_to_pre(int var) const {$/;"	f	class:CausalGraph
get_effects	global_operator.h	/^    const std::vector<GlobalEffect> &get_effects() const {return effects; }$/;"	f	class:GlobalOperator
get_effects	task_proxy.h	/^    EffectsProxy get_effects() const {$/;"	f	class:OperatorProxy
get_elapsed_time	utils/countdown_timer.cc	/^double CountdownTimer::get_elapsed_time() const {$/;"	f	class:utils::CountdownTimer
get_entries	per_state_information.h	/^    const segmented_vector::SegmentedVector<Entry> *get_entries(const StateRegistry *registry) const {$/;"	f	class:PerStateInformation
get_entries	per_state_information.h	/^    segmented_vector::SegmentedVector<Entry> *get_entries(const StateRegistry *registry) {$/;"	f	class:PerStateInformation
get_enum	options/options.h	/^    int get_enum(std::string key) const {$/;"	f	class:options::Options
get_evaluated_states	search_statistics.h	/^    int get_evaluated_states() const {return evaluated_states; }$/;"	f	class:SearchStatistics
get_evaluations	search_statistics.h	/^    int get_evaluations() const {return evaluations; }$/;"	f	class:SearchStatistics
get_exit_code_message_reentrant	utils/system.cc	/^const char *get_exit_code_message_reentrant(ExitCode exitcode) {$/;"	f	namespace:utils
get_expanded	search_statistics.h	/^    int get_expanded() const {return expanded_states; }$/;"	f	class:SearchStatistics
get_exploration_options	landmarks/landmark_count_heuristic.cc	/^static Options get_exploration_options($/;"	f	namespace:landmarks
get_f_value	search_engines/kstar.cc	/^int KStar::get_f_value(StateID id) {$/;"	f	class:kstar::KStar
get_fact	cegar/utils_landmarks.cc	/^static FactPair get_fact(const LandmarkNode &node) {$/;"	f	namespace:cegar
get_fact	task_proxy.h	/^    FactProxy get_fact() const {$/;"	f	class:EffectProxy
get_fact	task_proxy.h	/^    FactProxy get_fact(int index) const {$/;"	f	class:VariableProxy
get_fact_landmarks	cegar/utils_landmarks.cc	/^vector<FactPair> get_fact_landmarks(const LandmarkGraph &graph) {$/;"	f	namespace:cegar
get_fact_name	tasks/delegating_task.cc	/^string DelegatingTask::get_fact_name(const FactPair &fact) const {$/;"	f	class:tasks::DelegatingTask
get_fact_name	tasks/domain_abstracted_task.cc	/^string DomainAbstractedTask::get_fact_name(const FactPair &fact) const {$/;"	f	class:extra_tasks::DomainAbstractedTask
get_fact_name	tasks/plan_forbid_reformulated_task.cc	/^string PlanForbidReformulatedTask::get_fact_name(const FactPair &fact) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_fact_name	tasks/root_task.cc	/^string RootTask::get_fact_name(const FactPair &fact) const {$/;"	f	class:tasks::RootTask
get_fact_pairs	task_tools.h	/^std::vector<FactPair> get_fact_pairs(const FactProxyCollection &facts) {$/;"	f
get_facts	task_proxy.h	/^    FactsProxy get_facts() const {$/;"	f	class:VariablesProxy
get_ff_heuristic_proxy	landmarks/lama_ff_synergy.cc	/^Heuristic *LamaFFSynergy::get_ff_heuristic_proxy() const {$/;"	f	class:landmarks::LamaFFSynergy
get_final_entry	merge_and_shrink/factored_transition_system.cc	/^FactoredTransitionSystem::get_final_entry() {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
get_first_conditional_effects_op_id	globals.cc	/^static int get_first_conditional_effects_op_id() {$/;"	f	file:
get_first_conditional_effects_op_id	task_tools.cc	/^static int get_first_conditional_effects_op_id(TaskProxy task) {$/;"	f	file:
get_following_var_index	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_following_var_index(int op_index) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_full_help	options/option_parser.cc	/^static void get_full_help() {$/;"	f	namespace:options
get_full_help_templ	options/option_parser.cc	/^static void get_full_help_templ() {$/;"	f	namespace:options
get_g	search_space.cc	/^int SearchNode::get_g() const {$/;"	f	class:SearchNode
get_g_value	cegar/abstract_state.h	/^    int get_g_value() const {$/;"	f	class:cegar::AbstractSearchInfo
get_g_value	evaluation_context.cc	/^int EvaluationContext::get_g_value() const {$/;"	f	class:EvaluationContext
get_generated	search_statistics.h	/^    int get_generated() const {return generated_states; }$/;"	f	class:SearchStatistics
get_generated_ops	search_statistics.h	/^    int get_generated_ops() const {return generated_ops; }$/;"	f	class:SearchStatistics
get_global_operator	task_proxy.h	/^    const GlobalOperator *get_global_operator() const {$/;"	f	class:OperatorProxy
get_global_operator	tasks/delegating_task.cc	/^const GlobalOperator *DelegatingTask::get_global_operator(int index, bool is_axiom) const {$/;"	f	class:tasks::DelegatingTask
get_global_operator	tasks/plan_forbid_reformulated_task.cc	/^const GlobalOperator *PlanForbidReformulatedTask::get_global_operator(int , bool ) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_global_operator	tasks/root_task.cc	/^const GlobalOperator *RootTask::get_global_operator(int index, bool is_axiom) const {$/;"	f	class:tasks::RootTask
get_goal_distance	merge_and_shrink/distances.h	/^    int get_goal_distance(int state) const { \/\/ used by shrink strategies and DFP$/;"	f	class:merge_and_shrink::Distances
get_goal_fact	tasks/delegating_task.cc	/^FactPair DelegatingTask::get_goal_fact(int index) const {$/;"	f	class:tasks::DelegatingTask
get_goal_fact	tasks/domain_abstracted_task.cc	/^FactPair DomainAbstractedTask::get_goal_fact(int index) const {$/;"	f	class:extra_tasks::DomainAbstractedTask
get_goal_fact	tasks/modified_goals_task.cc	/^FactPair ModifiedGoalsTask::get_goal_fact(int index) const {$/;"	f	class:extra_tasks::ModifiedGoalsTask
get_goal_fact	tasks/plan_forbid_reformulated_task.cc	/^FactPair PlanForbidReformulatedTask::get_goal_fact(int index) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_goal_fact	tasks/root_task.cc	/^FactPair RootTask::get_goal_fact(int index) const {$/;"	f	class:tasks::RootTask
get_goals	task_proxy.h	/^    GoalsProxy get_goals() const {$/;"	f	class:TaskProxy
get_greedy_preconditions_for_lm	landmarks/landmark_factory_rpg_sasp.cc	/^void LandmarkFactoryRpgSasp::get_greedy_preconditions_for_lm($/;"	f	class:landmarks::LandmarkFactoryRpgSasp
get_group	merge_and_shrink/label_equivalence_relation.h	/^    const LabelGroup &get_group(int group_id) const {$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
get_group_id	merge_and_shrink/label_equivalence_relation.h	/^    int get_group_id(int label_no) const {$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
get_group_size_approx	bliss/graph.h	/^  long double get_group_size_approx() const {return group_size_approx;}$/;"	f	class:bliss::Stats
get_h_value	cegar/abstract_state.cc	/^int AbstractState::get_h_value() const {$/;"	f	class:cegar::AbstractState
get_h_value	cegar/refinement_hierarchy.h	/^    int get_h_value() const {$/;"	f	class:cegar::Node
get_h_value	evaluation_result.cc	/^int EvaluationResult::get_h_value() const {$/;"	f	class:EvaluationResult
get_h_value_of_initial_state	cegar/abstraction.cc	/^int Abstraction::get_h_value_of_initial_state() const {$/;"	f	class:cegar::Abstraction
get_hadd_value	cegar/split_selector.cc	/^int SplitSelector::get_hadd_value(int var_id, int value) const {$/;"	f	class:cegar::SplitSelector
get_hash	bliss/graph.cc	/^Digraph::get_hash()$/;"	f	class:bliss::Digraph
get_hash	bliss/graph.cc	/^Graph::get_hash()$/;"	f	class:bliss::Graph
get_hash_effect	pdbs/pattern_database.h	/^    std::size_t get_hash_effect() const {return hash_effect; }$/;"	f	class:pdbs::AbstractOperator
get_help	options/option_parser.cc	/^static void get_help(string k) {$/;"	f	namespace:options
get_help_templ	options/option_parser.cc	/^static void get_help_templ(const ParseTree &pt) {$/;"	f	namespace:options
get_heuristic_value	evaluation_context.cc	/^int EvaluationContext::get_heuristic_value(ScalarEvaluator *heur) {$/;"	f	class:EvaluationContext
get_heuristic_value	landmarks/landmark_count_heuristic.cc	/^int LandmarkCountHeuristic::get_heuristic_value(const GlobalState &global_state) {$/;"	f	class:landmarks::LandmarkCountHeuristic
get_heuristic_value_or_infinity	evaluation_context.cc	/^int EvaluationContext::get_heuristic_value_or_infinity(ScalarEvaluator *heur) {$/;"	f	class:EvaluationContext
get_id	global_state.h	/^    StateID get_id() const {$/;"	f	class:GlobalState
get_id	landmarks/landmark_graph.h	/^    int get_id() const {$/;"	f	class:landmarks::EdgeType::LandmarkNode
get_id	task_proxy.h	/^    int get_id() const {$/;"	f	class:OperatorProxy
get_id	task_proxy.h	/^    int get_id() const {$/;"	f	class:VariableProxy
get_incoming_transition	cegar/abstract_state.h	/^    const Transition &get_incoming_transition() const {$/;"	f	class:cegar::AbstractSearchInfo
get_incoming_transitions	cegar/abstract_state.h	/^    const Transitions &get_incoming_transitions() const {$/;"	f	class:cegar::AbstractState
get_incorporated_variables	merge_and_shrink/transition_system.h	/^    const std::vector<int> &get_incorporated_variables() const {$/;"	f	class:merge_and_shrink::TransitionSystem
get_index	global_operator.h	/^	int get_index() const {return index; }$/;"	f	class:GlobalOperator
get_index	heuristics/cg_cache.cc	/^int CGCache::get_index(int var, const State &state,$/;"	f	class:cg_heuristic::CGCache
get_index_by_var_val_pair	structural_symmetries/permutation.cc	/^int Permutation::get_index_by_var_val_pair(int var, int val) {$/;"	f	class:Permutation
get_infinity	lp/lp_solver.cc	/^double LPSolver::get_infinity() const {$/;"	f	class:lp::LPSolver
get_init_distance	merge_and_shrink/distances.h	/^    int get_init_distance(int state) const { \/\/ used by shrink_fh$/;"	f	class:merge_and_shrink::Distances
get_init_state	merge_and_shrink/transition_system.h	/^    int get_init_state() const {$/;"	f	class:merge_and_shrink::TransitionSystem
get_initial_state	state_registry.cc	/^const GlobalState &StateRegistry::get_initial_state() {$/;"	f	class:StateRegistry
get_initial_state	task_proxy.h	/^    State get_initial_state() const {$/;"	f	class:TaskProxy
get_initial_state_values	tasks/delegating_task.cc	/^vector<int> DelegatingTask::get_initial_state_values() const {$/;"	f	class:tasks::DelegatingTask
get_initial_state_values	tasks/domain_abstracted_task.cc	/^vector<int> DomainAbstractedTask::get_initial_state_values() const {$/;"	f	class:extra_tasks::DomainAbstractedTask
get_initial_state_values	tasks/plan_forbid_reformulated_task.cc	/^vector<int> PlanForbidReformulatedTask::get_initial_state_values() const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_initial_state_values	tasks/root_task.cc	/^vector<int> RootTask::get_initial_state_values() const {$/;"	f	class:tasks::RootTask
get_involved_heuristics	evaluators/combining_evaluator.cc	/^void CombiningEvaluator::get_involved_heuristics(set<Heuristic *> &hset) {$/;"	f	class:combining_evaluator::CombiningEvaluator
get_involved_heuristics	evaluators/weighted_evaluator.cc	/^void WeightedEvaluator::get_involved_heuristics(set<Heuristic *> &hset) {$/;"	f	class:weighted_evaluator::WeightedEvaluator
get_involved_heuristics	open_lists/alternation_open_list.cc	/^void AlternationOpenList<Entry>::get_involved_heuristics($/;"	f	class:AlternationOpenList
get_involved_heuristics	open_lists/epsilon_greedy_open_list.cc	/^void EpsilonGreedyOpenList<Entry>::get_involved_heuristics(set<Heuristic *> &hset) {$/;"	f	class:EpsilonGreedyOpenList
get_involved_heuristics	open_lists/pareto_open_list.cc	/^void ParetoOpenList<Entry>::get_involved_heuristics(set<Heuristic *> &hset) {$/;"	f	class:ParetoOpenList
get_involved_heuristics	open_lists/standard_scalar_open_list.cc	/^void StandardScalarOpenList<Entry>::get_involved_heuristics($/;"	f	class:StandardScalarOpenList
get_involved_heuristics	open_lists/tiebreaking_open_list.cc	/^void TieBreakingOpenList<Entry>::get_involved_heuristics($/;"	f	class:TieBreakingOpenList
get_involved_heuristics	open_lists/type_based_open_list.cc	/^void TypeBasedOpenList<Entry>::get_involved_heuristics($/;"	f	class:TypeBasedOpenList
get_keys	options/doc_store.cc	/^vector<string> DocStore::get_keys() {$/;"	f	class:options::DocStore
get_keys	options/registries.h	/^    std::vector<std::string> get_keys() {$/;"	f	class:options::Registry
get_label_cost	merge_and_shrink/labels.cc	/^int Labels::get_label_cost(int label_no) const {$/;"	f	class:merge_and_shrink::Labels
get_labels	merge_and_shrink/factored_transition_system.h	/^    const Labels &get_labels() const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
get_lama_heuristic_proxy	landmarks/lama_ff_synergy.cc	/^Heuristic *LamaFFSynergy::get_lama_heuristic_proxy() const {$/;"	f	class:landmarks::LamaFFSynergy
get_landmark	landmarks/landmark_graph.cc	/^LandmarkNode *LandmarkGraph::get_landmark(const FactPair &fact) const {$/;"	f	class:landmarks::LandmarkGraph
get_landmark_graph	cegar/utils_landmarks.cc	/^shared_ptr<LandmarkGraph> get_landmark_graph(const shared_ptr<AbstractTask> &task) {$/;"	f	namespace:cegar
get_left_most_sibling	merge_and_shrink/merge_tree.cc	/^MergeTreeNode *MergeTreeNode::get_left_most_sibling() {$/;"	f	class:merge_and_shrink::MergeTreeNode
get_list	options/options.h	/^    std::vector<T> get_list(std::string key) const {$/;"	f	class:options::Options
get_lm_for_index	landmarks/landmark_graph.cc	/^LandmarkNode *LandmarkGraph::get_lm_for_index(int i) const {$/;"	f	class:landmarks::LandmarkGraph
get_local_problem	heuristics/cea_heuristic.cc	/^LocalProblem *ContextEnhancedAdditiveHeuristic::get_local_problem($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
get_loops	cegar/abstract_state.h	/^    const Loops &get_loops() const {$/;"	f	class:cegar::AbstractState
get_lower_bound	lp/lp_solver.h	/^    double get_lower_bound() const {return lower_bound; }$/;"	f	class:lp::LPConstraint
get_lp_var_id	potentials/potential_optimizer.cc	/^int PotentialOptimizer::get_lp_var_id(const FactProxy &fact) const {$/;"	f	class:potentials::PotentialOptimizer
get_m_sets	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::get_m_sets(const VariablesProxy &variables, int m, vector<FluentSet> &subsets) {$/;"	f	class:landmarks::LandmarkFactoryHM
get_m_sets	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::get_m_sets(const VariablesProxy &variables, int m,$/;"	f	class:landmarks::LandmarkFactoryHM
get_m_sets	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::get_m_sets(const VariablesProxy &variables,$/;"	f	class:landmarks::LandmarkFactoryHM
get_m_sets_	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::get_m_sets_(const VariablesProxy &variables, int m, int num_included, int current_var,$/;"	f	class:landmarks::LandmarkFactoryHM
get_m_sets_of_set	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::get_m_sets_of_set(const VariablesProxy &variables,$/;"	f	class:landmarks::LandmarkFactoryHM
get_matching_landmark	landmarks/landmark_factory_merged.cc	/^LandmarkNode *LandmarkFactoryMerged::get_matching_landmark(const LandmarkNode &lm) const {$/;"	f	class:landmarks::LandmarkFactoryMerged
get_max_additive_subsets	pdbs/incremental_canonical_pdbs.cc	/^MaxAdditivePDBSubsets IncrementalCanonicalPDBs::get_max_additive_subsets($/;"	f	class:pdbs::IncrementalCanonicalPDBs
get_max_additive_subsets	pdbs/pattern_collection_information.cc	/^shared_ptr<MaxAdditivePDBSubsets> PatternCollectionInformation::get_max_additive_subsets() {$/;"	f	class:pdbs::PatternCollectionInformation
get_max_f	merge_and_shrink/distances.h	/^    int get_max_f() const { \/\/ used by shrink_fh$/;"	f	class:merge_and_shrink::Distances
get_max_g	merge_and_shrink/distances.h	/^    int get_max_g() const { \/\/ unused$/;"	f	class:merge_and_shrink::Distances
get_max_h	merge_and_shrink/distances.h	/^    int get_max_h() const { \/\/ used by shrink strategies$/;"	f	class:merge_and_shrink::Distances
get_max_hadd_value	cegar/split_selector.cc	/^int SplitSelector::get_max_hadd_value(int var_id, const vector<int> &values) const {$/;"	f	class:cegar::SplitSelector
get_max_level	bliss/graph.h	/^  unsigned long int get_max_level() const {return max_level;}$/;"	f	class:bliss::Stats
get_max_size	merge_and_shrink/labels.h	/^    int get_max_size() const {$/;"	f	class:merge_and_shrink::Labels
get_maximizing_vertex	algorithms/max_cliques.cc	/^    int get_maximizing_vertex($/;"	f	class:max_cliques::MaxCliqueComputer	file:
get_min_hadd_value	cegar/split_selector.cc	/^int SplitSelector::get_min_hadd_value(int var_id, const vector<int> &values) const {$/;"	f	class:cegar::SplitSelector
get_min_operator_cost	task_tools.cc	/^int get_min_operator_cost(TaskProxy task_proxy) {$/;"	f
get_minimal_representative	bliss/orbit.cc	/^unsigned int Orbit::get_minimal_representative(unsigned int element) const$/;"	f	class:bliss::Orbit
get_name	global_operator.h	/^    const std::string &get_name() const {return name; }$/;"	f	class:GlobalOperator
get_name	merge_and_shrink/shrink_strategy.cc	/^string ShrinkStrategy::get_name() const {$/;"	f	class:merge_and_shrink::ShrinkStrategy
get_name	task_proxy.h	/^    std::string get_name() const {$/;"	f	class:FactProxy
get_name	task_proxy.h	/^    std::string get_name() const {$/;"	f	class:OperatorProxy
get_name	task_proxy.h	/^    std::string get_name() const {$/;"	f	class:VariableProxy
get_needed_cost	landmarks/landmark_graph.h	/^    int get_needed_cost() const {return needed_cost; }$/;"	f	class:landmarks::EdgeType::LandmarkGraph
get_new_var_val_by_old_var_val	structural_symmetries/permutation.cc	/^pair<int, int> Permutation::get_new_var_val_by_old_var_val(const int var, const int val) const {$/;"	f	class:Permutation
get_next	merge_and_shrink/merge_strategy_precomputed.cc	/^pair<int, int> MergeStrategyPrecomputed::get_next() {$/;"	f	class:merge_and_shrink::MergeStrategyPrecomputed
get_next	merge_and_shrink/merge_strategy_stateless.cc	/^pair<int, int> MergeStrategyStateless::get_next() {$/;"	f	class:merge_and_shrink::MergeStrategyStateless
get_next_merge	merge_and_shrink/merge_tree.cc	/^pair<int, int> MergeTree::get_next_merge(int new_index) {$/;"	f	class:merge_and_shrink::MergeTree
get_node	cegar/refinement_hierarchy.cc	/^Node *RefinementHierarchy::get_node(const State &state) const {$/;"	f	class:cegar::RefinementHierarchy
get_node	search_space.cc	/^SearchNode SearchSpace::get_node(const GlobalState &state) {$/;"	f	class:SearchSpace
get_node_name	search_engines/top_k_eager_search.cc	/^std::string TopKEagerSearch::get_node_name(StateActionPair &edge) {$/;"	f	class:top_k_eager_search::TopKEagerSearch
get_nodes	landmarks/landmark_graph.h	/^    inline const std::set<LandmarkNode *> &get_nodes() const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
get_nof_bad_nodes	bliss/graph.h	/^  long unsigned int get_nof_bad_nodes() const {return nof_bad_nodes;}$/;"	f	class:bliss::Stats
get_nof_canupdates	bliss/graph.h	/^  long unsigned int get_nof_canupdates() const {return nof_canupdates;}$/;"	f	class:bliss::Stats
get_nof_generators	bliss/graph.h	/^  long unsigned int get_nof_generators() const {return nof_generators;}$/;"	f	class:bliss::Stats
get_nof_leaf_nodes	bliss/graph.h	/^  long unsigned int get_nof_leaf_nodes() const {return nof_leaf_nodes;}$/;"	f	class:bliss::Stats
get_nof_nodes	bliss/graph.h	/^  long unsigned int get_nof_nodes() const {return nof_nodes;}$/;"	f	class:bliss::Stats
get_nof_vertices	bliss/graph.h	/^  unsigned int get_nof_vertices() const {return vertices.size(); }$/;"	f	class:bliss::Digraph
get_nof_vertices	bliss/graph.h	/^  unsigned int get_nof_vertices() const {return vertices.size(); }$/;"	f	class:bliss::Graph
get_num_active_entries	merge_and_shrink/factored_transition_system.h	/^    int get_num_active_entries() const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
get_num_axioms	tasks/delegating_task.cc	/^int DelegatingTask::get_num_axioms() const {$/;"	f	class:tasks::DelegatingTask
get_num_axioms	tasks/root_task.cc	/^int RootTask::get_num_axioms() const {$/;"	f	class:tasks::RootTask
get_num_bins	algorithms/int_packer.h	/^    int get_num_bins() const {return num_bins; }$/;"	f	class:int_packer::IntPacker
get_num_blocks	algorithms/equivalence_relation.cc	/^int EquivalenceRelation::get_num_blocks() const {$/;"	f	class:equivalence_relation::EquivalenceRelation
get_num_constraints	lp/lp_solver.cc	/^int LPSolver::get_num_constraints() const {$/;"	f	class:lp::LPSolver
get_num_elements	algorithms/equivalence_relation.cc	/^int EquivalenceRelation::get_num_elements() const {$/;"	f	class:equivalence_relation::EquivalenceRelation
get_num_explicit_blocks	algorithms/equivalence_relation.cc	/^int EquivalenceRelation::get_num_explicit_blocks() const {$/;"	f	class:equivalence_relation::EquivalenceRelation
get_num_explicit_elements	algorithms/equivalence_relation.cc	/^int EquivalenceRelation::get_num_explicit_elements() const {$/;"	f	class:equivalence_relation::EquivalenceRelation
get_num_generators	structural_symmetries/group.cc	/^int Group::get_num_generators() const {$/;"	f	class:Group
get_num_goals	tasks/delegating_task.cc	/^int DelegatingTask::get_num_goals() const {$/;"	f	class:tasks::DelegatingTask
get_num_goals	tasks/modified_goals_task.cc	/^int ModifiedGoalsTask::get_num_goals() const {$/;"	f	class:extra_tasks::ModifiedGoalsTask
get_num_goals	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_goals() const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_goals	tasks/root_task.cc	/^int RootTask::get_num_goals() const {$/;"	f	class:tasks::RootTask
get_num_loops	cegar/transition_updater.cc	/^int TransitionUpdater::get_num_loops() const {$/;"	f	class:cegar::TransitionUpdater
get_num_non_looping_transitions	cegar/abstraction.h	/^    int get_num_non_looping_transitions() const {$/;"	f	class:cegar::Abstraction
get_num_non_loops	cegar/transition_updater.cc	/^int TransitionUpdater::get_num_non_loops() const {$/;"	f	class:cegar::TransitionUpdater
get_num_operator_appearances_on_plan	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_operator_appearances_on_plan(int op_no) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_operator_effect_conditions	tasks/delegating_task.cc	/^int DelegatingTask::get_num_operator_effect_conditions($/;"	f	class:tasks::DelegatingTask
get_num_operator_effect_conditions	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_operator_effect_conditions($/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_operator_effect_conditions	tasks/root_task.cc	/^int RootTask::get_num_operator_effect_conditions($/;"	f	class:tasks::RootTask
get_num_operator_effects	tasks/delegating_task.cc	/^int DelegatingTask::get_num_operator_effects(int op_index, bool is_axiom) const {$/;"	f	class:tasks::DelegatingTask
get_num_operator_effects	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_operator_effects(int op_index, bool is_axiom) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_operator_effects	tasks/root_task.cc	/^int RootTask::get_num_operator_effects(int op_index, bool is_axiom) const {$/;"	f	class:tasks::RootTask
get_num_operator_preconditions	tasks/delegating_task.cc	/^int DelegatingTask::get_num_operator_preconditions(int index, bool is_axiom) const {$/;"	f	class:tasks::DelegatingTask
get_num_operator_preconditions	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_operator_preconditions(int index, bool is_axiom) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_operator_preconditions	tasks/root_task.cc	/^int RootTask::get_num_operator_preconditions(int index, bool is_axiom) const {$/;"	f	class:tasks::RootTask
get_num_operators	tasks/delegating_task.cc	/^int DelegatingTask::get_num_operators() const {$/;"	f	class:tasks::DelegatingTask
get_num_operators	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_operators() const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_operators	tasks/root_task.cc	/^int RootTask::get_num_operators() const {$/;"	f	class:tasks::RootTask
get_num_states	cegar/abstraction.h	/^    int get_num_states() const {$/;"	f	class:cegar::Abstraction
get_num_states	merge_and_shrink/distances.cc	/^int Distances::get_num_states() const {$/;"	f	class:merge_and_shrink::Distances
get_num_unwanted_values	cegar/split_selector.cc	/^int SplitSelector::get_num_unwanted_values($/;"	f	class:cegar::SplitSelector
get_num_variables	lp/lp_solver.cc	/^int LPSolver::get_num_variables() const {$/;"	f	class:lp::LPSolver
get_num_variables	state_registry.h	/^    int get_num_variables() const {$/;"	f	class:StateRegistry
get_num_variables	tasks/delegating_task.cc	/^int DelegatingTask::get_num_variables() const {$/;"	f	class:tasks::DelegatingTask
get_num_variables	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_num_variables() const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_num_variables	tasks/root_task.cc	/^int RootTask::get_num_variables() const {$/;"	f	class:tasks::RootTask
get_objective_value	lp/lp_solver.cc	/^double LPSolver::get_objective_value() const {$/;"	f	class:lp::LPSolver
get_offset	algorithms/segmented_vector.h	/^    size_t get_offset(size_t index) const {$/;"	f	class:segmented_vector::SegmentedArrayVector
get_offset	algorithms/segmented_vector.h	/^    size_t get_offset(size_t index) const {$/;"	f	class:segmented_vector::SegmentedVector
get_op_for_label	domain_transition_graph.cc	/^OperatorProxy DTGFactory::get_op_for_label(const ValueTransitionLabel &label) {$/;"	f	class:DTGFactory
get_op_index	pruning_method.cc	/^static inline int get_op_index(const GlobalOperator *op) {$/;"	f	file:
get_op_index_hacked	global_operator.cc	/^int get_op_index_hacked(const GlobalOperator *op) {$/;"	f
get_op_type	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_op_type(int index) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_operator_cost	tasks/cost_adapted_task.cc	/^int CostAdaptedTask::get_operator_cost(int index, bool is_axiom) const {$/;"	f	class:tasks::CostAdaptedTask
get_operator_cost	tasks/delegating_task.cc	/^int DelegatingTask::get_operator_cost(int index, bool is_axiom) const {$/;"	f	class:tasks::DelegatingTask
get_operator_cost	tasks/modified_operator_costs_task.cc	/^int ModifiedOperatorCostsTask::get_operator_cost(int index, bool is_axiom) const {$/;"	f	class:extra_tasks::ModifiedOperatorCostsTask
get_operator_cost	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_operator_cost(int index, bool is_axiom) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_operator_cost	tasks/root_task.cc	/^int RootTask::get_operator_cost(int index, bool is_axiom) const {$/;"	f	class:tasks::RootTask
get_operator_costs	task_tools.cc	/^vector<int> get_operator_costs(const TaskProxy &task_proxy) {$/;"	f
get_operator_eff	heuristics/hm_heuristic.cc	/^HMHeuristic::Tuple HMHeuristic::get_operator_eff(const OperatorProxy &op) const {$/;"	f	class:hm_heuristic::HMHeuristic
get_operator_effect	tasks/delegating_task.cc	/^FactPair DelegatingTask::get_operator_effect($/;"	f	class:tasks::DelegatingTask
get_operator_effect	tasks/domain_abstracted_task.cc	/^FactPair DomainAbstractedTask::get_operator_effect($/;"	f	class:extra_tasks::DomainAbstractedTask
get_operator_effect	tasks/plan_forbid_reformulated_task.cc	/^FactPair PlanForbidReformulatedTask::get_operator_effect($/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_operator_effect	tasks/root_task.cc	/^FactPair RootTask::get_operator_effect($/;"	f	class:tasks::RootTask
get_operator_effect_condition	tasks/delegating_task.cc	/^FactPair DelegatingTask::get_operator_effect_condition($/;"	f	class:tasks::DelegatingTask
get_operator_effect_condition	tasks/plan_forbid_reformulated_task.cc	/^FactPair PlanForbidReformulatedTask::get_operator_effect_condition($/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_operator_effect_condition	tasks/root_task.cc	/^FactPair RootTask::get_operator_effect_condition($/;"	f	class:tasks::RootTask
get_operator_name	tasks/delegating_task.cc	/^string DelegatingTask::get_operator_name(int index, bool is_axiom) const {$/;"	f	class:tasks::DelegatingTask
get_operator_name	tasks/plan_forbid_reformulated_task.cc	/^string PlanForbidReformulatedTask::get_operator_name(int index, bool is_axiom) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_operator_name	tasks/root_task.cc	/^string RootTask::get_operator_name(int index, bool is_axiom) const {$/;"	f	class:tasks::RootTask
get_operator_or_axiom	landmarks/util.cc	/^OperatorProxy get_operator_or_axiom(const TaskProxy &task_proxy, int op_or_axiom_id) {$/;"	f	namespace:landmarks
get_operator_or_axiom	tasks/root_task.cc	/^static GlobalOperator &get_operator_or_axiom(int index, bool is_axiom) {$/;"	f	namespace:tasks
get_operator_or_axiom_id	landmarks/util.cc	/^int get_operator_or_axiom_id(const OperatorProxy &op) {$/;"	f	namespace:landmarks
get_operator_postcondition	landmarks/landmark_factory_h_m.cc	/^static FluentSet get_operator_postcondition(int num_vars, const OperatorProxy &op) {$/;"	f	namespace:landmarks
get_operator_pre	heuristics/hm_heuristic.cc	/^HMHeuristic::Tuple HMHeuristic::get_operator_pre(const OperatorProxy &op) const {$/;"	f	class:hm_heuristic::HMHeuristic
get_operator_precondition	landmarks/landmark_factory_h_m.cc	/^static FluentSet get_operator_precondition(const OperatorProxy &op) {$/;"	f	namespace:landmarks
get_operator_precondition	tasks/delegating_task.cc	/^FactPair DelegatingTask::get_operator_precondition($/;"	f	class:tasks::DelegatingTask
get_operator_precondition	tasks/domain_abstracted_task.cc	/^FactPair DomainAbstractedTask::get_operator_precondition($/;"	f	class:extra_tasks::DomainAbstractedTask
get_operator_precondition	tasks/plan_forbid_reformulated_task.cc	/^FactPair PlanForbidReformulatedTask::get_operator_precondition($/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_operator_precondition	tasks/root_task.cc	/^FactPair RootTask::get_operator_precondition($/;"	f	class:tasks::RootTask
get_operators	task_proxy.h	/^    OperatorsProxy get_operators() const {$/;"	f	class:TaskProxy
get_operators_including_eff	landmarks/landmark_graph.h	/^    inline const std::vector<int> &get_operators_including_eff(const FactPair &eff) const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
get_order	structural_symmetries/permutation.h	/^    int get_order() const {$/;"	f	class:Permutation
get_outgoing_transitions	cegar/abstract_state.h	/^    const Transitions &get_outgoing_transitions() const {$/;"	f	class:cegar::AbstractState
get_packed_buffer	global_state.h	/^    const PackedStateBin *get_packed_buffer() const {$/;"	f	class:GlobalState
get_pair	task_proxy.h	/^    FactPair get_pair() const {$/;"	f	class:FactProxy
get_parent_of_ts_index	merge_and_shrink/merge_tree.cc	/^MergeTreeNode *MergeTreeNode::get_parent_of_ts_index(int index) {$/;"	f	class:merge_and_shrink::MergeTreeNode
get_parent_op_index	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_parent_op_index(int index) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_parents_of_ts_indices	merge_and_shrink/merge_tree.cc	/^pair<MergeTreeNode *, MergeTreeNode *> MergeTree::get_parents_of_ts_indices($/;"	f	class:merge_and_shrink::MergeTree
get_parse_tree	options/option_parser.cc	/^const ParseTree *OptionParser::get_parse_tree() {$/;"	f	class:options::OptionParser
get_pattern	pdbs/pattern_database.h	/^    const Pattern &get_pattern() const {$/;"	f	class:pdbs::PatternDatabase
get_pattern_collection_information	pdbs/incremental_canonical_pdbs.cc	/^IncrementalCanonicalPDBs::get_pattern_collection_information() const {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
get_pattern_databases	pdbs/incremental_canonical_pdbs.h	/^    std::shared_ptr<PDBCollection> get_pattern_databases() const {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
get_patterns	pdbs/pattern_collection_information.cc	/^shared_ptr<PatternCollection> PatternCollectionInformation::get_patterns() {$/;"	f	class:pdbs::PatternCollectionInformation
get_pdb_from_options	pdbs/pdb_heuristic.cc	/^PatternDatabase get_pdb_from_options(const shared_ptr<AbstractTask> &task,$/;"	f	namespace:pdbs
get_pdbs	pdbs/pattern_collection_information.cc	/^shared_ptr<PDBCollection> PatternCollectionInformation::get_pdbs() {$/;"	f	class:pdbs::PatternCollectionInformation
get_peak_memory_in_kb	utils/system_unix.cc	/^int get_peak_memory_in_kb() {$/;"	f	namespace:utils
get_peak_memory_in_kb	utils/system_windows.cc	/^int get_peak_memory_in_kb() {$/;"	f	namespace:utils
get_permutation	structural_symmetries/group.cc	/^const Permutation &Group::get_permutation(int index) const {$/;"	f	class:Group
get_permuted_operator_no	structural_symmetries/operator_permutation.h	/^    int get_permuted_operator_no(int op_no) const {$/;"	f	class:OperatorPermutation
get_plan	search_engine.cc	/^const SearchEngine::Plan &SearchEngine::get_plan() const {$/;"	f	class:SearchEngine
get_plan_index_ordered	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_plan_index_ordered(int op_no, int appearance_index) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_possible_splits	cegar/abstraction.cc	/^    vector<Split> get_possible_splits() const {$/;"	f	struct:cegar::Flaw
get_possible_var_index	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_possible_var_index() const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_postcondition_value	cegar/transition_updater.cc	/^int TransitionUpdater::get_postcondition_value(int op_id, int var) const {$/;"	f	class:cegar::TransitionUpdater
get_postconditions	cegar/transition_updater.cc	/^static vector<FactPair> get_postconditions($/;"	f	namespace:cegar
get_postconditions_by_operator	cegar/transition_updater.cc	/^static vector<vector<FactPair>> get_postconditions_by_operator($/;"	f	namespace:cegar
get_potential_function	potentials/potential_optimizer.cc	/^unique_ptr<PotentialFunction> PotentialOptimizer::get_potential_function() const {$/;"	f	class:potentials::PotentialOptimizer
get_pre_to_eff	causal_graph.h	/^    const std::vector<int> &get_pre_to_eff(int var) const {$/;"	f	class:CausalGraph
get_precondition_value	cegar/transition_updater.cc	/^int TransitionUpdater::get_precondition_value(int op_id, int var) const {$/;"	f	class:cegar::TransitionUpdater
get_preconditions	global_operator.h	/^    const std::vector<GlobalCondition> &get_preconditions() const {return preconditions; }$/;"	f	class:GlobalOperator
get_preconditions	task_proxy.h	/^    PreconditionsProxy get_preconditions() const {$/;"	f	class:OperatorProxy
get_preconditions_by_operator	cegar/transition_updater.cc	/^static vector<vector<FactPair>> get_preconditions_by_operator($/;"	f	namespace:cegar
get_predecessors	causal_graph.h	/^    const std::vector<int> &get_predecessors(int var) const {$/;"	f	class:CausalGraph
get_predicate_for_fact	landmarks/landmark_factory_rpg_sasp.cc	/^static string get_predicate_for_fact(const VariablesProxy &variables,$/;"	f	namespace:landmarks
get_preferred_operators	evaluation_context.cc	/^EvaluationContext::get_preferred_operators(ScalarEvaluator *heur) {$/;"	f	class:EvaluationContext
get_preferred_operators	evaluation_result.cc	/^EvaluationResult::get_preferred_operators() const {$/;"	f	class:EvaluationResult
get_prev_landmarks	cegar/utils_landmarks.cc	/^VarToValues get_prev_landmarks(const LandmarkGraph &graph, const FactPair &fact) {$/;"	f	namespace:cegar
get_priority	heuristics/cea_heuristic.cc	/^int ContextEnhancedAdditiveHeuristic::get_priority($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
get_process_id	utils/system_unix.cc	/^int get_process_id() {$/;"	f	namespace:utils
get_process_id	utils/system_windows.cc	/^int get_process_id() {$/;"	f	namespace:utils
get_proposition	heuristics/lm_cut_landmarks.cc	/^RelaxedProposition *LandmarkCutLandmarks::get_proposition($/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
get_proposition	heuristics/relaxation_heuristic.cc	/^Proposition *RelaxationHeuristic::get_proposition(const FactProxy &fact) {$/;"	f	class:relaxation_heuristic::RelaxationHeuristic
get_range	causal_graph.cc	/^int IntRelationBuilder::get_range() const {$/;"	f	class:IntRelationBuilder
get_reached_cost	landmarks/landmark_graph.h	/^    int get_reached_cost() const {return reached_cost; }$/;"	f	class:landmarks::EdgeType::LandmarkGraph
get_reached_landmarks	landmarks/landmark_status_manager.cc	/^vector<bool> &LandmarkStatusManager::get_reached_landmarks(const GlobalState &state) {$/;"	f	class:landmarks::LandmarkStatusManager
get_real_g	search_space.cc	/^int SearchNode::get_real_g() const {$/;"	f	class:SearchNode
get_refinedness	cegar/split_selector.cc	/^double SplitSelector::get_refinedness(const AbstractState &state, int var_id) const {$/;"	f	class:cegar::SplitSelector
get_reformulated_op_type	global_operator.cc	/^int GlobalOperator::get_reformulated_op_type(const vector<GlobalCondition>& extra_pre, const vector<GlobalEffect>& extra_eff) const {$/;"	f	class:GlobalOperator
get_registry	global_state.h	/^    const StateRegistry &get_registry() const {$/;"	f	class:GlobalState
get_regression_preconditions	pdbs/pattern_database.h	/^    const std::vector<FactPair> &get_regression_preconditions() const {$/;"	f	class:pdbs::AbstractOperator
get_relaxed_possible_before	cegar/utils.cc	/^unordered_set<FactProxy> get_relaxed_possible_before($/;"	f	namespace:cegar
get_remaining_candidates	merge_and_shrink/merge_selector_score_based_filtering.cc	/^vector<pair<int, int>> MergeSelectorScoreBasedFiltering::get_remaining_candidates($/;"	f	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
get_remaining_costs_task	cegar/cost_saturation.cc	/^shared_ptr<AbstractTask> CostSaturation::get_remaining_costs_task($/;"	f	class:cegar::CostSaturation
get_remaining_time	utils/countdown_timer.cc	/^double CountdownTimer::get_remaining_time() const {$/;"	f	class:utils::CountdownTimer
get_reopened	search_statistics.h	/^    int get_reopened() const {return reopened_states; }$/;"	f	class:SearchStatistics
get_result	evaluation_context.cc	/^const EvaluationResult &EvaluationContext::get_result(ScalarEvaluator *heur) {$/;"	f	class:EvaluationContext
get_root	cegar/refinement_hierarchy.h	/^    Node *get_root() const {$/;"	f	class:cegar::RefinementHierarchy
get_saturated_costs	cegar/abstraction.cc	/^vector<int> Abstraction::get_saturated_costs() {$/;"	f	class:cegar::Abstraction
get_search_engine	search_engines/iterated_search.cc	/^unique_ptr<SearchEngine> IteratedSearch::get_search_engine($/;"	f	class:iterated_search::IteratedSearch
get_search_info	cegar/abstract_state.h	/^    AbstractSearchInfo &get_search_info() {return search_info; }$/;"	f	class:cegar::AbstractState
get_search_symmetries	structural_symmetries/group.h	/^    SearchSymmetries get_search_symmetries() const {$/;"	f	class:Group
get_segment	algorithms/segmented_vector.h	/^    size_t get_segment(size_t index) const {$/;"	f	class:segmented_vector::SegmentedArrayVector
get_segment	algorithms/segmented_vector.h	/^    size_t get_segment(size_t index) const {$/;"	f	class:segmented_vector::SegmentedVector
get_simple_lm_node	landmarks/landmark_graph.h	/^    inline LandmarkNode &get_simple_lm_node(const FactPair &a) const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
get_size	merge_and_shrink/factored_transition_system.h	/^    int get_size() const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
get_size	merge_and_shrink/label_equivalence_relation.h	/^    int get_size() const {$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
get_size	merge_and_shrink/labels.h	/^    int get_size() const {$/;"	f	class:merge_and_shrink::Labels
get_size	merge_and_shrink/transition_system.h	/^    int get_size() const {$/;"	f	class:merge_and_shrink::TransitionSystem
get_size	pdbs/incremental_canonical_pdbs.h	/^    int get_size() const {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
get_size	pdbs/pattern_database.h	/^    int get_size() const {$/;"	f	class:pdbs::PatternDatabase
get_solution	cegar/abstract_search.h	/^    const Solution &get_solution() {$/;"	f	class:cegar::AbstractSearch
get_split_m_sets	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::get_split_m_sets($/;"	f	class:landmarks::LandmarkFactoryHM
get_state	evaluation_context.cc	/^const GlobalState &EvaluationContext::get_state() const {$/;"	f	class:EvaluationContext
get_state	heuristic_cache.cc	/^const GlobalState &HeuristicCache::get_state() const {$/;"	f	class:HeuristicCache
get_state	search_space.cc	/^GlobalState SearchNode::get_state() const {$/;"	f	class:SearchNode
get_state_id	search_space.h	/^    StateID get_state_id() const {$/;"	f	class:SearchNode
get_state_registry	search_engine.h	/^    const StateRegistry &get_state_registry() const {$/;"	f	class:SearchEngine
get_state_size_in_bytes	state_registry.cc	/^int StateRegistry::get_state_size_in_bytes() const {$/;"	f	class:StateRegistry
get_state_value	state_registry.h	/^    int get_state_value(const PackedStateBin *buffer, int var) const {$/;"	f	class:StateRegistry
get_statistics	search_engine.h	/^    const SearchStatistics &get_statistics() const {return statistics; }$/;"	f	class:SearchEngine
get_status	landmarks/landmark_graph.h	/^    int get_status() const {$/;"	f	class:landmarks::EdgeType::LandmarkNode
get_status	search_engine.cc	/^SearchStatus SearchEngine::get_status() const {$/;"	f	class:SearchEngine
get_subtasks	cegar/subtask_generators.cc	/^SharedTasks GoalDecomposition::get_subtasks($/;"	f	class:cegar::GoalDecomposition
get_subtasks	cegar/subtask_generators.cc	/^SharedTasks LandmarkDecomposition::get_subtasks($/;"	f	class:cegar::LandmarkDecomposition
get_subtasks	cegar/subtask_generators.cc	/^SharedTasks TaskDuplicator::get_subtasks($/;"	f	class:cegar::TaskDuplicator
get_successor	task_proxy.h	/^    State get_successor(OperatorProxy op) const {$/;"	f	class:State
get_successor_operators	search_engines/lazy_search.cc	/^vector<const GlobalOperator *> LazySearch::get_successor_operators($/;"	f	class:lazy_search::LazySearch
get_successor_state	state_registry.cc	/^GlobalState StateRegistry::get_successor_state(const GlobalState &predecessor, const GlobalOperator &op) {$/;"	f	class:StateRegistry
get_successors	causal_graph.h	/^    const std::vector<int> &get_successors(int var) const {$/;"	f	class:CausalGraph
get_symmetrical_lookups	structural_symmetries/group.h	/^    SymmetricalLookups get_symmetrical_lookups() const {$/;"	f	class:Group
get_task	potentials/potential_optimizer.cc	/^const shared_ptr<AbstractTask> PotentialOptimizer::get_task() const {$/;"	f	class:potentials::PotentialOptimizer
get_task	state_registry.h	/^    const AbstractTask &get_task() const {$/;"	f	class:StateRegistry
get_task	task_proxy.h	/^inline TaskProxy State::get_task() const {$/;"	f	class:State
get_task	tasks/domain_abstracted_task_factory.cc	/^shared_ptr<AbstractTask> DomainAbstractedTaskFactory::get_task() const {$/;"	f	class:extra_tasks::DomainAbstractedTaskFactory
get_trace	structural_symmetries/group.cc	/^void Group::get_trace(const GlobalState &state, Trace& full_trace) const {$/;"	f	class:Group
get_transition	domain_transition_graph.cc	/^ValueTransition *DTGFactory::get_transition(int origin, int target,$/;"	f	class:DTGFactory
get_transition_cost	heuristics/cg_heuristic.cc	/^int CGHeuristic::get_transition_cost(const State &state,$/;"	f	class:cg_heuristic::CGHeuristic
get_transitions_for_group_id	merge_and_shrink/transition_system.h	/^    const std::vector<Transition> &get_transitions_for_group_id(int group_id) const {$/;"	f	class:merge_and_shrink::TransitionSystem
get_trivial_abstract_state	cegar/abstract_state.cc	/^AbstractState *AbstractState::get_trivial_abstract_state($/;"	f	class:cegar::AbstractState
get_ts	merge_and_shrink/factored_transition_system.h	/^    const TransitionSystem &get_ts(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
get_type	options/registries.h	/^    const std::type_index &get_type() const {$/;"	f	class:options::PluginTypeInfo
get_type_name	options/registries.h	/^    const std::string &get_type_name() const {$/;"	f	class:options::PluginTypeInfo
get_types	options/doc_store.cc	/^vector<string> DocStore::get_types() {$/;"	f	class:options::DocStore
get_undefined_value	potentials/potential_optimizer.cc	/^static int get_undefined_value(VariableProxy var) {$/;"	f	namespace:potentials
get_unparsed_config	options/options.h	/^    std::string get_unparsed_config() const {$/;"	f	class:options::Options
get_upper_bound	lp/lp_solver.h	/^    double get_upper_bound() const {return upper_bound; }$/;"	f	class:lp::LPConstraint
get_value	bliss/uintseqhash.h	/^  unsigned int get_value() const {return h; }$/;"	f	class:bliss::UintSeqHash
get_value	cegar/cartesian_heuristic_function.cc	/^int CartesianHeuristicFunction::get_value(const State &parent_state) const {$/;"	f	class:cegar::CartesianHeuristicFunction
get_value	merge_and_shrink/merge_and_shrink_representation.cc	/^int MergeAndShrinkRepresentationLeaf::get_value(const State &state) const {$/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
get_value	merge_and_shrink/merge_and_shrink_representation.cc	/^int MergeAndShrinkRepresentationMerge::get_value($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
get_value	pdbs/canonical_pdbs.cc	/^int CanonicalPDBs::get_value(const State &state) const {$/;"	f	class:pdbs::CanonicalPDBs
get_value	pdbs/incremental_canonical_pdbs.cc	/^int IncrementalCanonicalPDBs::get_value(const State &state) const {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
get_value	pdbs/pattern_database.cc	/^int PatternDatabase::get_value(const State &state) const {$/;"	f	class:pdbs::PatternDatabase
get_value	pdbs/zero_one_pdbs.cc	/^int ZeroOnePDBs::get_value(const State &state) const {$/;"	f	class:pdbs::ZeroOnePDBs
get_value	potentials/potential_function.cc	/^int PotentialFunction::get_value(const State &state) const {$/;"	f	class:potentials::PotentialFunction
get_value	structural_symmetries/permutation.h	/^    int get_value(int ind) const {$/;"	f	class:Permutation
get_value	task_proxy.h	/^    int get_value() const {$/;"	f	class:FactProxy
get_value_or_default	utils/collections.h	/^ValueType get_value_or_default($/;"	f	namespace:utils
get_values	global_state.cc	/^vector<int> GlobalState::get_values() const {$/;"	f	class:GlobalState
get_values	task_proxy.h	/^    const std::vector<int> &get_values() const {$/;"	f	class:State
get_var	cegar/refinement_hierarchy.h	/^    int get_var() const {$/;"	f	class:cegar::Node
get_var_by_index	structural_symmetries/permutation.cc	/^int Permutation::get_var_by_index(int ind) {$/;"	f	class:Permutation
get_var_val_by_index	structural_symmetries/permutation.cc	/^pair<int, int> Permutation::get_var_val_by_index(int ind) {$/;"	f	class:Permutation
get_variable	task_proxy.h	/^inline VariableProxy FactProxy::get_variable() const {$/;"	f	class:FactProxy
get_variable_axiom_layer	tasks/delegating_task.cc	/^int DelegatingTask::get_variable_axiom_layer(int var) const {$/;"	f	class:tasks::DelegatingTask
get_variable_axiom_layer	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_variable_axiom_layer(int var) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_variable_axiom_layer	tasks/root_task.cc	/^int RootTask::get_variable_axiom_layer(int var) const {$/;"	f	class:tasks::RootTask
get_variable_default_axiom_value	tasks/delegating_task.cc	/^int DelegatingTask::get_variable_default_axiom_value(int var) const {$/;"	f	class:tasks::DelegatingTask
get_variable_default_axiom_value	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_variable_default_axiom_value(int var) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_variable_default_axiom_value	tasks/root_task.cc	/^int RootTask::get_variable_default_axiom_value(int var) const {$/;"	f	class:tasks::RootTask
get_variable_domain_size	tasks/delegating_task.cc	/^int DelegatingTask::get_variable_domain_size(int var) const {$/;"	f	class:tasks::DelegatingTask
get_variable_domain_size	tasks/domain_abstracted_task.cc	/^int DomainAbstractedTask::get_variable_domain_size(int var) const {$/;"	f	class:extra_tasks::DomainAbstractedTask
get_variable_domain_size	tasks/plan_forbid_reformulated_task.cc	/^int PlanForbidReformulatedTask::get_variable_domain_size(int var) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_variable_domain_size	tasks/root_task.cc	/^int RootTask::get_variable_domain_size(int var) const {$/;"	f	class:tasks::RootTask
get_variable_name	tasks/delegating_task.cc	/^string DelegatingTask::get_variable_name(int var) const {$/;"	f	class:tasks::DelegatingTask
get_variable_name	tasks/plan_forbid_reformulated_task.cc	/^string PlanForbidReformulatedTask::get_variable_name(int var) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
get_variable_name	tasks/root_task.cc	/^string RootTask::get_variable_name(int var) const {$/;"	f	class:tasks::RootTask
get_variables	lp/lp_solver.h	/^    const std::vector<int> &get_variables() const {return variables; }$/;"	f	class:lp::LPConstraint
get_variables	task_proxy.h	/^    VariablesProxy get_variables() const {$/;"	f	class:TaskProxy
get_zero_one_pdbs_from_options	pdbs/zero_one_pdbs_heuristic.cc	/^ZeroOnePDBs get_zero_one_pdbs_from_options($/;"	f	namespace:pdbs
global_to_local_var	domain_transition_graph.h	/^    std::vector<std::unordered_map<int, int>> global_to_local_var;$/;"	m	class:DTGFactory
goal_count_heuristic	heuristics/goal_count_heuristic.cc	/^namespace goal_count_heuristic {$/;"	n	file:
goal_count_heuristic	heuristics/goal_count_heuristic.h	/^namespace goal_count_heuristic {$/;"	n
goal_distances	merge_and_shrink/distances.h	/^    std::vector<int> goal_distances;$/;"	m	class:merge_and_shrink::Distances
goal_node	heuristics/cea_heuristic.h	/^    LocalProblemNode *goal_node;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
goal_problem	heuristics/cea_heuristic.h	/^    LocalProblem *goal_problem;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
goal_propositions	heuristics/relaxation_heuristic.h	/^    std::vector<Proposition *> goal_propositions;$/;"	m	class:relaxation_heuristic::RelaxationHeuristic
goal_propositions	landmarks/exploration.h	/^    std::vector<ExProposition *> goal_propositions;$/;"	m	class:landmarks::Exploration
goal_state	operator_counting/state_equation_constraints.h	/^    std::vector<int> goal_state;$/;"	m	class:operator_counting::StateEquationConstraints
goal_state	search_engines/top_k_eager_search.h	/^	StateID goal_state = StateID::no_state;$/;"	m	class:top_k_eager_search::TopKEagerSearch
goal_states	merge_and_shrink/fts_factory.cc	/^        vector<bool> goal_states;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
goal_states	merge_and_shrink/transition_system.h	/^    std::vector<bool> goal_states;$/;"	m	class:merge_and_shrink::TransitionSystem
goals	cegar/abstraction.h	/^    AbstractStates goals;$/;"	m	class:cegar::Abstraction
goals	heuristics/hm_heuristic.h	/^    const Tuple goals;$/;"	m	class:hm_heuristic::HMHeuristic
goals	tasks/domain_abstracted_task.h	/^    const std::vector<FactPair> goals;$/;"	m	class:extra_tasks::DomainAbstractedTask
goals	tasks/domain_abstracted_task_factory.cc	/^    vector<FactPair> goals;$/;"	m	class:extra_tasks::DomainAbstractedTaskFactory	file:
goals	tasks/modified_goals_task.h	/^    const std::vector<FactPair> goals;$/;"	m	class:extra_tasks::ModifiedGoalsTask
goto_backtrack_point	bliss/partition.cc	/^Partition::goto_backtrack_point(BacktrackPoint p)$/;"	f	class:bliss::Partition
graph	algorithms/max_cliques.cc	/^    const vector<vector<int>> &graph;$/;"	m	class:max_cliques::MaxCliqueComputer	file:
graph	bliss/partition.h	/^  AbstractGraph* graph;$/;"	m	class:bliss::Partition
graph_creator	structural_symmetries/group.h	/^    GraphCreator *graph_creator;$/;"	m	class:Group
greedy	merge_and_shrink/shrink_bisimulation.h	/^    const bool greedy;$/;"	m	class:merge_and_shrink::ShrinkBisimulation
greedy_necessary	landmarks/landmark_graph.h	/^    greedy_necessary = 3,$/;"	m	class:landmarks::EdgeType
group	merge_and_shrink/shrink_bisimulation.cc	/^    int group;$/;"	m	struct:merge_and_shrink::Signature	file:
group	search_engines/eager_search.h	/^    std::shared_ptr<Group> group;$/;"	m	class:eager_search::EagerSearch
group	state_registry.h	/^    std::shared_ptr<Group> group;$/;"	m	class:StateRegistry
group_size	bliss/graph.h	/^  BigNum group_size;$/;"	m	class:bliss::Stats
group_size_approx	bliss/graph.h	/^  long double group_size_approx;$/;"	m	class:bliss::Stats
grouped_labels	merge_and_shrink/label_equivalence_relation.h	/^    std::vector<LabelGroup> grouped_labels;$/;"	m	class:merge_and_shrink::LabelEquivalenceRelation
h	bliss/uintseqhash.h	/^  unsigned int h;$/;"	m	class:bliss::UintSeqHash
h	cegar/refinement_hierarchy.h	/^    int h;$/;"	m	class:cegar::Node
h	heuristic.h	/^        int h : 31;$/;"	m	struct:Heuristic::HEntry
h	open_lists/epsilon_greedy_open_list.cc	/^        int h;$/;"	m	struct:EpsilonGreedyOpenList::HeapNode	file:
h_add_cost	landmarks/exploration.h	/^    int h_add_cost;$/;"	m	struct:landmarks::ExProposition
h_add_cost	landmarks/exploration.h	/^    int h_add_cost;$/;"	m	struct:landmarks::ExUnaryOperator
h_and_goal	merge_and_shrink/shrink_bisimulation.cc	/^    int h_and_goal; \/\/ -1 for goal states; h value for non-goal states$/;"	m	struct:merge_and_shrink::Signature	file:
h_m_table_	landmarks/landmark_factory_h_m.h	/^    std::vector<HMEntry> h_m_table_;$/;"	m	class:landmarks::LandmarkFactoryHM
h_max_cost	heuristics/lm_cut_landmarks.h	/^    int h_max_cost;$/;"	m	struct:lm_cut_heuristic::RelaxedProposition
h_max_cost	landmarks/exploration.h	/^    int h_max_cost;$/;"	m	struct:landmarks::ExProposition
h_max_cost	landmarks/exploration.h	/^    int h_max_cost;$/;"	m	struct:landmarks::ExUnaryOperator
h_max_supporter	heuristics/lm_cut_landmarks.h	/^    RelaxedProposition *h_max_supporter;$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
h_max_supporter_cost	heuristics/lm_cut_landmarks.h	/^    int h_max_supporter_cost; \/\/ h_max_cost of h_max_supporter$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
h_start	merge_and_shrink/shrink_fh.h	/^    const HighLow h_start;$/;"	m	class:merge_and_shrink::ShrinkFH
h_value	evaluation_result.h	/^    int h_value;$/;"	m	class:EvaluationResult
hadd	cegar/subtask_generators.cc	/^    shared_ptr<additive_heuristic::AdditiveHeuristic> hadd;$/;"	m	class:cegar::SortFactsByIncreasingHaddValues	file:
handle_coin_error	lp/lp_internals.cc	/^void handle_coin_error(const CoinError &error) {$/;"	f	namespace:lp
handle_eff_eff_edge	causal_graph.cc	/^    void handle_eff_eff_edge(int u, int v) {$/;"	f	struct:CausalGraphBuilder
handle_operator	causal_graph.cc	/^    void handle_operator(const OperatorProxy &op) {$/;"	f	struct:CausalGraphBuilder
handle_operator_effect	merge_and_shrink/fts_factory.cc	/^void FTSFactory::handle_operator_effect($/;"	f	class:merge_and_shrink::FTSFactory
handle_operator_precondition	merge_and_shrink/fts_factory.cc	/^void FTSFactory::handle_operator_precondition($/;"	f	class:merge_and_shrink::FTSFactory
handle_pre_eff_arc	causal_graph.cc	/^    void handle_pre_eff_arc(int u, int v) {$/;"	f	struct:CausalGraphBuilder
handle_shrink_limit_options_defaults	merge_and_shrink/merge_and_shrink_heuristic.cc	/^void MergeAndShrinkHeuristic::handle_shrink_limit_options_defaults(Options &opts) {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
handle_stubborn_operator	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::handle_stubborn_operator(const State &state, int op_no) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
handle_stubborn_operator	pruning/stubborn_sets_simple.cc	/^void StubbornSetsSimple::handle_stubborn_operator(const State &state,$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
has_axioms	globals.cc	/^bool has_axioms() {$/;"	f
has_axioms	task_tools.cc	/^bool has_axioms(TaskProxy task) {$/;"	f
has_bound	options/bounds.h	/^    bool has_bound() const {$/;"	f	struct:options::Bounds
has_cond_effects	heuristics/hm_heuristic.h	/^    const bool has_cond_effects;$/;"	m	class:hm_heuristic::HMHeuristic
has_conditional_effects	globals.cc	/^bool has_conditional_effects() {$/;"	f
has_conditional_effects	task_tools.cc	/^bool has_conditional_effects(TaskProxy task) {$/;"	f
has_conditional_effects	tasks/domain_abstracted_task.cc	/^static bool has_conditional_effects(const AbstractTask &task) {$/;"	f	namespace:extra_tasks
has_optimal_solution	lp/lp_solver.cc	/^bool LPSolver::has_optimal_solution() const {$/;"	f	class:lp::LPSolver
has_optimal_solution	potentials/potential_optimizer.cc	/^bool PotentialOptimizer::has_optimal_solution() const {$/;"	f	class:potentials::PotentialOptimizer
has_symmetries	structural_symmetries/group.h	/^    bool has_symmetries() const {$/;"	f	class:Group
has_temporary_constraints	lp/lp_solver.cc	/^int LPSolver::has_temporary_constraints() const {$/;"	f	class:lp::LPSolver
has_temporary_constraints_	lp/lp_solver.h	/^    bool has_temporary_constraints_;$/;"	m	class:lp::LPSolver
has_two_leaf_children	merge_and_shrink/merge_tree.h	/^    bool has_two_leaf_children() const {$/;"	f	struct:merge_and_shrink::MergeTreeNode
hash	abstract_task.h	/^struct hash<FactPair> {$/;"	s	namespace:std
hash	cegar/utils.h	/^struct hash<FactProxy> {$/;"	s	namespace:std
hash	state_id.h	/^    size_t hash() const {$/;"	f	class:StateID
hash	state_id.h	/^struct hash<StateID> {$/;"	s	namespace:std
hash	task_proxy.h	/^    std::size_t hash() const {$/;"	f	class:State
hash	task_proxy.h	/^struct hash<State> {$/;"	s	namespace:std
hash	utils/hash.h	/^struct hash<std::pair<TA, TB>> {$/;"	s	namespace:std
hash	utils/hash.h	/^struct hash<std::vector<T>> {$/;"	s	namespace:std
hash_combine	utils/hash.h	/^inline void hash_combine(size_t &hash, const T &value) {$/;"	f	namespace:utils
hash_effect	pdbs/pattern_database.h	/^    std::size_t hash_effect;$/;"	m	class:pdbs::AbstractOperator
hash_index	pdbs/pattern_database.cc	/^size_t PatternDatabase::hash_index(const State &state) const {$/;"	f	class:pdbs::PatternDatabase
hash_multipliers	pdbs/match_tree.h	/^    std::vector<size_t> hash_multipliers;$/;"	m	class:pdbs::MatchTree
hash_multipliers	pdbs/pattern_database.h	/^    std::vector<std::size_t> hash_multipliers;$/;"	m	class:pdbs::PatternDatabase
hash_sequence	utils/hash.h	/^size_t hash_sequence(const Sequence &data, size_t length) {$/;"	f	namespace:utils
head	bliss/kqueue.h	/^  Type *head, *tail;$/;"	m	class:bliss::KQueue
head	ext/tree.hh	/^		tree_node *head, *feet;    \/\/ head\/feet are always dummy; if an iterator points to them it is invalid$/;"	m	class:tree
head_initialise_	ext/tree.hh	/^void tree<T, tree_node_allocator>::head_initialise_() $/;"	f	class:tree
heap	algorithms/priority_queues.h	/^    Heap heap;$/;"	m	class:priority_queues::HeapQueue
heap	open_lists/epsilon_greedy_open_list.cc	/^    vector<HeapNode> heap;$/;"	m	class:EpsilonGreedyOpenList	file:
held	options/any.h	/^        ValueType held;$/;"	m	class:options::Any::Holder
help	options/doc_store.h	/^    std::string help;$/;"	m	struct:options::ArgumentInfo
help_mode	options/option_parser.cc	/^bool OptionParser::help_mode() const {$/;"	f	class:options::OptionParser
help_mode	options/options.h	/^    bool help_mode;$/;"	m	class:options::Options
help_mode_	options/option_parser.h	/^    bool help_mode_;$/;"	m	class:options::OptionParser
helpful_transition_cache	heuristics/cg_cache.h	/^    std::vector<std::vector<ValueTransitionLabel *>> helpful_transition_cache;$/;"	m	class:cg_heuristic::CGCache
helpful_transition_extraction_counter	heuristics/cg_heuristic.h	/^    int helpful_transition_extraction_counter;$/;"	m	class:cg_heuristic::CGHeuristic
helpful_transitions	domain_transition_graph.h	/^    std::vector<ValueTransitionLabel *> helpful_transitions;$/;"	m	struct:ValueNode
heuristic	search_engines/enforced_hill_climbing_search.h	/^    Heuristic *heuristic;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
heuristic_cache	heuristic.h	/^    PerStateInformation<HEntry> heuristic_cache;$/;"	m	class:Heuristic
heuristic_functions	cegar/additive_cartesian_heuristic.h	/^    const std::vector<CartesianHeuristicFunction> heuristic_functions;$/;"	m	class:cegar::AdditiveCartesianHeuristic
heuristic_functions	cegar/cost_saturation.h	/^    std::vector<CartesianHeuristicFunction> heuristic_functions;$/;"	m	class:cegar::CostSaturation
heuristic_recomputation_needed	landmarks/exploration.h	/^    bool heuristic_recomputation_needed;$/;"	m	class:landmarks::Exploration
heuristics	options/synergy.h	/^    std::vector<Heuristic *> heuristics;$/;"	m	class:options::Synergy
heuristics	search_engines/eager_search.h	/^    std::vector<Heuristic *> heuristics;$/;"	m	class:eager_search::EagerSearch
heuristics	search_engines/enforced_hill_climbing_search.h	/^    std::set<Heuristic *> heuristics;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
heuristics	search_engines/lazy_search.h	/^    std::vector<Heuristic *> heuristics;$/;"	m	class:lazy_search::LazySearch
heuristics	search_engines/top_k_eager_search.h	/^    std::vector<Heuristic *> heuristics;$/;"	m	class:top_k_eager_search::TopKEagerSearch
hidden	options/doc_store.h	/^    bool hidden;$/;"	m	struct:options::DocStruct
hide	options/doc_store.cc	/^void DocStore::hide(string k) {$/;"	f	class:options::DocStore
hill_climbing	pdbs/pattern_collection_generator_hillclimbing.cc	/^void PatternCollectionGeneratorHillclimbing::hill_climbing($/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
hill_climbing_timer	pdbs/pattern_collection_generator_hillclimbing.h	/^    utils::CountdownTimer *hill_climbing_timer;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
hm_heuristic	heuristics/hm_heuristic.cc	/^namespace hm_heuristic {$/;"	n	file:
hm_heuristic	heuristics/hm_heuristic.h	/^namespace hm_heuristic {$/;"	n
hm_table	heuristics/hm_heuristic.h	/^    std::map<Tuple, int> hm_table;$/;"	m	class:hm_heuristic::HMHeuristic
id	global_state.h	/^    StateID id;$/;"	m	class:GlobalState
id	heuristics/relaxation_heuristic.h	/^    int id;$/;"	m	struct:relaxation_heuristic::Proposition
id	landmarks/landmark_graph.h	/^    int id;$/;"	m	class:landmarks::EdgeType::LandmarkNode
id	open_lists/epsilon_greedy_open_list.cc	/^        int id;$/;"	m	struct:EpsilonGreedyOpenList::HeapNode	file:
id	task_proxy.h	/^    int id;$/;"	m	class:VariableProxy
identity	structural_symmetries/operator_permutation.cc	/^bool OperatorPermutation::identity() const{$/;"	f	class:OperatorPermutation
identity	structural_symmetries/permutation.cc	/^bool Permutation::identity() const{$/;"	f	class:Permutation
immediate_operators	successor_generator.cc	/^    list<OperatorProxy> immediate_operators;$/;"	m	class:GeneratorSwitch	file:
in_best_path	bliss/graph.cc	/^  bool in_best_path;$/;"	m	class:bliss::TreeNode	file:
in_bounds	utils/collections.h	/^bool in_bounds(int index, const T &container) {$/;"	f	namespace:utils
in_bounds	utils/collections.h	/^bool in_bounds(size_t index, const T &container) {$/;"	f	namespace:utils
in_goal	landmarks/landmark_graph.h	/^    bool in_goal;$/;"	m	class:landmarks::EdgeType::LandmarkNode
in_neighbour_heap	bliss/partition.h	/^    bool in_neighbour_heap;$/;"	m	class:bliss::Partition::Cell
in_orbit	bliss/orbit.h	/^  OrbitEntry **in_orbit;$/;"	m	class:bliss::Orbit
in_pos	bliss/partition.h	/^  unsigned int **in_pos;$/;"	m	class:bliss::Partition
in_search	bliss/graph.h	/^  bool in_search;$/;"	m	class:bliss::AbstractGraph
in_splitting_queue	bliss/partition.h	/^    bool in_splitting_queue;$/;"	m	class:bliss::Partition::Cell
inc_dead_ends	search_statistics.h	/^    void inc_dead_ends(int inc = 1) {dead_end_states += inc; }$/;"	f	class:SearchStatistics
inc_evaluated_states	search_statistics.h	/^    void inc_evaluated_states(int inc = 1) {evaluated_states += inc; }$/;"	f	class:SearchStatistics
inc_evaluations	search_statistics.h	/^    void inc_evaluations(int inc = 1) {evaluations += inc; }$/;"	f	class:SearchStatistics
inc_expanded	search_statistics.h	/^    void inc_expanded(int inc = 1) {expanded_states += inc; }$/;"	f	class:SearchStatistics
inc_generated	search_statistics.h	/^    void inc_generated(int inc = 1) {generated_states += inc; }$/;"	f	class:SearchStatistics
inc_generated_ops	search_statistics.h	/^    void inc_generated_ops(int inc = 1) {generated_ops += inc; }$/;"	f	class:SearchStatistics
inc_reopened	search_statistics.h	/^    void inc_reopened(int inc = 1) {reopened_states += inc; }$/;"	f	class:SearchStatistics
includes	cegar/abstract_state.cc	/^bool AbstractState::includes(const State &concrete_state) const {$/;"	f	class:cegar::AbstractState
incoming_transition	cegar/abstract_state.h	/^    Transition incoming_transition;$/;"	m	class:cegar::AbstractSearchInfo
incoming_transitions	cegar/abstract_state.h	/^    Transitions incoming_transitions;$/;"	m	class:cegar::AbstractState
incorporated_variables	merge_and_shrink/fts_factory.cc	/^        vector<int> incorporated_variables;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
incorporated_variables	merge_and_shrink/transition_system.h	/^    std::vector<int> incorporated_variables;$/;"	m	class:merge_and_shrink::TransitionSystem
increase_cost	heuristics/additive_heuristic.h	/^    void increase_cost(int &cost, int amount) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
increase_cost	landmarks/exploration.cc	/^void Exploration::increase_cost(int &cost, int amount) {$/;"	f	class:landmarks::Exploration
increase_h_value_to	cegar/refinement_hierarchy.h	/^    void increase_h_value_to(int new_h) {$/;"	f	class:cegar::Node
indegree_invariant	bliss/graph.cc	/^Digraph::indegree_invariant(const Digraph* const g, const unsigned int vnum)$/;"	f	class:bliss::Digraph
index	ext/tree.hh	/^unsigned int tree<T, tree_node_allocator>::index(sibling_iterator it) const$/;"	f	class:tree
index	global_operator.h	/^	int index;$/;"	m	class:GlobalOperator
index	landmarks/landmark_factory_h_m.h	/^    int index;$/;"	m	struct:landmarks::PMOp
index	task_proxy.h	/^    int index;$/;"	m	class:OperatorProxy
indices	lp/lp_solver.h	/^    std::vector<int> indices;$/;"	m	class:lp::LPSolver
individualize	bliss/partition.cc	/^Partition::individualize(Partition::Cell * const cell,$/;"	f	class:bliss::Partition
info	search_space.h	/^    SearchNodeInfo &info;$/;"	m	class:SearchNode
info_bytes	search_node_info.cc	/^static const int info_bytes = 3 * sizeof(int) + sizeof(StateID);$/;"	v	file:
information_is_valid	pdbs/pattern_collection_information.cc	/^bool PatternCollectionInformation::information_is_valid() const {$/;"	f	class:pdbs::PatternCollectionInformation
init	bliss/heap.cc	/^void Heap::init(const unsigned int size)$/;"	f	class:bliss::Heap
init	bliss/kqueue.h	/^void KQueue<Type>::init(const unsigned int k)$/;"	f	class:bliss::KQueue
init	bliss/kstack.h	/^void KStack<Type>::init(int k)$/;"	f	class:bliss::KStack
init	bliss/orbit.cc	/^void Orbit::init(const unsigned int n)$/;"	f	class:bliss::Orbit
init	bliss/partition.cc	/^void Partition::init(const unsigned int M)$/;"	f	class:bliss::Partition
init	cegar/abstraction.h	/^    AbstractState *init;$/;"	m	class:cegar::Abstraction
init_distances	merge_and_shrink/distances.h	/^    std::vector<int> init_distances;$/;"	m	class:merge_and_shrink::Distances
init_hm_table	heuristics/hm_heuristic.cc	/^void HMHeuristic::init_hm_table(const Tuple &t) {$/;"	f	class:hm_heuristic::HMHeuristic
init_state	merge_and_shrink/fts_factory.cc	/^        int init_state;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
init_state	merge_and_shrink/transition_system.h	/^    int init_state;$/;"	m	class:merge_and_shrink::TransitionSystem
initial_state_data	state_registry.h	/^    const std::vector<int> &initial_state_data;$/;"	m	class:StateRegistry
initial_state_values	tasks/domain_abstracted_task.h	/^    const std::vector<int> initial_state_values;$/;"	m	class:extra_tasks::DomainAbstractedTask
initial_state_values	tasks/domain_abstracted_task_factory.cc	/^    vector<int> initial_state_values;$/;"	m	class:extra_tasks::DomainAbstractedTaskFactory	file:
initial_state_values	tasks/plan_forbid_reformulated_task.h	/^	std::vector<int> initial_state_values;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
initialize	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::initialize(const TaskProxy &task_proxy) {$/;"	f	class:landmarks::LandmarkFactoryHM
initialize	merge_and_shrink/label_reduction.cc	/^void LabelReduction::initialize(const TaskProxy &task_proxy) {$/;"	f	class:merge_and_shrink::LabelReduction
initialize	merge_and_shrink/merge_scoring_function.h	/^    virtual void initialize(const TaskProxy &) {$/;"	f	class:merge_and_shrink::MergeScoringFunction
initialize	merge_and_shrink/merge_scoring_function_total_order.cc	/^void MergeScoringFunctionTotalOrder::initialize(const TaskProxy &task_proxy) {$/;"	f	class:merge_and_shrink::MergeScoringFunctionTotalOrder
initialize	merge_and_shrink/merge_selector_score_based_filtering.cc	/^void MergeSelectorScoreBasedFiltering::initialize(const TaskProxy &task_proxy) {$/;"	f	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
initialize	pdbs/match_tree.cc	/^void MatchTree::Node::initialize(int var_id_, int var_domain_size_) {$/;"	f	class:pdbs::MatchTree::Node
initialize	potentials/potential_optimizer.cc	/^void PotentialOptimizer::initialize() {$/;"	f	class:potentials::PotentialOptimizer
initialize	pruning/null_pruning_method.cc	/^void NullPruningMethod::initialize(const shared_ptr<AbstractTask> &task) {$/;"	f	class:null_pruning_method::NullPruningMethod
initialize	pruning/stubborn_sets.cc	/^void StubbornSets::initialize(const shared_ptr<AbstractTask> &task) {$/;"	f	class:stubborn_sets::StubbornSets
initialize	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::initialize(const shared_ptr<AbstractTask> &task) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
initialize	pruning/stubborn_sets_simple.cc	/^void StubbornSetsSimple::initialize(const shared_ptr<AbstractTask> &task) {$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
initialize	pruning_method.cc	/^void PruningMethod::initialize(const shared_ptr<AbstractTask> &task_) {$/;"	f	class:PruningMethod
initialize	search_engine.h	/^    virtual void initialize() {}$/;"	f	class:SearchEngine
initialize	search_engines/eager_search.cc	/^void EagerSearch::initialize() {$/;"	f	class:eager_search::EagerSearch
initialize	search_engines/enforced_hill_climbing_search.cc	/^void EnforcedHillClimbingSearch::initialize() {$/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
initialize	search_engines/lazy_search.cc	/^void LazySearch::initialize() {$/;"	f	class:lazy_search::LazySearch
initialize	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::initialize() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
initialize	tasks/domain_abstracted_task_factory.cc	/^void DomainAbstractedTaskFactory::initialize(const AbstractTask &parent) {$/;"	f	class:extra_tasks::DomainAbstractedTaskFactory
initialize_certificate	bliss/graph.cc	/^Digraph::initialize_certificate()$/;"	f	class:bliss::Digraph
initialize_certificate	bliss/graph.cc	/^Graph::initialize_certificate()$/;"	f	class:bliss::Graph
initialize_constraints	operator_counting/constraint_generator.cc	/^void ConstraintGenerator::initialize_constraints($/;"	f	class:operator_counting::ConstraintGenerator
initialize_constraints	operator_counting/lm_cut_constraints.cc	/^void LMCutConstraints::initialize_constraints($/;"	f	class:operator_counting::LMCutConstraints
initialize_constraints	operator_counting/pho_constraints.cc	/^void PhOConstraints::initialize_constraints($/;"	f	class:operator_counting::PhOConstraints
initialize_constraints	operator_counting/state_equation_constraints.cc	/^void StateEquationConstraints::initialize_constraints($/;"	f	class:operator_counting::StateEquationConstraints
initialize_groups	merge_and_shrink/shrink_bisimulation.cc	/^int ShrinkBisimulation::initialize_groups(const FactoredTransitionSystem &fts,$/;"	f	class:merge_and_shrink::ShrinkBisimulation
initialize_heap	heuristics/cea_heuristic.cc	/^inline void ContextEnhancedAdditiveHeuristic::initialize_heap() {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
initialize_index_structures	domain_transition_graph.cc	/^void DTGFactory::initialize_index_structures(int num_dtgs) {$/;"	f	class:DTGFactory
initialize_stubborn_set	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::initialize_stubborn_set(const State &state) {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
initialize_stubborn_set	pruning/stubborn_sets_simple.cc	/^void StubbornSetsSimple::initialize_stubborn_set(const State &state) {$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
initialize_transition_system_data	merge_and_shrink/fts_factory.cc	/^void FTSFactory::initialize_transition_system_data(const Labels &labels) {$/;"	f	class:merge_and_shrink::FTSFactory
initialized	merge_and_shrink/label_reduction.cc	/^bool LabelReduction::initialized() const {$/;"	f	class:merge_and_shrink::LabelReduction
initialized	merge_and_shrink/merge_scoring_function.h	/^    bool initialized;$/;"	m	class:merge_and_shrink::MergeScoringFunction
initialized	structural_symmetries/group.h	/^    bool initialized;$/;"	m	class:Group
inorder	merge_and_shrink/merge_tree.cc	/^void MergeTreeNode::inorder(int offset, int current_indentation) const {$/;"	f	class:merge_and_shrink::MergeTreeNode
inorder_traversal	merge_and_shrink/merge_tree.cc	/^void MergeTree::inorder_traversal(int indentation_offset) const {$/;"	f	class:merge_and_shrink::MergeTree
insert	algorithms/equivalence_relation.cc	/^ElementListIter Block::insert(int element) {$/;"	f	class:equivalence_relation::Block
insert	algorithms/ordered_set.h	/^    void insert(const T &item) {$/;"	f	class:ordered_set::OrderedSet
insert	bliss/heap.cc	/^void Heap::insert(const unsigned int v)$/;"	f	class:bliss::Heap
insert	ext/tree.hh	/^iter tree<T, tree_node_allocator>::insert(iter position, const T& x)$/;"	f	class:tree
insert	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)$/;"	f	class:tree
insert	lp/lp_solver.cc	/^void LPConstraint::insert(int index, double coefficient) {$/;"	f	class:lp::LPConstraint
insert	merge_and_shrink/label_equivalence_relation.h	/^    LabelIter insert(int label) {$/;"	f	class:merge_and_shrink::LabelGroup
insert	open_lists/open_list.h	/^void OpenList<Entry>::insert($/;"	f	class:OpenList
insert	options/registries.cc	/^void PluginTypeRegistry::insert(const PluginTypeInfo &info) {$/;"	f	class:options::PluginTypeRegistry
insert	options/registries.h	/^    void insert(const std::string &k, Factory f) {$/;"	f	class:options::Registry
insert	pdbs/match_tree.cc	/^void MatchTree::insert(const AbstractOperator &op) {$/;"	f	class:pdbs::MatchTree
insert_after	ext/tree.hh	/^iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)$/;"	f	class:tree
insert_id_or_pop_state	state_registry.cc	/^StateID StateRegistry::insert_id_or_pop_state() {$/;"	f	class:StateRegistry
insert_id_or_pop_state_dks	state_registry.cc	/^StateID StateRegistry::insert_id_or_pop_state_dks() {$/;"	f	class:StateRegistry
insert_into	landmarks/landmark_factory_h_m.cc	/^void insert_into(list<T> &alist, const T &val) {$/;"	f	namespace:landmarks
insert_recursive	pdbs/match_tree.cc	/^void MatchTree::insert_recursive($/;"	f	class:pdbs::MatchTree
insert_subtree	ext/tree.hh	/^iter tree<T, tree_node_allocator>::insert_subtree(iter position, const iterator_base& subtree)$/;"	f	class:tree
insert_subtree_after	ext/tree.hh	/^iter tree<T, tree_node_allocator>::insert_subtree_after(iter position, const iterator_base& subtree)$/;"	f	class:tree
insert_successor_into_open_list	search_engines/enforced_hill_climbing_search.cc	/^void EnforcedHillClimbingSearch::insert_successor_into_open_list($/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
instance	options/doc_store.h	/^    static DocStore *instance() {$/;"	f	class:options::DocStore
instance	options/predefinitions.h	/^    static Predefinitions<T> *instance() {$/;"	f	class:options::Predefinitions
instance	options/registries.cc	/^PluginTypeRegistry *PluginTypeRegistry::instance() {$/;"	f	class:options::PluginTypeRegistry
instance	options/registries.h	/^    static Registry<T> *instance() {$/;"	f	class:options::Registry
int_packer	algorithms/int_packer.cc	/^namespace int_packer {$/;"	n	file:
int_packer	algorithms/int_packer.h	/^namespace int_packer {$/;"	n
int_packer	axioms.h	/^namespace int_packer {$/;"	n
int_packer	globals.h	/^namespace int_packer {$/;"	n
int_sets	causal_graph.cc	/^    vector<IntSet> int_sets;$/;"	m	class:IntRelationBuilder	file:
interesting	landmarks/landmark_factory_h_m.cc	/^bool LandmarkFactoryHM::interesting(const VariablesProxy &variables,$/;"	f	class:landmarks::LandmarkFactoryHM
interfere	pruning/stubborn_sets_simple.h	/^    inline bool interfere(int op1_no, int op2_no) {$/;"	f	class:stubborn_sets_simple::StubbornSetsSimple
interference_relation	pruning/stubborn_sets_simple.h	/^    std::vector<std::vector<int>> interference_relation;$/;"	m	class:stubborn_sets_simple::StubbornSetsSimple
interferes	landmarks/landmark_factory.cc	/^bool LandmarkFactory::interferes(const TaskProxy &task_proxy,$/;"	f	class:landmarks::LandmarkFactory
interrupt	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::interrupt() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
interrupt_immediatly	search_engines/top_k_eager_search.h	/^	bool interrupt_immediatly = false;$/;"	m	struct:top_k_eager_search::SearchControl
interrupt_search	search_engines/top_k_eager_search.h	/^	bool interrupt_search;$/;"	m	class:top_k_eager_search::TopKEagerSearch
intersect_with	landmarks/landmark_factory_h_m.cc	/^void intersect_with(list<T> &alist, const list<T> &other) {$/;"	f	namespace:landmarks
intersects	algorithms/dynamic_bitset.h	/^    bool intersects(const DynamicBitset &other) const {$/;"	f	class:dynamic_bitset::DynamicBitset
intersects	cegar/domains.cc	/^bool Domains::intersects(const Domains &other, int var) const {$/;"	f	class:cegar::Domains
invariant_values	bliss/partition.h	/^  unsigned int *invariant_values;$/;"	m	class:bliss::Partition
is_active	merge_and_shrink/factored_transition_system.h	/^    bool is_active(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
is_an_axiom	global_operator.h	/^    bool is_an_axiom;$/;"	m	class:GlobalOperator
is_an_axiom	task_proxy.h	/^    bool is_an_axiom;$/;"	m	class:OperatorProxy
is_applicable	global_operator.h	/^    bool is_applicable(const GlobalState &state) const {$/;"	f	class:GlobalOperator
is_applicable	global_operator.h	/^    bool is_applicable(const GlobalState &state) const {$/;"	f	struct:GlobalCondition
is_applicable	pruning/stubborn_sets_ec.cc	/^bool StubbornSetsEC::is_applicable(int op_no, const State &state) const {$/;"	f	class:stubborn_sets_ec::StubbornSetsEC
is_applicable	task_tools.h	/^inline bool is_applicable(OperatorProxy op, const State &state) {$/;"	f
is_automorphism	bliss/graph.cc	/^AbstractGraph::is_automorphism(const std::vector<unsigned int>& perm) const$/;"	f	class:bliss::AbstractGraph
is_automorphism	bliss/graph.cc	/^AbstractGraph::is_automorphism(unsigned int* const perm)$/;"	f	class:bliss::AbstractGraph
is_automorphism	bliss/graph.cc	/^Digraph::is_automorphism(const std::vector<unsigned int>& perm) const$/;"	f	class:bliss::Digraph
is_automorphism	bliss/graph.cc	/^Digraph::is_automorphism(unsigned int* const perm)$/;"	f	class:bliss::Digraph
is_automorphism	bliss/graph.cc	/^Graph::is_automorphism(const std::vector<unsigned int>& perm) const$/;"	f	class:bliss::Graph
is_automorphism	bliss/graph.cc	/^Graph::is_automorphism(unsigned int* const perm)$/;"	f	class:bliss::Graph
is_axiom	domain_transition_graph.h	/^    bool is_axiom;$/;"	m	struct:ValueTransitionLabel
is_axiom	global_operator.h	/^    bool is_axiom() const {return is_an_axiom; }$/;"	f	class:GlobalOperator
is_axiom	task_proxy.h	/^    bool is_axiom() const {$/;"	f	class:OperatorProxy
is_axiom	task_proxy.h	/^    bool is_axiom;$/;"	m	class:EffectConditionsProxy
is_axiom	task_proxy.h	/^    bool is_axiom;$/;"	m	class:EffectProxy
is_axiom	task_proxy.h	/^    bool is_axiom;$/;"	m	class:EffectsProxy
is_axiom	task_proxy.h	/^    bool is_axiom;$/;"	m	class:PreconditionsProxy
is_cached	heuristics/cg_cache.h	/^    bool is_cached(int var) const {$/;"	f	class:cg_heuristic::CGCache
is_call	options/doc_printer.cc	/^static bool is_call(string s) {$/;"	f	namespace:options
is_causal_landmark	landmarks/landmark_factory.cc	/^bool LandmarkFactory::is_causal_landmark(const TaskProxy &task_proxy, Exploration &exploration,$/;"	f	class:landmarks::LandmarkFactory
is_causal_predecessor	variable_order_finder.h	/^    std::vector<bool> is_causal_predecessor;$/;"	m	class:VariableOrderFinder
is_closed	search_space.cc	/^bool SearchNode::is_closed() const {$/;"	f	class:SearchNode
is_component_valid	merge_and_shrink/factored_transition_system.cc	/^bool FactoredTransitionSystem::is_component_valid(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
is_current_label	merge_and_shrink/labels.cc	/^bool Labels::is_current_label(int label_no) const {$/;"	f	class:merge_and_shrink::Labels
is_dead_end	open_lists/alternation_open_list.cc	/^bool AlternationOpenList<Entry>::is_dead_end($/;"	f	class:AlternationOpenList
is_dead_end	open_lists/epsilon_greedy_open_list.cc	/^bool EpsilonGreedyOpenList<Entry>::is_dead_end($/;"	f	class:EpsilonGreedyOpenList
is_dead_end	open_lists/pareto_open_list.cc	/^bool ParetoOpenList<Entry>::is_dead_end($/;"	f	class:ParetoOpenList
is_dead_end	open_lists/standard_scalar_open_list.cc	/^bool StandardScalarOpenList<Entry>::is_dead_end($/;"	f	class:StandardScalarOpenList
is_dead_end	open_lists/tiebreaking_open_list.cc	/^bool TieBreakingOpenList<Entry>::is_dead_end($/;"	f	class:TieBreakingOpenList
is_dead_end	open_lists/type_based_open_list.cc	/^bool TypeBasedOpenList<Entry>::is_dead_end($/;"	f	class:TypeBasedOpenList
is_dead_end	pdbs/incremental_canonical_pdbs.cc	/^bool IncrementalCanonicalPDBs::is_dead_end(const State &state) const {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
is_dead_end	search_space.cc	/^bool SearchNode::is_dead_end() const {$/;"	f	class:SearchNode
is_derived	landmarks/landmark_graph.h	/^    bool is_derived;$/;"	m	class:landmarks::EdgeType::LandmarkNode
is_derived	task_proxy.h	/^    bool is_derived() const {$/;"	f	class:VariableProxy
is_discrete	bliss/partition.h	/^  bool is_discrete() const {return(free_cells == 0); }$/;"	f	class:bliss::Partition
is_empty	bliss/heap.h	/^  bool is_empty() const {return(n==0); }$/;"	f	class:bliss::Heap
is_empty	bliss/kqueue.h	/^bool KQueue<Type>::is_empty() const$/;"	f	class:bliss::KQueue
is_empty	bliss/kstack.h	/^  bool is_empty() const {return(cursor == entries); }$/;"	f	class:bliss::KStack
is_empty_group	merge_and_shrink/label_equivalence_relation.h	/^    bool is_empty_group(int group_id) const {$/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
is_equal	bliss/uintseqhash.h	/^  bool is_equal(const UintSeqHash &other) const {return(cmp(other) == 0); }$/;"	f	class:bliss::UintSeqHash
is_equitable	bliss/graph.cc	/^Digraph::is_equitable() const$/;"	f	class:bliss::Digraph
is_equitable	bliss/graph.cc	/^bool Graph::is_equitable() const$/;"	f	class:bliss::Graph
is_exit_code_error_reentrant	utils/system.cc	/^bool is_exit_code_error_reentrant(ExitCode exitcode) {$/;"	f	namespace:utils
is_expired	utils/countdown_timer.cc	/^bool CountdownTimer::is_expired() const {$/;"	f	class:utils::CountdownTimer
is_goal	cegar/abstraction.cc	/^bool Abstraction::is_goal(AbstractState *state) const {$/;"	f	class:cegar::Abstraction
is_goal	heuristics/relaxation_heuristic.h	/^    bool is_goal;$/;"	m	struct:relaxation_heuristic::Proposition
is_goal	landmarks/landmark_graph.h	/^    bool is_goal() const {$/;"	f	class:landmarks::EdgeType::LandmarkNode
is_goal_condition	landmarks/exploration.h	/^    bool is_goal_condition;$/;"	m	struct:landmarks::ExProposition
is_goal_relevant	merge_and_shrink/utils.cc	/^bool is_goal_relevant(const TransitionSystem &ts) {$/;"	f	namespace:merge_and_shrink
is_goal_state	merge_and_shrink/transition_system.h	/^    bool is_goal_state(int state) const {$/;"	f	class:merge_and_shrink::TransitionSystem
is_goal_state	pdbs/pattern_database.cc	/^bool PatternDatabase::is_goal_state($/;"	f	class:pdbs::PatternDatabase
is_goal_state	task_tools.h	/^inline bool is_goal_state(TaskProxy task, const State &state) {$/;"	f
is_goal_variable	variable_order_finder.h	/^    std::vector<bool> is_goal_variable;$/;"	m	class:VariableOrderFinder
is_h_dirty	heuristic.h	/^    bool is_h_dirty(GlobalState &state) {$/;"	f	class:Heuristic
is_heuristic_improved	pdbs/pattern_collection_generator_hillclimbing.cc	/^bool PatternCollectionGeneratorHillclimbing::is_heuristic_improved($/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
is_heuristic_infinite	evaluation_context.cc	/^bool EvaluationContext::is_heuristic_infinite(ScalarEvaluator *heur) {$/;"	f	class:EvaluationContext
is_in_splitting_queue	bliss/partition.h	/^    bool is_in_splitting_queue() const {return(in_splitting_queue); }$/;"	f	class:bliss::Partition::Cell
is_in_subtree	ext/tree.hh	/^bool tree<T, tree_node_allocator>::is_in_subtree(const iterator_base& it, const iterator_base& begin, $/;"	f	class:tree
is_index_valid	merge_and_shrink/factored_transition_system.cc	/^bool FactoredTransitionSystem::is_index_valid(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
is_induced_by_axiom	landmarks/exploration.h	/^    bool is_induced_by_axiom(const TaskProxy &task_proxy) const {$/;"	f	struct:landmarks::ExUnaryOperator
is_infinite	evaluation_result.cc	/^bool EvaluationResult::is_infinite() const {$/;"	f	class:EvaluationResult
is_initialized	lp/lp_solver.h	/^    bool is_initialized;$/;"	m	class:lp::LPSolver
is_initialized	structural_symmetries/group.h	/^    bool is_initialized() const {$/;"	f	class:Group
is_landmark	landmarks/exploration.cc	/^static bool is_landmark(vector<FactPair> &landmarks, const FactPair &fact) {$/;"	f	namespace:landmarks
is_landmark_precondition	landmarks/landmark_factory.cc	/^bool LandmarkFactory::is_landmark_precondition(const OperatorProxy &op,$/;"	f	class:landmarks::LandmarkFactory
is_le	bliss/uintseqhash.h	/^  bool is_le(const UintSeqHash &other) const {return(cmp(other) <= 0); }$/;"	f	class:bliss::UintSeqHash
is_leaf	merge_and_shrink/merge_tree.h	/^    bool is_leaf() const {$/;"	f	struct:merge_and_shrink::MergeTreeNode
is_leaf_node	pdbs/match_tree.cc	/^bool MatchTree::Node::is_leaf_node() const {$/;"	f	class:pdbs::MatchTree::Node
is_local_problem_set_up	heuristics/cea_heuristic.cc	/^bool ContextEnhancedAdditiveHeuristic::is_local_problem_set_up($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
is_lt	bliss/uintseqhash.h	/^  bool is_lt(const UintSeqHash &other) const {return(cmp(other) < 0); }$/;"	f	class:bliss::UintSeqHash
is_minimal_representative	bliss/orbit.cc	/^bool Orbit::is_minimal_representative(unsigned int element) const$/;"	f	class:bliss::Orbit
is_more_general_than	cegar/abstract_state.cc	/^bool AbstractState::is_more_general_than(const AbstractState &other) const {$/;"	f	class:cegar::AbstractState
is_mutex	task_proxy.h	/^    bool is_mutex(const FactProxy &other) const {$/;"	f	class:FactProxy
is_new	search_space.cc	/^bool SearchNode::is_new() const {$/;"	f	class:SearchNode
is_nondominated	open_lists/pareto_open_list.cc	/^bool ParetoOpenList<Entry>::is_nondominated($/;"	f	class:ParetoOpenList
is_op_affected	structural_symmetries/operator_permutation.h	/^    std::vector<bool> is_op_affected;$/;"	m	class:OperatorPermutation
is_open	search_space.cc	/^bool SearchNode::is_open() const {$/;"	f	class:SearchNode
is_operator_on_plan	tasks/plan_forbid_reformulated_task.cc	/^bool PlanForbidReformulatedTask::is_operator_on_plan(int op_no) const {$/;"	f	class:extra_tasks::PlanForbidReformulatedTask
is_operator_relevant	pdbs/pattern_database.cc	/^bool PatternDatabase::is_operator_relevant(const OperatorProxy &op) const {$/;"	f	class:pdbs::PatternDatabase
is_pattern_too_large	pdbs/pattern_collection_generator_genetic.cc	/^bool PatternCollectionGeneratorGenetic::is_pattern_too_large($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
is_permutation	bliss/utils.cc	/^is_permutation(const std::vector<unsigned int>& perm)$/;"	f	namespace:bliss
is_permutation	bliss/utils.cc	/^is_permutation(const unsigned int N, const unsigned int* perm)$/;"	f	namespace:bliss
is_preferred	evaluation_context.cc	/^bool EvaluationContext::is_preferred() const {$/;"	f	class:EvaluationContext
is_product_within_limit	utils/math.cc	/^bool is_product_within_limit(int factor1, int factor2, int limit) {$/;"	f	namespace:utils
is_relevant	merge_and_shrink/fts_factory.cc	/^bool FTSFactory::is_relevant(int var_no, int label_no) const {$/;"	f	class:merge_and_shrink::FTSFactory
is_reliable_dead_end	open_lists/alternation_open_list.cc	/^bool AlternationOpenList<Entry>::is_reliable_dead_end($/;"	f	class:AlternationOpenList
is_reliable_dead_end	open_lists/epsilon_greedy_open_list.cc	/^bool EpsilonGreedyOpenList<Entry>::is_reliable_dead_end($/;"	f	class:EpsilonGreedyOpenList
is_reliable_dead_end	open_lists/pareto_open_list.cc	/^bool ParetoOpenList<Entry>::is_reliable_dead_end($/;"	f	class:ParetoOpenList
is_reliable_dead_end	open_lists/standard_scalar_open_list.cc	/^bool StandardScalarOpenList<Entry>::is_reliable_dead_end($/;"	f	class:StandardScalarOpenList
is_reliable_dead_end	open_lists/tiebreaking_open_list.cc	/^bool TieBreakingOpenList<Entry>::is_reliable_dead_end($/;"	f	class:TieBreakingOpenList
is_reliable_dead_end	open_lists/type_based_open_list.cc	/^bool TypeBasedOpenList<Entry>::is_reliable_dead_end($/;"	f	class:TypeBasedOpenList
is_solvable	merge_and_shrink/factored_transition_system.h	/^    bool is_solvable() const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
is_solvable	merge_and_shrink/transition_system.cc	/^bool TransitionSystem::is_solvable() const {$/;"	f	class:merge_and_shrink::TransitionSystem
is_solved	lp/lp_solver.h	/^    bool is_solved;$/;"	m	class:lp::LPSolver
is_sorted_unique	utils/collections.h	/^extern bool is_sorted_unique(const std::vector<T> &values) {$/;"	f	namespace:utils
is_split	cegar/refinement_hierarchy.h	/^    bool is_split() const {$/;"	f	class:cegar::Node
is_stabilizing_initial_state	structural_symmetries/group.h	/^    bool is_stabilizing_initial_state() const {$/;"	f	class:Group
is_subset	utils/util.h	/^bool is_subset(std::set<T>&v1, std::set<T>&v2) {$/;"	f
is_subset_of	algorithms/dynamic_bitset.h	/^    bool is_subset_of(const DynamicBitset &other) const {$/;"	f	class:dynamic_bitset::DynamicBitset
is_superset_of	cegar/domains.cc	/^bool Domains::is_superset_of(const Domains &other) const {$/;"	f	class:cegar::Domains
is_termination_condition	landmarks/exploration.h	/^    bool is_termination_condition;$/;"	m	struct:landmarks::ExProposition
is_true_in_state	landmarks/landmark_graph.h	/^    bool is_true_in_state(const GlobalState &global_state) const {$/;"	f	class:landmarks::EdgeType::LandmarkNode
is_true_in_state	landmarks/landmark_graph.h	/^    bool is_true_in_state(const State &state) const {$/;"	f	class:landmarks::EdgeType::LandmarkNode
is_uninitialized	evaluation_result.cc	/^bool EvaluationResult::is_uninitialized() const {$/;"	f	class:EvaluationResult
is_unit	bliss/partition.h	/^    bool is_unit() const {return(length == 1); }$/;"	f	class:bliss::Partition::Cell
is_unit_cost	globals.cc	/^bool is_unit_cost() {$/;"	f
is_unit_cost	merge_and_shrink/distances.cc	/^bool Distances::is_unit_cost() const {$/;"	f	class:merge_and_shrink::Distances
is_unit_cost	task_tools.cc	/^bool is_unit_cost(TaskProxy task) {$/;"	f
is_unit_cost	tasks/cost_adapted_task.h	/^    const bool is_unit_cost;$/;"	m	class:tasks::CostAdaptedTask
is_v_applicable	pruning/stubborn_sets_ec.cc	/^static inline bool is_v_applicable(int var,$/;"	f	namespace:stubborn_sets_ec
is_valid	ext/tree.hh	/^bool tree<T, tree_node_allocator>::is_valid(const iterator_base& it) const$/;"	f	class:tree
is_valid_option	options/option_parser.cc	/^bool OptionParser::is_valid_option(const string &k) const {$/;"	f	class:options::OptionParser
it_intersection_block	algorithms/equivalence_relation.h	/^    BlockListIter it_intersection_block;$/;"	m	class:equivalence_relation::Block
iterated_found_solution	search_engines/iterated_search.h	/^    bool iterated_found_solution;$/;"	m	class:iterated_search::IteratedSearch
iterated_search	search_engines/iterated_search.cc	/^namespace iterated_search {$/;"	n	file:
iterated_search	search_engines/iterated_search.h	/^namespace iterated_search {$/;"	n
iterator	ext/tree.hh	/^		typedef pre_order_iterator            iterator;$/;"	t	class:tree
iterator_base	ext/tree.hh	/^		class iterator_base : public stlport::bidirectional_iterator<T, ptrdiff_t> {$/;"	c	class:tree
iterator_base	ext/tree.hh	/^tree<T, tree_node_allocator>::iterator_base::iterator_base()$/;"	f	class:tree::iterator_base
iterator_base	ext/tree.hh	/^tree<T, tree_node_allocator>::iterator_base::iterator_base(tree_node *tn)$/;"	f	class:tree::iterator_base
iterator_base_less	ext/tree.hh	/^		class iterator_base_less {$/;"	c	class:tree
iterator_category	ext/tree.hh	/^				typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:tree::iterator_base
kapacity	bliss/kstack.h	/^  int kapacity;$/;"	m	class:bliss::KStack
keep_operator_symmetries	structural_symmetries/group.h	/^    bool keep_operator_symmetries;$/;"	m	class:Group
key	options/parse_tree.h	/^    std::string key;$/;"	m	struct:options::ParseNode
key_to_bucket_index	open_lists/type_based_open_list.cc	/^    unordered_map<Key, int> key_to_bucket_index;$/;"	m	class:TypeBasedOpenList	file:
kp	ext/tree.hh	/^namespace kp {$/;"	n
kptree	ext/tree_util.hh	/^namespace kptree {$/;"	n
kstar	search_engines/kstar.cc	/^namespace kstar{$/;"	n	file:
kstar	search_engines/kstar.h	/^namespace kstar {$/;"	n
kwd	options/doc_store.h	/^    std::string kwd;$/;"	m	struct:options::ArgumentInfo
label	heuristics/cea_heuristic.cc	/^    const ValueTransitionLabel *label;$/;"	m	struct:cea_heuristic::LocalTransition	file:
label_equivalence_relation	merge_and_shrink/fts_factory.cc	/^        unique_ptr<LabelEquivalenceRelation> label_equivalence_relation;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
label_equivalence_relation	merge_and_shrink/transition_system.h	/^    const LabelEquivalenceRelation &label_equivalence_relation;$/;"	m	class:merge_and_shrink::TSConstIterator
label_equivalence_relation	merge_and_shrink/transition_system.h	/^    std::unique_ptr<LabelEquivalenceRelation> label_equivalence_relation;$/;"	m	class:merge_and_shrink::TransitionSystem
label_group	merge_and_shrink/transition_system.h	/^    const LabelGroup &label_group;$/;"	m	struct:merge_and_shrink::GroupAndTransitions
label_reduction	merge_and_shrink/merge_and_shrink_heuristic.h	/^    std::shared_ptr<LabelReduction> label_reduction;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
label_to_positions	merge_and_shrink/label_equivalence_relation.h	/^    std::vector<std::pair<int, LabelIter>> label_to_positions;$/;"	m	class:merge_and_shrink::LabelEquivalenceRelation
labels	domain_transition_graph.h	/^    std::vector<ValueTransitionLabel> labels;$/;"	m	struct:ValueTransition
labels	landmarks/landmark_factory_zhu_givan.h	/^        lm_set labels;$/;"	m	class:landmarks::LandmarkFactoryZhuGivan::plan_graph_node
labels	merge_and_shrink/factored_transition_system.h	/^    std::unique_ptr<Labels> labels;$/;"	m	class:merge_and_shrink::FactoredTransitionSystem
labels	merge_and_shrink/label_equivalence_relation.h	/^    const Labels &labels;$/;"	m	class:merge_and_shrink::LabelEquivalenceRelation
labels	merge_and_shrink/label_equivalence_relation.h	/^    std::list<int> labels;$/;"	m	class:merge_and_shrink::LabelGroup
labels	merge_and_shrink/labels.h	/^    std::vector<std::unique_ptr<Label>> labels;$/;"	m	class:merge_and_shrink::Labels
lama_heuristic	landmarks/lama_ff_synergy.h	/^    std::unique_ptr<LandmarkCountHeuristic> lama_heuristic;$/;"	m	class:landmarks::LamaFFSynergy
lama_master_heuristic	landmarks/lama_ff_synergy.h	/^    std::unique_ptr<LamaMasterHeuristic> lama_master_heuristic;$/;"	m	class:landmarks::LamaFFSynergy
lama_notify_initial_state	landmarks/lama_ff_synergy.cc	/^void LamaFFSynergy::lama_notify_initial_state(const GlobalState &initial_state) {$/;"	f	class:landmarks::LamaFFSynergy
lama_notify_state_transition	landmarks/lama_ff_synergy.cc	/^bool LamaFFSynergy::lama_notify_state_transition($/;"	f	class:landmarks::LamaFFSynergy
lama_result	landmarks/lama_ff_synergy.h	/^    EvaluationResult lama_result;$/;"	m	class:landmarks::LamaFFSynergy
landmark_add_conjunctive	landmarks/landmark_graph.cc	/^LandmarkNode &LandmarkGraph::landmark_add_conjunctive(const set<FactPair> &lm) {$/;"	f	class:landmarks::LandmarkGraph
landmark_add_disjunctive	landmarks/landmark_graph.cc	/^LandmarkNode &LandmarkGraph::landmark_add_disjunctive(const set<FactPair> &lm) {$/;"	f	class:landmarks::LandmarkGraph
landmark_add_simple	landmarks/landmark_graph.cc	/^LandmarkNode &LandmarkGraph::landmark_add_simple(const FactPair &lm) {$/;"	f	class:landmarks::LandmarkGraph
landmark_exists	landmarks/landmark_graph.cc	/^bool LandmarkGraph::landmark_exists(const FactPair &lm) const {$/;"	f	class:landmarks::LandmarkGraph
landmark_generator	heuristics/lm_cut_heuristic.h	/^    std::unique_ptr<LandmarkCutLandmarks> landmark_generator;$/;"	m	class:lm_cut_heuristic::LandmarkCutHeuristic
landmark_generator	operator_counting/lm_cut_constraints.h	/^    std::unique_ptr<lm_cut_heuristic::LandmarkCutLandmarks> landmark_generator;$/;"	m	class:operator_counting::LMCutConstraints
landmark_is_interesting	landmarks/landmark_count_heuristic.cc	/^bool LandmarkCountHeuristic::landmark_is_interesting($/;"	f	class:landmarks::LandmarkCountHeuristic
landmark_is_leaf	landmarks/landmark_status_manager.cc	/^bool LandmarkStatusManager::landmark_is_leaf(const LandmarkNode &node,$/;"	f	class:landmarks::LandmarkStatusManager
landmark_status	landmarks/landmark_graph.h	/^enum landmark_status {lm_reached = 0, lm_not_reached = 1, lm_needed_again = 2};$/;"	g	class:landmarks::EdgeType
landmarks	cegar/subtask_generators.h	/^namespace landmarks {$/;"	n
landmarks	cegar/utils_landmarks.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/exploration.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/exploration.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/lama_ff_synergy.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/lama_ff_synergy.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_cost_assignment.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_cost_assignment.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_count_heuristic.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_count_heuristic.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_factory.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_factory.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_factory_h_m.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_factory_h_m.h	/^    std::list<int> landmarks;$/;"	m	struct:landmarks::HMEntry
landmarks	landmarks/landmark_factory_h_m.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_factory_merged.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_factory_merged.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_factory_rpg_exhaust.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_factory_rpg_exhaust.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_factory_rpg_sasp.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_factory_rpg_sasp.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_factory_zhu_givan.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_factory_zhu_givan.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_graph.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_graph.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/landmark_status_manager.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/landmark_status_manager.h	/^namespace landmarks {$/;"	n
landmarks	landmarks/util.cc	/^namespace landmarks {$/;"	n	file:
landmarks	landmarks/util.h	/^namespace landmarks {$/;"	n
landmarks	options/option_parser.cc	/^namespace landmarks {$/;"	n	file:
landmarks_cost	landmarks/landmark_graph.h	/^    int landmarks_cost;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
landmarks_count	landmarks/landmark_graph.h	/^    int landmarks_count;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
last_child	ext/tree.hh	/^	   tree_node_<T> *first_child, *last_child;$/;"	m	class:tree_node_
last_child	options/parse_tree.h	/^typename tree<T>::sibling_iterator last_child($/;"	f	namespace:options
last_child_of_root	options/parse_tree.h	/^typename tree<T>::sibling_iterator last_child_of_root(const tree<T> &tr) {$/;"	f	namespace:options
last_helpful_transition_extraction_time	domain_transition_graph.h	/^    int last_helpful_transition_extraction_time;$/;"	m	class:DomainTransitionGraph
last_jump_improving_symmetrical_states	search_statistics.h	/^    int last_jump_improving_symmetrical_states;$/;"	m	class:SearchStatistics
last_jump_symmetrical_states_generated	search_statistics.h	/^    int last_jump_symmetrical_states_generated;$/;"	m	class:SearchStatistics
last_jump_symmetry_improved_evaluations	search_statistics.h	/^    int last_jump_symmetry_improved_evaluations;$/;"	m	class:SearchStatistics
last_num_expanded	search_engines/enforced_hill_climbing_search.h	/^    int last_num_expanded;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
last_phase_found_solution	search_engines/iterated_search.h	/^    bool last_phase_found_solution;$/;"	m	class:iterated_search::IteratedSearch
last_start_clock	utils/timer.h	/^    double last_start_clock;$/;"	m	class:utils::Timer
lastjump_evaluated_states	search_statistics.h	/^    int lastjump_evaluated_states;$/;"	m	class:SearchStatistics
lastjump_expanded_states	search_statistics.h	/^    int lastjump_expanded_states; \/\/ same guy but at point where the last jump in the open list$/;"	m	class:SearchStatistics
lastjump_f_value	search_statistics.h	/^    int lastjump_f_value; \/\/f value obtained in the last jump$/;"	m	class:SearchStatistics
lastjump_generated_states	search_statistics.h	/^    int lastjump_generated_states;$/;"	m	class:SearchStatistics
lastjump_reopened_states	search_statistics.h	/^    int lastjump_reopened_states; \/\/ occurred (jump == f-value of the first node in the queue increases)$/;"	m	class:SearchStatistics
lazy_search	search_engines/lazy_search.cc	/^namespace lazy_search {$/;"	n	file:
lazy_search	search_engines/lazy_search.h	/^namespace lazy_search {$/;"	n
lcm	structural_symmetries/permutation.cc	/^int lcm(int a, int b) {$/;"	f
leaf_iterator	ext/tree.hh	/^      class leaf_iterator : public iterator_base {$/;"	c	class:tree
leaf_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator() $/;"	f	class:tree::leaf_iterator
leaf_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(const iterator_base &other)$/;"	f	class:tree::leaf_iterator
leaf_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(const sibling_iterator& other)$/;"	f	class:tree::leaf_iterator
leaf_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::leaf_iterator::leaf_iterator(tree_node *tn, tree_node *top)$/;"	f	class:tree::leaf_iterator
leave_block	utils/logging.cc	/^void MemoryTracer::leave_block(const string &block_name) {$/;"	f	class:utils::MemoryTracer
left_child	cegar/refinement_hierarchy.h	/^    Node *left_child;$/;"	m	class:cegar::Node
left_child	merge_and_shrink/merge_and_shrink_representation.h	/^    std::unique_ptr<MergeAndShrinkRepresentation> left_child;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
left_child	merge_and_shrink/merge_tree.h	/^    MergeTreeNode *left_child;$/;"	m	struct:merge_and_shrink::MergeTreeNode
length	bliss/partition.h	/^    unsigned int length;$/;"	m	class:bliss::Partition::Cell
length	structural_symmetries/permutation.cc	/^int Permutation::length;$/;"	m	class:Permutation	file:
length	structural_symmetries/permutation.h	/^    static int length;$/;"	m	class:Permutation
level	bliss/partition.h	/^    unsigned int level;$/;"	m	class:bliss::Partition::CRCell
level	landmarks/landmark_factory_h_m.h	/^    int level;$/;"	m	struct:landmarks::HMEntry
lgraph	landmarks/landmark_count_heuristic.h	/^    std::shared_ptr<LandmarkGraph> lgraph;$/;"	m	class:landmarks::LandmarkCountHeuristic
literal	axioms.h	/^        AxiomLiteral *literal;$/;"	m	struct:AxiomEvaluator::NegationByFailureInfo
lm_cost_assignment	landmarks/landmark_count_heuristic.h	/^    std::unique_ptr<LandmarkCostAssignment> lm_cost_assignment;$/;"	m	class:landmarks::LandmarkCountHeuristic
lm_cost_type	landmarks/landmark_factory.h	/^    const OperatorCost lm_cost_type;$/;"	m	class:landmarks::LandmarkFactory
lm_cut_heuristic	heuristics/lm_cut_heuristic.cc	/^namespace lm_cut_heuristic {$/;"	n	file:
lm_cut_heuristic	heuristics/lm_cut_heuristic.h	/^namespace lm_cut_heuristic {$/;"	n
lm_cut_heuristic	heuristics/lm_cut_landmarks.cc	/^namespace lm_cut_heuristic {$/;"	n	file:
lm_cut_heuristic	heuristics/lm_cut_landmarks.h	/^namespace lm_cut_heuristic {$/;"	n
lm_cut_heuristic	operator_counting/lm_cut_constraints.h	/^namespace lm_cut_heuristic {$/;"	n
lm_factories	landmarks/landmark_factory_merged.h	/^    std::vector<LandmarkFactory *> lm_factories;$/;"	m	class:landmarks::LandmarkFactoryMerged
lm_graph	landmarks/landmark_cost_assignment.h	/^    const LandmarkGraph &lm_graph;$/;"	m	class:landmarks::LandmarkCostAssignment
lm_graph	landmarks/landmark_factory.h	/^    std::shared_ptr<LandmarkGraph> lm_graph;$/;"	m	class:landmarks::LandmarkFactory
lm_graph	landmarks/landmark_status_manager.h	/^    LandmarkGraph &lm_graph;$/;"	m	class:landmarks::LandmarkStatusManager
lm_graphs	landmarks/landmark_factory_merged.h	/^    std::vector<std::shared_ptr<LandmarkGraph>> lm_graphs;$/;"	m	class:landmarks::LandmarkFactoryMerged
lm_needed_again	landmarks/landmark_graph.h	/^enum landmark_status {lm_reached = 0, lm_not_reached = 1, lm_needed_again = 2};$/;"	e	enum:landmarks::EdgeType::landmark_status
lm_node_table_	landmarks/landmark_factory_h_m.h	/^    std::map<int, LandmarkNode *> lm_node_table_;$/;"	m	class:landmarks::LandmarkFactoryHM
lm_not_reached	landmarks/landmark_graph.h	/^enum landmark_status {lm_reached = 0, lm_not_reached = 1, lm_needed_again = 2};$/;"	e	enum:landmarks::EdgeType::landmark_status
lm_reached	landmarks/landmark_graph.h	/^enum landmark_status {lm_reached = 0, lm_not_reached = 1, lm_needed_again = 2};$/;"	e	enum:landmarks::EdgeType::landmark_status
lm_status_manager	landmarks/landmark_count_heuristic.h	/^    std::unique_ptr<LandmarkStatusManager> lm_status_manager;$/;"	m	class:landmarks::LandmarkCountHeuristic
load_problem	lp/lp_solver.cc	/^void LPSolver::load_problem(LPObjectiveSense sense,$/;"	f	class:lp::LPSolver
local_problem_index	heuristics/cea_heuristic.h	/^    std::vector<std::vector<LocalProblem *>> local_problem_index;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
local_problems	heuristics/cea_heuristic.h	/^    std::vector<LocalProblem *> local_problems;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
local_to_global_child	domain_transition_graph.h	/^    std::vector<int> local_to_global_child;$/;"	m	class:DomainTransitionGraph
local_var	domain_transition_graph.h	/^    short local_var;$/;"	m	struct:LocalAssignment
long_prune_add_automorphism	bliss/graph.cc	/^AbstractGraph::long_prune_add_automorphism(const unsigned int* aut)$/;"	f	class:bliss::AbstractGraph
long_prune_allocget_fixed	bliss/graph.cc	/^AbstractGraph::long_prune_allocget_fixed(const unsigned int index)$/;"	f	class:bliss::AbstractGraph
long_prune_allocget_mcrs	bliss/graph.cc	/^AbstractGraph::long_prune_allocget_mcrs(const unsigned int index)$/;"	f	class:bliss::AbstractGraph
long_prune_begin	bliss/graph.cc	/^  unsigned int long_prune_begin;$/;"	m	class:bliss::TreeNode	file:
long_prune_begin	bliss/graph.h	/^  unsigned int long_prune_begin;$/;"	m	class:bliss::AbstractGraph
long_prune_deallocate	bliss/graph.cc	/^AbstractGraph::long_prune_deallocate()$/;"	f	class:bliss::AbstractGraph
long_prune_end	bliss/graph.h	/^  unsigned int long_prune_end;$/;"	m	class:bliss::AbstractGraph
long_prune_fixed	bliss/graph.h	/^  std::vector<std::vector<bool> *> long_prune_fixed;$/;"	m	class:bliss::AbstractGraph
long_prune_get_fixed	bliss/graph.cc	/^AbstractGraph::long_prune_get_fixed(const unsigned int index)$/;"	f	class:bliss::AbstractGraph
long_prune_get_mcrs	bliss/graph.cc	/^AbstractGraph::long_prune_get_mcrs(const unsigned int index)$/;"	f	class:bliss::AbstractGraph
long_prune_init	bliss/graph.cc	/^AbstractGraph::long_prune_init()$/;"	f	class:bliss::AbstractGraph
long_prune_max_stored_autss	bliss/graph.h	/^  unsigned int long_prune_max_stored_autss;$/;"	m	class:bliss::AbstractGraph
long_prune_mcrs	bliss/graph.h	/^  std::vector<std::vector<bool> *> long_prune_mcrs;$/;"	m	class:bliss::AbstractGraph
long_prune_options_max_mem	bliss/graph.h	/^  static const unsigned int long_prune_options_max_mem = 50;$/;"	m	class:bliss::AbstractGraph
long_prune_options_max_stored_auts	bliss/graph.h	/^  static const unsigned int long_prune_options_max_stored_auts = 100;$/;"	m	class:bliss::AbstractGraph
long_prune_redundant	bliss/graph.cc	/^  std::set<unsigned int, std::less<unsigned int> > long_prune_redundant;$/;"	m	class:bliss::TreeNode	file:
long_prune_swap	bliss/graph.cc	/^AbstractGraph::long_prune_swap(const unsigned int i, const unsigned int j)$/;"	f	class:bliss::AbstractGraph
long_prune_temp	bliss/graph.h	/^  std::vector<bool> long_prune_temp;$/;"	m	class:bliss::AbstractGraph
long_text	options/doc_store.h	/^    bool long_text;$/;"	m	struct:options::NoteInfo
lookup	heuristics/cg_cache.h	/^    int lookup(int var, const State &state, int from_val, int to_val) const {$/;"	f	class:cg_heuristic::CGCache
lookup_helpful_transition	heuristics/cg_cache.h	/^    ValueTransitionLabel *lookup_helpful_transition($/;"	f	class:cg_heuristic::CGCache
lookup_in_predefinitions	options/token_parser.h	/^static T *lookup_in_predefinitions(OptionParser &p, bool &found) {$/;"	f	namespace:options
lookup_in_predefinitions_shared	options/token_parser.h	/^static std::shared_ptr<T> lookup_in_predefinitions_shared(OptionParser &p, bool &found) {$/;"	f	namespace:options
lookup_in_registry	options/token_parser.h	/^static T *lookup_in_registry(OptionParser &p) {$/;"	f	namespace:options
lookup_in_registry_shared	options/token_parser.h	/^static std::shared_ptr<T> lookup_in_registry_shared(OptionParser &p) {$/;"	f	namespace:options
lookup_state	state_registry.cc	/^GlobalState StateRegistry::lookup_state(StateID id) const {$/;"	f	class:StateRegistry
lookup_table	merge_and_shrink/merge_and_shrink_representation.h	/^    std::vector<int> lookup_table;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
lookup_table	merge_and_shrink/merge_and_shrink_representation.h	/^    std::vector<std::vector<int>> lookup_table;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
lookup_value	cegar/transition_updater.cc	/^static int lookup_value(const vector<FactPair> &facts, int var) {$/;"	f	namespace:cegar
loop_acyclic_graph	landmarks/landmark_factory.cc	/^int LandmarkFactory::loop_acyclic_graph(LandmarkNode &lmn,$/;"	f	class:landmarks::LandmarkFactory
loops	cegar/abstract_state.h	/^    Loops loops;$/;"	m	class:cegar::AbstractState
lower_bound	lp/lp_solver.h	/^    double lower_bound;$/;"	m	class:lp::LPConstraint
lower_bound	lp/lp_solver.h	/^    double lower_bound;$/;"	m	struct:lp::LPVariable
lp	lp/lp_internals.cc	/^namespace lp {$/;"	n	file:
lp	lp/lp_internals.h	/^namespace lp {$/;"	n
lp	lp/lp_solver.cc	/^namespace lp {$/;"	n	file:
lp	lp/lp_solver.h	/^namespace lp {$/;"	n
lp	operator_counting/constraint_generator.h	/^namespace lp {$/;"	n
lp	operator_counting/state_equation_constraints.h	/^namespace lp {$/;"	n
lp_constraints	landmarks/landmark_cost_assignment.h	/^    std::vector<lp::LPConstraint> lp_constraints;$/;"	m	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
lp_solver	landmarks/landmark_cost_assignment.h	/^    lp::LPSolver lp_solver;$/;"	m	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
lp_solver	lp/lp_solver.h	/^    std::unique_ptr<OsiSolverInterface> lp_solver;$/;"	m	class:lp::LPSolver
lp_solver	operator_counting/operator_counting_heuristic.h	/^    lp::LPSolver lp_solver;$/;"	m	class:operator_counting::OperatorCountingHeuristic
lp_solver	potentials/potential_optimizer.h	/^    lp::LPSolver lp_solver;$/;"	m	class:potentials::PotentialOptimizer
lp_var_ids	potentials/potential_optimizer.h	/^    std::vector<std::vector<int>> lp_var_ids;$/;"	m	class:potentials::PotentialOptimizer
lp_variables	landmarks/landmark_cost_assignment.h	/^    std::vector<lp::LPVariable> lp_variables;$/;"	m	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
lr_before_merging	merge_and_shrink/label_reduction.h	/^    bool lr_before_merging;$/;"	m	class:merge_and_shrink::LabelReduction
lr_before_shrinking	merge_and_shrink/label_reduction.h	/^    bool lr_before_shrinking;$/;"	m	class:merge_and_shrink::LabelReduction
lr_method	merge_and_shrink/label_reduction.h	/^    LabelReductionMethod lr_method;$/;"	m	class:merge_and_shrink::LabelReduction
lr_system_order	merge_and_shrink/label_reduction.h	/^    LabelReductionSystemOrder lr_system_order;$/;"	m	class:merge_and_shrink::LabelReduction
m	heuristics/hm_heuristic.h	/^    const int m;$/;"	m	class:hm_heuristic::HMHeuristic
m_	landmarks/landmark_factory_h_m.h	/^    const int m_;$/;"	m	class:landmarks::LandmarkFactoryHM
mach_absolute_difference	utils/timer.cc	/^void mach_absolute_difference(uint64_t end, uint64_t start, struct timespec *tp) {$/;"	f	namespace:utils
main	planner.cc	/^int main(int argc, const char **argv) {$/;"	f
make_disj_node_simple	landmarks/landmark_graph.cc	/^LandmarkNode &LandmarkGraph::make_disj_node_simple(const FactPair &lm) {$/;"	f	class:landmarks::LandmarkGraph
make_initial_equitable_partition	bliss/graph.cc	/^Digraph::make_initial_equitable_partition()$/;"	f	class:bliss::Digraph
make_initial_equitable_partition	bliss/graph.cc	/^void Graph::make_initial_equitable_partition()$/;"	f	class:bliss::Graph
make_unique_ptr	utils/memory.h	/^std::unique_ptr<T> make_unique_ptr(Args && ... args) {$/;"	f	namespace:utils
map_vector	utils/collections.h	/^std::vector<ElemTo> map_vector(const Collection &collection, MapFunc map_func) {$/;"	f	namespace:utils
mark_as_dead_end	search_space.cc	/^void SearchNode::mark_as_dead_end() {$/;"	f	class:SearchNode
mark_as_relevant	merge_and_shrink/fts_factory.cc	/^void FTSFactory::mark_as_relevant(int var_no, int label_no) {$/;"	f	class:merge_and_shrink::FTSFactory
mark_as_stubborn	pruning/stubborn_sets.cc	/^bool StubbornSets::mark_as_stubborn(int op_no) {$/;"	f	class:stubborn_sets::StubbornSets
mark_as_stubborn_and_remember_written_vars	pruning/stubborn_sets_ec.cc	/^void StubbornSetsEC::mark_as_stubborn_and_remember_written_vars($/;"	f	class:stubborn_sets_ec::StubbornSetsEC
mark_goal_plateau	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::mark_goal_plateau(RelaxedProposition *subgoal) {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
mark_helpful_transitions	heuristics/cea_heuristic.cc	/^void ContextEnhancedAdditiveHeuristic::mark_helpful_transitions($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
mark_helpful_transitions	heuristics/cg_heuristic.cc	/^void CGHeuristic::mark_helpful_transitions(const State &state,$/;"	f	class:cg_heuristic::CGHeuristic
mark_preferred_operators	heuristics/additive_heuristic.cc	/^void AdditiveHeuristic::mark_preferred_operators($/;"	f	class:additive_heuristic::AdditiveHeuristic
mark_preferred_operators_and_relaxed_plan	heuristics/ff_heuristic.cc	/^void FFHeuristic::mark_preferred_operators_and_relaxed_plan($/;"	f	class:ff_heuristic::FFHeuristic
mark_used_variables	pdbs/pattern_collection_generator_genetic.cc	/^bool PatternCollectionGeneratorGenetic::mark_used_variables($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
marked	heuristics/relaxation_heuristic.h	/^    bool marked; \/\/ used when computing preferred operators for h^add and h^FF$/;"	m	struct:relaxation_heuristic::Proposition
marked	landmarks/exploration.h	/^    bool marked; \/\/ used when computing preferred operators$/;"	m	struct:landmarks::ExProposition
mas_representation	merge_and_shrink/merge_and_shrink_heuristic.h	/^    std::unique_ptr<MergeAndShrinkRepresentation> mas_representation;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
mas_representations	merge_and_shrink/factored_transition_system.h	/^    std::vector<std::unique_ptr<MergeAndShrinkRepresentation>> mas_representations;$/;"	m	class:merge_and_shrink::FactoredTransitionSystem
master	landmarks/lama_ff_synergy.cc	/^    LamaMasterHeuristic *master;$/;"	m	class:landmarks::FFSlaveHeuristic	file:
max	options/bounds.h	/^    std::string max;$/;"	m	struct:options::Bounds
max_additive_subsets	pdbs/canonical_pdbs.h	/^    std::shared_ptr<MaxAdditivePDBSubsets> max_additive_subsets;$/;"	m	class:pdbs::CanonicalPDBs
max_additive_subsets	pdbs/incremental_canonical_pdbs.h	/^    std::shared_ptr<MaxAdditivePDBSubsets> max_additive_subsets;$/;"	m	class:pdbs::IncrementalCanonicalPDBs
max_additive_subsets	pdbs/pattern_collection_information.h	/^    std::shared_ptr<MaxAdditivePDBSubsets> max_additive_subsets;$/;"	m	class:pdbs::PatternCollectionInformation
max_cliques	algorithms/max_cliques.cc	/^    vector<vector<int>> &max_cliques;$/;"	m	class:max_cliques::MaxCliqueComputer	file:
max_cliques	algorithms/max_cliques.cc	/^namespace max_cliques {$/;"	n	file:
max_cliques	algorithms/max_cliques.h	/^namespace max_cliques {$/;"	n
max_depth	ext/tree.hh	/^int tree<T, tree_node_allocator>::max_depth() const$/;"	f	class:tree
max_depth	ext/tree.hh	/^int tree<T, tree_node_allocator>::max_depth(const iterator_base& pos) const$/;"	f	class:tree
max_evaluator	evaluators/max_evaluator.cc	/^namespace max_evaluator {$/;"	n	file:
max_evaluator	evaluators/max_evaluator.h	/^namespace max_evaluator {$/;"	n
max_f	merge_and_shrink/distances.h	/^    int max_f;$/;"	m	class:merge_and_shrink::Distances
max_g	merge_and_shrink/distances.h	/^    int max_g;$/;"	m	class:merge_and_shrink::Distances
max_h	merge_and_shrink/distances.h	/^    int max_h;$/;"	m	class:merge_and_shrink::Distances
max_heuristic	heuristics/max_heuristic.cc	/^namespace max_heuristic {$/;"	n	file:
max_heuristic	heuristics/max_heuristic.h	/^namespace max_heuristic {$/;"	n
max_ival	bliss/partition.h	/^    unsigned int max_ival;$/;"	m	class:bliss::Partition::Cell
max_ival_count	bliss/partition.h	/^    unsigned int max_ival_count;$/;"	m	class:bliss::Partition::Cell
max_level	bliss/graph.h	/^  unsigned long int max_level;$/;"	m	class:bliss::Stats
max_non_looping_transitions	cegar/abstraction.h	/^    const int max_non_looping_transitions;$/;"	m	class:cegar::Abstraction
max_non_looping_transitions	cegar/cost_saturation.h	/^    const int max_non_looping_transitions;$/;"	m	class:cegar::CostSaturation
max_num_heuristics	potentials/diverse_potential_heuristics.h	/^    const int max_num_heuristics;$/;"	m	class:potentials::DiversePotentialHeuristics
max_pattern_size	pdbs/pattern_collection_generator_systematic.h	/^    const size_t max_pattern_size;$/;"	m	class:pdbs::PatternCollectionGeneratorSystematic
max_potential	potentials/potential_optimizer.h	/^    const double max_potential;$/;"	m	class:potentials::PotentialOptimizer
max_size	merge_and_shrink/labels.h	/^    int max_size; \/\/ the maximum number of labels that can be created$/;"	m	class:merge_and_shrink::Labels
max_states	cegar/abstraction.h	/^    const int max_states;$/;"	m	class:cegar::Abstraction
max_states	cegar/cost_saturation.h	/^    const int max_states;$/;"	m	class:cegar::CostSaturation
max_states	merge_and_shrink/merge_and_shrink_heuristic.h	/^    const int max_states;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
max_states	pdbs/pattern_collection_generator_combo.h	/^    int max_states;$/;"	m	class:pdbs::PatternCollectionGeneratorCombo
max_states	pdbs/pattern_generator_greedy.h	/^    int max_states;$/;"	m	class:pdbs::PatternGeneratorGreedy
max_states_before_merge	merge_and_shrink/merge_and_shrink_heuristic.h	/^    const int max_states_before_merge;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
max_time	cegar/cost_saturation.h	/^    const double max_time;$/;"	m	class:cegar::CostSaturation
max_time	pdbs/pattern_collection_generator_hillclimbing.h	/^    const double max_time;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
max_time	search_engine.h	/^    double max_time;$/;"	m	class:SearchEngine
max_time	utils/countdown_timer.h	/^    double max_time;$/;"	m	class:utils::CountdownTimer
may_keep_refining	cegar/abstraction.cc	/^bool Abstraction::may_keep_refining() const {$/;"	f	class:cegar::Abstraction
memory_padding_in_mb	cegar/cost_saturation.cc	/^static const int memory_padding_in_mb = 75;$/;"	m	namespace:cegar	file:
merge	ext/tree.hh	/^void tree<T, tree_node_allocator>::merge(sibling_iterator to1,   sibling_iterator to2,$/;"	f	class:tree
merge	merge_and_shrink/factored_transition_system.cc	/^int FactoredTransitionSystem::merge($/;"	f	class:merge_and_shrink::FactoredTransitionSystem
merge	merge_and_shrink/transition_system.cc	/^unique_ptr<TransitionSystem> TransitionSystem::merge($/;"	f	class:merge_and_shrink::TransitionSystem
merge_and_shrink	merge_and_shrink/distances.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/distances.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/factored_transition_system.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/factored_transition_system.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/fts_factory.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/fts_factory.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/label_equivalence_relation.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/label_equivalence_relation.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/label_reduction.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/label_reduction.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/labels.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/labels.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_and_shrink_heuristic.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_and_shrink_heuristic.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_and_shrink_representation.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_and_shrink_representation.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_scoring_function.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_scoring_function.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_scoring_function_dfp.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_scoring_function_dfp.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_scoring_function_goal_relevance.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_scoring_function_goal_relevance.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_scoring_function_single_random.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_scoring_function_single_random.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_scoring_function_total_order.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_scoring_function_total_order.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_selector.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_selector.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_selector_score_based_filtering.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_selector_score_based_filtering.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_strategy.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_strategy_aliases.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy_factory.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy_factory.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_strategy_factory_precomputed.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy_factory_precomputed.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_strategy_factory_stateless.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy_factory_stateless.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_strategy_precomputed.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy_precomputed.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_strategy_stateless.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_strategy_stateless.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_tree.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_tree.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_tree_factory.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_tree_factory.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/merge_tree_factory_linear.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/merge_tree_factory_linear.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/shrink_bisimulation.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/shrink_bisimulation.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/shrink_bucket_based.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/shrink_bucket_based.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/shrink_fh.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/shrink_fh.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/shrink_random.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/shrink_random.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/shrink_strategy.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/shrink_strategy.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/transition_system.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/transition_system.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/types.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/types.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	merge_and_shrink/utils.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_and_shrink	merge_and_shrink/utils.h	/^namespace merge_and_shrink {$/;"	n
merge_and_shrink	options/option_parser.cc	/^namespace merge_and_shrink {$/;"	n	file:
merge_candidate_order	merge_and_shrink/merge_scoring_function_total_order.h	/^    std::vector<std::pair<int, int>> merge_candidate_order;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
merge_orbits	bliss/orbit.cc	/^void Orbit::merge_orbits(OrbitEntry *orbit1, OrbitEntry *orbit2)$/;"	f	class:bliss::Orbit
merge_orbits	bliss/orbit.cc	/^void Orbit::merge_orbits(unsigned int e1, unsigned int e2)$/;"	f	class:bliss::Orbit
merge_scoring_functions	merge_and_shrink/merge_selector_score_based_filtering.h	/^    std::vector<std::shared_ptr<MergeScoringFunction>> merge_scoring_functions;$/;"	m	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
merge_selector	merge_and_shrink/merge_strategy_factory_stateless.h	/^    std::shared_ptr<MergeSelector> merge_selector;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryStateless
merge_selector	merge_and_shrink/merge_strategy_stateless.h	/^    const std::shared_ptr<MergeSelector> merge_selector;$/;"	m	class:merge_and_shrink::MergeStrategyStateless
merge_strategy_factory	merge_and_shrink/merge_and_shrink_heuristic.h	/^    std::shared_ptr<MergeStrategyFactory> merge_strategy_factory;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
merge_tree	merge_and_shrink/merge_strategy_precomputed.h	/^    std::unique_ptr<MergeTree> merge_tree;$/;"	m	class:merge_and_shrink::MergeStrategyPrecomputed
merge_tree_factory	merge_and_shrink/merge_strategy_factory_precomputed.h	/^    std::shared_ptr<MergeTreeFactory> merge_tree_factory;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
min	options/bounds.h	/^    std::string min;$/;"	m	struct:options::Bounds
min_action_cost	heuristics/cea_heuristic.h	/^    int min_action_cost;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
min_action_cost	heuristics/cg_heuristic.h	/^    int min_action_cost;$/;"	m	class:cg_heuristic::CGHeuristic
min_cost	landmarks/landmark_graph.h	/^    int min_cost; \/\/ minimal cost of achieving operators$/;"	m	class:landmarks::EdgeType::LandmarkNode
min_cost_for_landmark	landmarks/landmark_factory_rpg_sasp.cc	/^int LandmarkFactoryRpgSasp::min_cost_for_landmark(const TaskProxy &task_proxy,$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
min_improvement	pdbs/pattern_collection_generator_hillclimbing.h	/^    const int min_improvement;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
min_operator_cost	heuristics/blind_search_heuristic.h	/^    int min_operator_cost;$/;"	m	class:blind_search_heuristic::BlindSearchHeuristic
mk_acyclic_graph	landmarks/landmark_factory.cc	/^void LandmarkFactory::mk_acyclic_graph() {$/;"	f	class:landmarks::LandmarkFactory
move_after	ext/tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_after(iter target, iter source)$/;"	f	class:tree
move_before	ext/tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_before(iter target, iter source)$/;"	f	class:tree
move_before	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::move_before(sibling_iterator target, $/;"	f	class:tree
move_group_into_group	merge_and_shrink/label_equivalence_relation.cc	/^void LabelEquivalenceRelation::move_group_into_group($/;"	f	class:merge_and_shrink::LabelEquivalenceRelation
move_ontop	ext/tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::move_ontop(iter target, iter source)$/;"	f	class:tree
msg	options/errors.h	/^    std::string msg;$/;"	m	struct:options::ArgError
msg	options/errors.h	/^    std::string msg;$/;"	m	struct:options::ParseError
multiply	bliss/bignum.h	/^  void multiply(const int n) {mpz_mul_si(v, v, n); }$/;"	f	class:bliss::BigNum
multiply_out	pdbs/pattern_database.cc	/^void PatternDatabase::multiply_out($/;"	f	class:pdbs::PatternDatabase
mutate	pdbs/pattern_collection_generator_genetic.cc	/^void PatternCollectionGeneratorGenetic::mutate() {$/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
mutation_probability	pdbs/pattern_collection_generator_genetic.h	/^    const double mutation_probability;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
n	bliss/heap.h	/^  unsigned int n;$/;"	m	class:bliss::Heap
name	global_operator.h	/^    std::string name;$/;"	m	class:GlobalOperator
name	merge_and_shrink/merge_scoring_function_dfp.cc	/^string MergeScoringFunctionDFP::name() const {$/;"	f	class:merge_and_shrink::MergeScoringFunctionDFP
name	merge_and_shrink/merge_scoring_function_goal_relevance.cc	/^string MergeScoringFunctionGoalRelevance::name() const {$/;"	f	class:merge_and_shrink::MergeScoringFunctionGoalRelevance
name	merge_and_shrink/merge_scoring_function_single_random.cc	/^string MergeScoringFunctionSingleRandom::name() const {$/;"	f	class:merge_and_shrink::MergeScoringFunctionSingleRandom
name	merge_and_shrink/merge_scoring_function_total_order.cc	/^string MergeScoringFunctionTotalOrder::name() const {$/;"	f	class:merge_and_shrink::MergeScoringFunctionTotalOrder
name	merge_and_shrink/merge_selector_score_based_filtering.cc	/^string MergeSelectorScoreBasedFiltering::name() const {$/;"	f	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
name	merge_and_shrink/merge_strategy_factory_precomputed.cc	/^string MergeStrategyFactoryPrecomputed::name() const {$/;"	f	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
name	merge_and_shrink/merge_strategy_factory_stateless.cc	/^string MergeStrategyFactoryStateless::name() const {$/;"	f	class:merge_and_shrink::MergeStrategyFactoryStateless
name	merge_and_shrink/merge_tree_factory_linear.cc	/^string MergeTreeFactoryLinear::name() const {$/;"	f	class:merge_and_shrink::MergeTreeFactoryLinear
name	merge_and_shrink/shrink_bisimulation.cc	/^string ShrinkBisimulation::name() const {$/;"	f	class:merge_and_shrink::ShrinkBisimulation
name	merge_and_shrink/shrink_fh.cc	/^string ShrinkFH::name() const {$/;"	f	class:merge_and_shrink::ShrinkFH
name	merge_and_shrink/shrink_random.cc	/^string ShrinkRandom::name() const {$/;"	f	class:merge_and_shrink::ShrinkRandom
name	options/doc_store.h	/^    std::string name;$/;"	m	struct:options::NoteInfo
name	options/type_namer.h	/^    static std::string name() {$/;"	f	struct:options::TypeNamer
natural	landmarks/landmark_graph.h	/^    natural = 2,$/;"	m	class:landmarks::EdgeType
nbf_info_by_layer	axioms.h	/^    std::vector<std::vector<NegationByFailureInfo>> nbf_info_by_layer;$/;"	m	class:AxiomEvaluator
necessary	landmarks/landmark_factory_h_m.h	/^    std::list<int> necessary; \/\/ greedy necessary landmarks, disjoint from landmarks$/;"	m	struct:landmarks::HMEntry
necessary	landmarks/landmark_graph.h	/^    necessary = 4,$/;"	m	class:landmarks::EdgeType
needed_cost	landmarks/landmark_graph.h	/^    int needed_cost;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
needs_long_prune	bliss/graph.cc	/^  bool needs_long_prune;$/;"	m	class:bliss::TreeNode	file:
neighbour_heap	bliss/graph.h	/^  Heap neighbour_heap;$/;"	m	class:bliss::AbstractGraph
nes_computed	pruning/stubborn_sets_ec.h	/^    std::vector<std::vector<bool>> nes_computed;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
next	bliss/orbit.h	/^    OrbitEntry *next;$/;"	m	class:bliss::Orbit::OrbitEntry
next	bliss/partition.h	/^    CRCell* next;$/;"	m	class:bliss::Partition::CRCell
next	bliss/partition.h	/^    Cell* next;$/;"	m	class:bliss::Partition::Cell
next	variable_order_finder.cc	/^int VariableOrderFinder::next() {$/;"	f	class:VariableOrderFinder
next_at_same_depth	ext/tree.hh	/^iter tree<T, tree_node_allocator>::next_at_same_depth(iter position) const$/;"	f	class:tree
next_cep_index	bliss/graph.h	/^    unsigned int next_cep_index;$/;"	m	class:bliss::AbstractGraph::CR_CEP
next_condition_by_op	successor_generator.h	/^    std::vector<Condition::const_iterator> next_condition_by_op;$/;"	m	class:SuccessorGenerator
next_cr_level	bliss/graph.h	/^    unsigned int next_cr_level;$/;"	m	class:bliss::AbstractGraph::CR_CEP
next_id	open_lists/epsilon_greedy_open_list.cc	/^    int next_id;$/;"	m	class:EpsilonGreedyOpenList	file:
next_nonsingleton	bliss/partition.h	/^    Cell* next_nonsingleton;$/;"	m	class:bliss::Partition::Cell
next_nonsingleton_first	bliss/partition.h	/^    int next_nonsingleton_first;$/;"	m	class:bliss::Partition::RefInfo
next_sibling	ext/tree.hh	/^		tree_node_<T> *prev_sibling, *next_sibling;$/;"	m	class:tree_node_
next_sibling	ext/tree.hh	/^iter tree<T, tree_node_allocator>::next_sibling(iter position) const$/;"	f	class:tree
next_unparsed_argument	options/option_parser.h	/^    ParseTree::sibling_iterator next_unparsed_argument;$/;"	m	class:options::OptionParser
next_valid_index	merge_and_shrink/factored_transition_system.cc	/^void FTSConstIterator::next_valid_index() {$/;"	f	class:merge_and_shrink::FTSConstIterator
next_valid_index	merge_and_shrink/transition_system.cc	/^void TSConstIterator::next_valid_index() {$/;"	f	class:merge_and_shrink::TSConstIterator
no_fact	abstract_task.cc	/^const FactPair FactPair::no_fact = FactPair(-1, -1);$/;"	m	class:FactPair	file:
no_fact	abstract_task.h	/^    static const FactPair no_fact;$/;"	m	struct:FactPair
no_orders	landmarks/landmark_factory.h	/^    const bool no_orders;$/;"	m	class:landmarks::LandmarkFactory
no_state	state_id.cc	/^const StateID StateID::no_state = StateID(-1);$/;"	m	class:StateID	file:
no_state	state_id.h	/^    static const StateID no_state;$/;"	m	class:StateID
node	cegar/abstract_state.h	/^    Node *node;$/;"	m	class:cegar::AbstractState
node	ext/tree.hh	/^				tree_node *node;$/;"	m	class:tree::iterator_base
node_queue	heuristics/cea_heuristic.h	/^    priority_queues::AdaptiveQueue<LocalProblemNode *> node_queue;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
nodes	domain_transition_graph.h	/^    std::vector<ValueNode> nodes;$/;"	m	class:DomainTransitionGraph
nodes	heuristics/cea_heuristic.cc	/^    vector<LocalProblemNode> nodes;$/;"	m	struct:cea_heuristic::LocalProblem	file:
nodes	landmarks/landmark_graph.h	/^    std::set<LandmarkNode *> nodes;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
nof_bad_nodes	bliss/graph.h	/^  long unsigned int nof_bad_nodes;$/;"	m	class:bliss::Stats
nof_canupdates	bliss/graph.h	/^  long unsigned int nof_canupdates;$/;"	m	class:bliss::Stats
nof_discrete_cells	bliss/partition.h	/^  unsigned int nof_discrete_cells() const {return(discrete_cell_count); }$/;"	f	class:bliss::Partition
nof_edges	bliss/graph.h	/^    unsigned int nof_edges() const {return edges.size(); }$/;"	f	class:bliss::Graph::Vertex
nof_edges_in	bliss/graph.h	/^    unsigned int nof_edges_in() const {return edges_in.size(); }$/;"	f	class:bliss::Digraph::Vertex
nof_edges_out	bliss/graph.h	/^    unsigned int nof_edges_out() const {return edges_out.size(); }$/;"	f	class:bliss::Digraph::Vertex
nof_elements	bliss/orbit.h	/^  unsigned int nof_elements;$/;"	m	class:bliss::Orbit
nof_generators	bliss/graph.h	/^  long unsigned int nof_generators;$/;"	m	class:bliss::Stats
nof_leaf_nodes	bliss/graph.h	/^  long unsigned int nof_leaf_nodes;$/;"	m	class:bliss::Stats
nof_nodes	bliss/graph.h	/^  long unsigned int nof_nodes;$/;"	m	class:bliss::Stats
nof_orbits	bliss/orbit.h	/^  unsigned int nof_orbits() const {return _nof_orbits; }$/;"	f	class:bliss::Orbit
non_empty_lp_constraints	landmarks/landmark_cost_assignment.h	/^    std::vector<lp::LPConstraint> non_empty_lp_constraints;$/;"	m	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
nondominated	open_lists/pareto_open_list.cc	/^    KeySet nondominated;$/;"	m	class:ParetoOpenList	file:
normalize_given_transitions	merge_and_shrink/transition_system.cc	/^static void normalize_given_transitions(vector<Transition> &transitions) {$/;"	f	namespace:merge_and_shrink
notes	options/doc_store.h	/^    std::vector<NoteInfo> notes;$/;"	m	struct:options::DocStruct
notify_initial_state	heuristic.h	/^    virtual void notify_initial_state(const GlobalState & \/*initial_state*\/) {$/;"	f	class:Heuristic
notify_initial_state	landmarks/landmark_count_heuristic.cc	/^void LandmarkCountHeuristic::notify_initial_state(const GlobalState &initial_state) {$/;"	f	class:landmarks::LandmarkCountHeuristic
notify_state_transition	heuristic.cc	/^bool Heuristic::notify_state_transition($/;"	f	class:Heuristic
notify_state_transition	landmarks/landmark_count_heuristic.cc	/^bool LandmarkCountHeuristic::notify_state_transition($/;"	f	class:landmarks::LandmarkCountHeuristic
nucr_find_first_component	bliss/graph.cc	/^Digraph::nucr_find_first_component(const unsigned int level)$/;"	f	class:bliss::Digraph
nucr_find_first_component	bliss/graph.cc	/^Digraph::nucr_find_first_component(const unsigned int level,$/;"	f	class:bliss::Digraph
nucr_find_first_component	bliss/graph.cc	/^Graph::nucr_find_first_component(const unsigned int level)$/;"	f	class:bliss::Graph
nucr_find_first_component	bliss/graph.cc	/^Graph::nucr_find_first_component(const unsigned int level,$/;"	f	class:bliss::Graph
null_pruning_method	pruning/null_pruning_method.cc	/^namespace null_pruning_method {$/;"	n	file:
null_pruning_method	pruning/null_pruning_method.h	/^namespace null_pruning_method {$/;"	n
numTicksPerSec	bliss/timer.cc	/^static const double numTicksPerSec = (double)(sysconf(_SC_CLK_TCK));$/;"	m	namespace:bliss	file:
num_abstractions	cegar/cost_saturation.h	/^    int num_abstractions;$/;"	m	class:cegar::CostSaturation
num_active_entries	merge_and_shrink/factored_transition_system.h	/^    int num_active_entries;$/;"	m	class:merge_and_shrink::FactoredTransitionSystem
num_bins	algorithms/int_packer.h	/^    int num_bins;$/;"	m	class:int_packer::IntPacker
num_bits	algorithms/dynamic_bitset.h	/^    const std::size_t num_bits;$/;"	m	class:dynamic_bitset::DynamicBitset
num_collections	pdbs/pattern_collection_generator_genetic.h	/^    const int num_collections;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
num_copies	cegar/subtask_generators.h	/^    int num_copies;$/;"	m	class:cegar::TaskDuplicator
num_ehc_phases	search_engines/enforced_hill_climbing_search.h	/^    int num_ehc_phases;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
num_elements	algorithms/equivalence_relation.h	/^    int num_elements;$/;"	m	class:equivalence_relation::EquivalenceRelation
num_entries	algorithms/priority_queues.h	/^    int num_entries;$/;"	m	class:priority_queues::BucketQueue
num_episodes	pdbs/pattern_collection_generator_genetic.h	/^    const int num_episodes;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
num_identity_generators	structural_symmetries/group.cc	/^int Group::num_identity_generators;$/;"	m	class:Group	file:
num_identity_generators	structural_symmetries/group.h	/^    static int num_identity_generators;$/;"	m	class:Group
num_loops	cegar/transition_updater.h	/^    int num_loops;$/;"	m	class:cegar::TransitionUpdater
num_lp_vars	potentials/potential_optimizer.h	/^    int num_lp_vars;$/;"	m	class:potentials::PotentialOptimizer
num_non_looping_transitions	cegar/cost_saturation.h	/^    int num_non_looping_transitions;$/;"	m	class:cegar::CostSaturation
num_non_loops	cegar/transition_updater.h	/^    int num_non_loops;$/;"	m	class:cegar::TransitionUpdater
num_operators	pruning/stubborn_sets.h	/^    int num_operators;$/;"	m	class:stubborn_sets::StubbornSets
num_permanent_constraints	lp/lp_solver.h	/^    int num_permanent_constraints;$/;"	m	class:lp::LPSolver
num_propositions	heuristics/lm_cut_landmarks.h	/^    int num_propositions;$/;"	m	class:lm_cut_heuristic::LandmarkCutLandmarks
num_pruned_successors_generated	pruning/stubborn_sets.h	/^    long num_pruned_successors_generated;$/;"	m	class:stubborn_sets::StubbornSets
num_pushes	algorithms/priority_queues.h	/^    int num_pushes;$/;"	m	class:priority_queues::BucketQueue
num_rejected	pdbs/pattern_collection_generator_hillclimbing.h	/^    int num_rejected;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
num_samples	pdbs/pattern_collection_generator_hillclimbing.h	/^    const int num_samples;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
num_samples	potentials/diverse_potential_heuristics.h	/^    const int num_samples;$/;"	m	class:potentials::DiversePotentialHeuristics
num_states	cegar/cost_saturation.h	/^    int num_states;$/;"	m	class:cegar::CostSaturation
num_states	merge_and_shrink/fts_factory.cc	/^        int num_states;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
num_states	merge_and_shrink/transition_system.h	/^    int num_states;$/;"	m	class:merge_and_shrink::TransitionSystem
num_states	pdbs/pattern_database.h	/^    std::size_t num_states;$/;"	m	class:pdbs::PatternDatabase
num_unpruned_successors_generated	pruning/stubborn_sets.h	/^    long num_unpruned_successors_generated;$/;"	m	class:stubborn_sets::StubbornSets
num_variables	merge_and_shrink/fts_factory.cc	/^        int num_variables;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
num_variables	merge_and_shrink/transition_system.h	/^    const int num_variables;$/;"	m	class:merge_and_shrink::TransitionSystem
num_variables	state_registry.h	/^    const int num_variables;$/;"	m	class:StateRegistry
num_vars	structural_symmetries/permutation.cc	/^int Permutation::num_vars;$/;"	m	class:Permutation	file:
num_vars	structural_symmetries/permutation.h	/^    static int num_vars;$/;"	m	class:Permutation
number_of_children	ext/tree.hh	/^unsigned int tree<T, tree_node_allocator>::iterator_base::number_of_children() const$/;"	f	class:tree::iterator_base
number_of_children	ext/tree.hh	/^unsigned int tree<T, tree_node_allocator>::number_of_children(const iterator_base& it) $/;"	f	class:tree
number_of_conj_landmarks	landmarks/landmark_graph.h	/^    int number_of_conj_landmarks() const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
number_of_disj_landmarks	landmarks/landmark_graph.h	/^    int number_of_disj_landmarks() const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
number_of_edges	landmarks/landmark_graph.cc	/^int LandmarkGraph::number_of_edges() const {$/;"	f	class:landmarks::LandmarkGraph
number_of_landmarks	landmarks/landmark_graph.h	/^    inline int number_of_landmarks() const {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
number_of_plans	search_engines/top_k_eager_search.h	/^    const int number_of_plans;$/;"	m	class:top_k_eager_search::TopKEagerSearch
number_of_siblings	ext/tree.hh	/^unsigned int tree<T, tree_node_allocator>::number_of_siblings(const iterator_base& it) const$/;"	f	class:tree
obedient_reasonable	landmarks/landmark_graph.h	/^    obedient_reasonable = 0$/;"	m	class:landmarks::EdgeType
objective	lp/lp_solver.h	/^    std::vector<double> objective;$/;"	m	class:lp::LPSolver
objective_coefficient	lp/lp_solver.h	/^    double objective_coefficient;$/;"	m	struct:lp::LPVariable
on_plan	tasks/plan_forbid_reformulated_task.h	/^	std::vector<bool> on_plan;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
ones	algorithms/dynamic_bitset.h	/^    static const Block ones;$/;"	m	class:dynamic_bitset::DynamicBitset
ones	algorithms/dynamic_bitset.h	/^const Block DynamicBitset<Block>::ones = Block(~Block(0));$/;"	m	class:dynamic_bitset::DynamicBitset
only_causal_landmarks	landmarks/landmark_factory.h	/^    const bool only_causal_landmarks;$/;"	m	class:landmarks::LandmarkFactory
only_contains_preferred_entries	open_lists/open_list.h	/^bool OpenList<Entry>::only_contains_preferred_entries() const {$/;"	f	class:OpenList
only_interesting_patterns	pdbs/pattern_collection_generator_systematic.h	/^    const bool only_interesting_patterns;$/;"	m	class:pdbs::PatternCollectionGeneratorSystematic
only_preferred	open_lists/open_list.h	/^    bool only_preferred;$/;"	m	class:OpenList
op_id	cegar/transition.h	/^    int op_id;$/;"	m	struct:cegar::Transition
op_id	domain_transition_graph.h	/^    int op_id;$/;"	m	struct:ValueTransitionLabel
op_index	search_engines/top_k_eager_search.h	/^	int op_index = -1;$/;"	m	struct:top_k_eager_search::StateActionPair
op_index	task_proxy.h	/^    int op_index;$/;"	m	class:EffectConditionsProxy
op_index	task_proxy.h	/^    int op_index;$/;"	m	class:EffectProxy
op_index	task_proxy.h	/^    int op_index;$/;"	m	class:EffectsProxy
op_index	task_proxy.h	/^    int op_index;$/;"	m	class:PreconditionsProxy
op_or_axiom_id	landmarks/exploration.h	/^    int op_or_axiom_id;$/;"	m	struct:landmarks::ExUnaryOperator
op_preconditions_on_var	pruning/stubborn_sets_ec.h	/^    std::vector<std::vector<int>> op_preconditions_on_var;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
open	search_space.cc	/^void SearchNode::open(const SearchNode &parent_node,$/;"	f	class:SearchNode
open_initial	search_space.cc	/^void SearchNode::open_initial() {$/;"	f	class:SearchNode
open_landmarks	landmarks/landmark_factory_rpg_sasp.h	/^    std::list<LandmarkNode *> open_landmarks;$/;"	m	class:landmarks::LandmarkFactoryRpgSasp
open_list	search_engines/eager_search.h	/^    std::unique_ptr<StateOpenList> open_list;$/;"	m	class:eager_search::EagerSearch
open_list	search_engines/enforced_hill_climbing_search.h	/^    std::unique_ptr<EdgeOpenList> open_list;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
open_list	search_engines/lazy_search.h	/^    std::unique_ptr<EdgeOpenList> open_list;$/;"	m	class:lazy_search::LazySearch
open_list	search_engines/top_k_eager_search.h	/^    std::unique_ptr<StateOpenList> open_list;$/;"	m	class:top_k_eager_search::TopKEagerSearch
open_lists	open_lists/alternation_open_list.cc	/^    vector<unique_ptr<OpenList<Entry>>> open_lists;$/;"	m	class:AlternationOpenList	file:
open_queue	cegar/abstract_search.h	/^    priority_queues::AdaptiveQueue<AbstractState *> open_queue;$/;"	m	class:cegar::AbstractSearch
operator !=	abstract_task.h	/^    bool operator!=(const FactPair &other) const {$/;"	f	struct:FactPair
operator !=	ext/tree.hh	/^bool tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator!=(const breadth_first_queued_iterator& other) const$/;"	f	class:tree::breadth_first_queued_iterator
operator !=	ext/tree.hh	/^bool tree<T, tree_node_allocator>::fixed_depth_iterator::operator!=(const fixed_depth_iterator& other) const$/;"	f	class:tree::fixed_depth_iterator
operator !=	ext/tree.hh	/^bool tree<T, tree_node_allocator>::leaf_iterator::operator!=(const leaf_iterator& other) const$/;"	f	class:tree::leaf_iterator
operator !=	ext/tree.hh	/^bool tree<T, tree_node_allocator>::post_order_iterator::operator!=(const post_order_iterator& other) const$/;"	f	class:tree::post_order_iterator
operator !=	ext/tree.hh	/^bool tree<T, tree_node_allocator>::pre_order_iterator::operator!=(const pre_order_iterator& other) const$/;"	f	class:tree::pre_order_iterator
operator !=	ext/tree.hh	/^bool tree<T, tree_node_allocator>::sibling_iterator::operator!=(const sibling_iterator& other) const$/;"	f	class:tree::sibling_iterator
operator !=	global_operator.h	/^    bool operator!=(const GlobalCondition &other) const {$/;"	f	struct:GlobalCondition
operator !=	merge_and_shrink/factored_transition_system.h	/^    bool operator!=(const FTSConstIterator &rhs) const {$/;"	f	class:merge_and_shrink::FTSConstIterator
operator !=	merge_and_shrink/transition_system.h	/^    bool operator!=(const TSConstIterator &rhs) const {$/;"	f	class:merge_and_shrink::TSConstIterator
operator !=	per_state_information.h	/^        bool operator!=(const const_iterator &rhs) {$/;"	f	class:PerStateInformation::const_iterator
operator !=	state_id.h	/^    bool operator!=(const StateID &other) const {$/;"	f	class:StateID
operator !=	task_proxy.h	/^    bool operator!=(const FactProxy &other) const {$/;"	f	class:FactProxy
operator !=	task_proxy.h	/^    bool operator!=(const FactsProxyIterator &other) const {$/;"	f	class:FactsProxyIterator
operator !=	task_proxy.h	/^    bool operator!=(const OperatorProxy &other) const {$/;"	f	class:OperatorProxy
operator !=	task_proxy.h	/^    bool operator!=(const ProxyIterator &other) const {$/;"	f	class:ProxyIterator
operator !=	task_proxy.h	/^    bool operator!=(const State &other) const {$/;"	f	class:State
operator !=	task_proxy.h	/^    bool operator!=(const VariableProxy &other) const {$/;"	f	class:VariableProxy
operator ()	abstract_task.h	/^    size_t operator()(const FactPair &fact) const {$/;"	f	struct:std::hash
operator ()	algorithms/priority_queues.h	/^        bool operator()(const Entry &lhs, const Entry &rhs) const {$/;"	f	struct:priority_queues::HeapQueue::compare_func
operator ()	cegar/subtask_generators.cc	/^    bool operator()(const FactPair &a, const FactPair &b) {$/;"	f	class:cegar::SortFactsByIncreasingHaddValues
operator ()	cegar/utils.h	/^    size_t operator()(const FactProxy &fact) const {$/;"	f	struct:std::hash
operator ()	ext/tree.hh	/^				bool operator()(const tree_node *a, const tree_node *b) $/;"	f	class:tree::compare_nodes
operator ()	ext/tree.hh	/^				bool operator()(const typename tree<T, tree_node_allocator>::iterator_base& one,$/;"	f	class:tree::iterator_base_less
operator ()	landmarks/landmark_factory_h_m.h	/^    bool operator()(const FluentSet &fs1, const FluentSet &fs2) const {$/;"	f	struct:landmarks::FluentSetComparer
operator ()	landmarks/landmark_graph.h	/^    bool operator()(LandmarkNode *a, LandmarkNode *b) const {$/;"	f	struct:landmarks::EdgeType::LandmarkNodeComparer
operator ()	state_id.h	/^    size_t operator()(StateID id) const {$/;"	f	struct:std::hash
operator ()	state_registry.h	/^        bool operator()(StateID lhs, StateID rhs) const {$/;"	f	struct:StateRegistry::StateIDSemanticEqual
operator ()	state_registry.h	/^        size_t operator()(StateID id) const {$/;"	f	struct:StateRegistry::StateIDSemanticHash
operator ()	task_proxy.h	/^    size_t operator()(const State &state) const {$/;"	f	struct:std::hash
operator ()	utils/hash.h	/^    size_t operator()(const std::pair<TA, TB> &pair) const {$/;"	f	struct:std::hash
operator ()	utils/hash.h	/^    size_t operator()(const std::vector<T> &vec) const {$/;"	f	struct:std::hash
operator ()	utils/rng.h	/^    double operator()() {$/;"	f	class:utils::RandomNumberGenerator
operator ()	utils/rng.h	/^    int operator()(int bound) {$/;"	f	class:utils::RandomNumberGenerator
operator ()	utils/timer.cc	/^double Timer::operator()() const {$/;"	f	class:utils::Timer
operator *	ext/tree.hh	/^T& tree<T, tree_node_allocator>::iterator_base::operator*() const$/;"	f	class:tree::iterator_base
operator *	merge_and_shrink/factored_transition_system.h	/^    int operator*() const {$/;"	f	class:merge_and_shrink::FTSConstIterator
operator *	merge_and_shrink/transition_system.cc	/^GroupAndTransitions TSConstIterator::operator*() const {$/;"	f	class:merge_and_shrink::TSConstIterator
operator *	per_state_information.h	/^        StateID operator*() {$/;"	f	class:PerStateInformation::const_iterator
operator *	task_proxy.h	/^    FactProxy operator*() const {$/;"	f	class:FactsProxyIterator
operator *	task_proxy.h	/^    reference operator*() const {$/;"	f	class:ProxyIterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator++(int)$/;"	f	class:tree::breadth_first_queued_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator& tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator++()$/;"	f	class:tree::breadth_first_queued_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::fixed_depth_iterator::operator++(int)$/;"	f	class:tree::fixed_depth_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator++()$/;"	f	class:tree::fixed_depth_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::leaf_iterator::operator++(int)$/;"	f	class:tree::leaf_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator++()$/;"	f	class:tree::leaf_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::post_order_iterator::operator++(int)$/;"	f	class:tree::post_order_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator++()$/;"	f	class:tree::post_order_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::pre_order_iterator::operator++(int)$/;"	f	class:tree::pre_order_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator++()$/;"	f	class:tree::pre_order_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling_iterator::operator++(int)$/;"	f	class:tree::sibling_iterator
operator ++	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator++()$/;"	f	class:tree::sibling_iterator
operator ++	merge_and_shrink/factored_transition_system.cc	/^void FTSConstIterator::operator++() {$/;"	f	class:merge_and_shrink::FTSConstIterator
operator ++	merge_and_shrink/transition_system.cc	/^void TSConstIterator::operator++() {$/;"	f	class:merge_and_shrink::TSConstIterator
operator ++	per_state_information.h	/^        const_iterator &operator++() {$/;"	f	class:PerStateInformation::const_iterator
operator ++	per_state_information.h	/^        const_iterator operator++(int) {$/;"	f	class:PerStateInformation::const_iterator
operator ++	task_proxy.h	/^    FactsProxyIterator &operator++() {$/;"	f	class:FactsProxyIterator
operator ++	task_proxy.h	/^    ProxyIterator &operator++() {$/;"	f	class:ProxyIterator
operator ++	task_proxy.h	/^    value_type operator++(int) {$/;"	f	class:ProxyIterator
operator +=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::breadth_first_queued_iterator& tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator+=(unsigned int num)$/;"	f	class:tree::breadth_first_queued_iterator
operator +=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator+=(unsigned int num)$/;"	f	class:tree::fixed_depth_iterator
operator +=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator+=(unsigned int num)$/;"	f	class:tree::leaf_iterator
operator +=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator+=(unsigned int num)$/;"	f	class:tree::post_order_iterator
operator +=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator+=(unsigned int num)$/;"	f	class:tree::pre_order_iterator
operator +=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator+=(unsigned int num)$/;"	f	class:tree::sibling_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator tree<T, tree_node_allocator>::fixed_depth_iterator::operator--(int)$/;"	f	class:tree::fixed_depth_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator--()$/;"	f	class:tree::fixed_depth_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator tree<T, tree_node_allocator>::leaf_iterator::operator--(int)$/;"	f	class:tree::leaf_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator--()$/;"	f	class:tree::leaf_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator tree<T, tree_node_allocator>::post_order_iterator::operator--(int)$/;"	f	class:tree::post_order_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator--()$/;"	f	class:tree::post_order_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::pre_order_iterator::operator--(int)$/;"	f	class:tree::pre_order_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator--()$/;"	f	class:tree::pre_order_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling_iterator::operator--(int)$/;"	f	class:tree::sibling_iterator
operator --	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator--()$/;"	f	class:tree::sibling_iterator
operator -=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::fixed_depth_iterator& tree<T, tree_node_allocator>::fixed_depth_iterator::operator-=(unsigned int num)$/;"	f	class:tree::fixed_depth_iterator
operator -=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::leaf_iterator& tree<T, tree_node_allocator>::leaf_iterator::operator-=(unsigned int num)$/;"	f	class:tree::leaf_iterator
operator -=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::post_order_iterator& tree<T, tree_node_allocator>::post_order_iterator::operator-=(unsigned int num)$/;"	f	class:tree::post_order_iterator
operator -=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator& tree<T, tree_node_allocator>::pre_order_iterator::operator-=(unsigned int num)$/;"	f	class:tree::pre_order_iterator
operator -=	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator& tree<T, tree_node_allocator>::sibling_iterator::operator-=(unsigned int num)$/;"	f	class:tree::sibling_iterator
operator ->	ext/tree.hh	/^T* tree<T, tree_node_allocator>::iterator_base::operator->() const$/;"	f	class:tree::iterator_base
operator ->	per_state_information.h	/^        StateID *operator->() {$/;"	f	class:PerStateInformation::const_iterator
operator <	abstract_task.h	/^    bool operator<(const FactPair &other) const {$/;"	f	struct:FactPair
operator <	landmarks/exploration.h	/^    bool operator<(const ExProposition &other) const {$/;"	f	struct:landmarks::ExProposition
operator <	landmarks/exploration.h	/^    bool operator<(const ExUnaryOperator &other) const {$/;"	f	struct:landmarks::ExUnaryOperator
operator <	merge_and_shrink/shrink_bisimulation.cc	/^    bool operator<(const Signature &other) const {$/;"	f	struct:merge_and_shrink::Signature
operator <	merge_and_shrink/transition_system.h	/^    bool operator<(const Transition &other) const {$/;"	f	struct:merge_and_shrink::Transition
operator <	search_engines/top_k_eager_search.h	/^	bool operator<(const StateActionPair &other) const {            $/;"	f	struct:top_k_eager_search::StateActionPair
operator <<	abstract_task.cc	/^ostream &operator<<(ostream &os, const FactPair &fact_pair) {$/;"	f
operator <<	abstract_task.cc	/^ostream &operator<<(ostream &os, const GlobalCondition &cond) {$/;"	f
operator <<	cegar/abstract_state.h	/^    friend std::ostream &operator<<(std::ostream &os, const AbstractState &state) {$/;"	f	class:cegar::AbstractState
operator <<	cegar/domains.cc	/^ostream &operator<<(ostream &os, const Domains &domains) {$/;"	f	namespace:cegar
operator <<	merge_and_shrink/transition_system.cc	/^ostream &operator<<(ostream &os, const Transition &trans) {$/;"	f	namespace:merge_and_shrink
operator <<	options/bounds.cc	/^ostream &operator<<(ostream &out, const Bounds &bounds) {$/;"	f	namespace:options
operator <<	options/errors.h	/^    friend std::ostream &operator<<(std::ostream &out, const ArgError &err) {$/;"	f	struct:options::ArgError
operator <<	options/errors.h	/^    friend std::ostream &operator<<(std::ostream &out, const ParseError &pe) {$/;"	f	struct:options::ParseError
operator <<	options/parse_tree.h	/^    friend std::ostream &operator<<(std::ostream &out, const ParseNode &pn) {$/;"	f	struct:options::ParseNode
operator <<	state_id.cc	/^ostream &operator<<(ostream &os, StateID id) {$/;"	f
operator <<	utils/countdown_timer.cc	/^ostream &operator<<(ostream &os, const CountdownTimer &cd_timer) {$/;"	f	namespace:utils
operator <<	utils/logging.h	/^    std::ostream &operator<<(const T &elem) {$/;"	f	struct:utils::Log
operator <<	utils/logging.h	/^ostream &operator<<(ostream &stream, const vector<T> &vec) {$/;"	f	namespace:std
operator <<	utils/timer.cc	/^ostream &operator<<(ostream &os, const Timer &timer) {$/;"	f	namespace:utils
operator =	bliss/uintseqhash.h	/^  UintSeqHash& operator=(const UintSeqHash &other) {h = other.h; return *this; }$/;"	f	class:bliss::UintSeqHash
operator =	ext/tree.hh	/^void tree<T, tree_node_allocator>::operator=(const tree<T, tree_node_allocator>& other)$/;"	f	class:tree
operator =	options/any.h	/^    Any &operator=(const Any &rhs) {$/;"	f	class:options::Any
operator =	options/any.h	/^    Any &operator=(const ValueType &rhs) {$/;"	f	class:options::Any
operator =	task_proxy.h	/^    State &operator=(const State &&other) {$/;"	f	class:State
operator ==	abstract_task.h	/^    bool operator==(const FactPair &other) const {$/;"	f	struct:FactPair
operator ==	cegar/transition.h	/^    bool operator==(const Transition &other) {$/;"	f	struct:cegar::Transition
operator ==	ext/tree.hh	/^bool tree<T, tree_node_allocator>::breadth_first_queued_iterator::operator==(const breadth_first_queued_iterator& other) const$/;"	f	class:tree::breadth_first_queued_iterator
operator ==	ext/tree.hh	/^bool tree<T, tree_node_allocator>::fixed_depth_iterator::operator==(const fixed_depth_iterator& other) const$/;"	f	class:tree::fixed_depth_iterator
operator ==	ext/tree.hh	/^bool tree<T, tree_node_allocator>::leaf_iterator::operator==(const leaf_iterator& other) const$/;"	f	class:tree::leaf_iterator
operator ==	ext/tree.hh	/^bool tree<T, tree_node_allocator>::post_order_iterator::operator==(const post_order_iterator& other) const$/;"	f	class:tree::post_order_iterator
operator ==	ext/tree.hh	/^bool tree<T, tree_node_allocator>::pre_order_iterator::operator==(const pre_order_iterator& other) const$/;"	f	class:tree::pre_order_iterator
operator ==	ext/tree.hh	/^bool tree<T, tree_node_allocator>::sibling_iterator::operator==(const sibling_iterator& other) const$/;"	f	class:tree::sibling_iterator
operator ==	global_operator.h	/^    bool operator==(const GlobalCondition &other) const {$/;"	f	struct:GlobalCondition
operator ==	merge_and_shrink/factored_transition_system.h	/^    bool operator==(const FTSConstIterator &rhs) const {$/;"	f	class:merge_and_shrink::FTSConstIterator
operator ==	merge_and_shrink/transition_system.h	/^    bool operator==(const TSConstIterator &rhs) const {$/;"	f	class:merge_and_shrink::TSConstIterator
operator ==	merge_and_shrink/transition_system.h	/^    bool operator==(const Transition &other) const {$/;"	f	struct:merge_and_shrink::Transition
operator ==	per_state_information.h	/^        bool operator==(const const_iterator &rhs) {$/;"	f	class:PerStateInformation::const_iterator
operator ==	state_id.h	/^    bool operator==(const StateID &other) const {$/;"	f	class:StateID
operator ==	task_proxy.h	/^    bool operator==(const FactProxy &other) const {$/;"	f	class:FactProxy
operator ==	task_proxy.h	/^    bool operator==(const FactsProxyIterator &other) const {$/;"	f	class:FactsProxyIterator
operator ==	task_proxy.h	/^    bool operator==(const OperatorProxy &other) const {$/;"	f	class:OperatorProxy
operator ==	task_proxy.h	/^    bool operator==(const ProxyIterator &other) const {$/;"	f	class:ProxyIterator
operator ==	task_proxy.h	/^    bool operator==(const State &other) const {$/;"	f	class:State
operator ==	task_proxy.h	/^    bool operator==(const VariableProxy &other) const {$/;"	f	class:VariableProxy
operator >	open_lists/epsilon_greedy_open_list.cc	/^        bool operator>(const HeapNode &other) const {$/;"	f	struct:EpsilonGreedyOpenList::HeapNode
operator >=	merge_and_shrink/transition_system.h	/^    bool operator>=(const Transition &other) const {$/;"	f	struct:merge_and_shrink::Transition
operator []	algorithms/dynamic_bitset.h	/^    bool operator[](std::size_t pos) const {$/;"	f	class:dynamic_bitset::DynamicBitset
operator []	algorithms/ordered_set.h	/^    const T &operator[](int pos) const {$/;"	f	class:ordered_set::OrderedSet
operator []	algorithms/segmented_vector.h	/^    Element *operator[](size_t index) {$/;"	f	class:segmented_vector::SegmentedArrayVector
operator []	algorithms/segmented_vector.h	/^    Entry &operator[](size_t index) {$/;"	f	class:segmented_vector::SegmentedVector
operator []	algorithms/segmented_vector.h	/^    const Element *operator[](size_t index) const {$/;"	f	class:segmented_vector::SegmentedArrayVector
operator []	algorithms/segmented_vector.h	/^    const Entry &operator[](size_t index) const {$/;"	f	class:segmented_vector::SegmentedVector
operator []	global_state.cc	/^int GlobalState::operator[](int var) const {$/;"	f	class:GlobalState
operator []	heuristic_cache.cc	/^EvaluationResult &HeuristicCache::operator[](ScalarEvaluator *heur) {$/;"	f	class:HeuristicCache
operator []	per_state_information.h	/^    Entry &operator[](const GlobalState &state) {$/;"	f	class:PerStateInformation
operator []	per_state_information.h	/^    const Entry &operator[](const GlobalState &state) const {$/;"	f	class:PerStateInformation
operator []	task_proxy.h	/^    EffectProxy operator[](std::size_t eff_index) const {$/;"	f	class:EffectsProxy
operator []	task_proxy.h	/^    FactProxy operator[](VariableProxy var) const {$/;"	f	class:State
operator []	task_proxy.h	/^    FactProxy operator[](std::size_t var_id) const {$/;"	f	class:State
operator []	task_proxy.h	/^    OperatorProxy operator[](std::size_t index) const {$/;"	f	class:AxiomsProxy
operator []	task_proxy.h	/^    OperatorProxy operator[](std::size_t index) const {$/;"	f	class:OperatorsProxy
operator []	task_proxy.h	/^    VariableProxy operator[](std::size_t index) const {$/;"	f	class:VariablesProxy
operator_achieves_fact	cegar/utils.cc	/^static bool operator_achieves_fact($/;"	f	namespace:cegar
operator_applicable	cegar/utils.cc	/^static bool operator_applicable($/;"	f	namespace:cegar
operator_applicable	landmarks/landmark_factory_zhu_givan.cc	/^bool LandmarkFactoryZhuGivan::operator_applicable(const OperatorProxy &op,$/;"	f	class:landmarks::LandmarkFactoryZhuGivan
operator_cond_effect_fires	landmarks/landmark_factory_zhu_givan.cc	/^bool LandmarkFactoryZhuGivan::operator_cond_effect_fires($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
operator_costs	cegar/abstract_search.h	/^    const std::vector<int> operator_costs;$/;"	m	class:cegar::AbstractSearch
operator_costs	landmarks/landmark_cost_assignment.h	/^    const std::vector<int> operator_costs;$/;"	m	class:landmarks::LandmarkCostAssignment
operator_costs	tasks/modified_operator_costs_task.h	/^    const std::vector<int> operator_costs;$/;"	m	class:extra_tasks::ModifiedOperatorCostsTask
operator_counting	operator_counting/constraint_generator.cc	/^namespace operator_counting {$/;"	n	file:
operator_counting	operator_counting/constraint_generator.h	/^namespace operator_counting {$/;"	n
operator_counting	operator_counting/lm_cut_constraints.cc	/^namespace operator_counting {$/;"	n	file:
operator_counting	operator_counting/lm_cut_constraints.h	/^namespace operator_counting {$/;"	n
operator_counting	operator_counting/operator_counting_heuristic.cc	/^namespace operator_counting {$/;"	n	file:
operator_counting	operator_counting/operator_counting_heuristic.h	/^namespace operator_counting {$/;"	n
operator_counting	operator_counting/pho_constraints.cc	/^namespace operator_counting {$/;"	n	file:
operator_counting	operator_counting/pho_constraints.h	/^namespace operator_counting {$/;"	n
operator_counting	operator_counting/state_equation_constraints.cc	/^namespace operator_counting {$/;"	n	file:
operator_counting	operator_counting/state_equation_constraints.h	/^namespace operator_counting {$/;"	n
operator_counting	options/option_parser.cc	/^namespace operator_counting {$/;"	n	file:
operator_generators	structural_symmetries/group.h	/^    std::vector<const OperatorPermutation *> operator_generators;$/;"	m	class:Group
operator_no	heuristics/relaxation_heuristic.h	/^    int operator_no; \/\/ -1 for axioms; index into g_operators otherwise$/;"	m	struct:relaxation_heuristic::UnaryOperator
operators_eff_lookup	landmarks/landmark_graph.h	/^    std::vector<std::vector<std::vector<int>>> operators_eff_lookup;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
operators_on_plan	tasks/plan_forbid_reformulated_task.h	/^	int operators_on_plan;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
operators_without_preconditions	landmarks/landmark_factory_zhu_givan.h	/^    std::vector<int> operators_without_preconditions;$/;"	m	class:landmarks::LandmarkFactoryZhuGivan
ops_affected	structural_symmetries/operator_permutation.h	/^    std::vector<int> ops_affected;$/;"	m	class:OperatorPermutation
opt_use_comprec	bliss/graph.h	/^  bool opt_use_comprec;$/;"	m	class:bliss::AbstractGraph
opt_use_failure_recording	bliss/graph.h	/^  bool opt_use_failure_recording;$/;"	m	class:bliss::AbstractGraph
opt_use_long_prune	bliss/graph.h	/^  bool opt_use_long_prune;$/;"	m	class:bliss::AbstractGraph
optimal_solution_cost	search_engines/kstar.h	/^	int optimal_solution_cost;$/;"	m	class:kstar::KStar
optimize_for_all_states	potentials/potential_optimizer.cc	/^void PotentialOptimizer::optimize_for_all_states() {$/;"	f	class:potentials::PotentialOptimizer
optimize_for_samples	potentials/potential_optimizer.cc	/^void PotentialOptimizer::optimize_for_samples(const vector<State> &samples) {$/;"	f	class:potentials::PotentialOptimizer
optimize_for_samples	potentials/sample_based_potential_heuristics.cc	/^static void optimize_for_samples($/;"	f	namespace:potentials
optimize_for_state	potentials/potential_optimizer.cc	/^void PotentialOptimizer::optimize_for_state(const State &state) {$/;"	f	class:potentials::PotentialOptimizer
optimizer	potentials/diverse_potential_heuristics.h	/^    PotentialOptimizer optimizer;$/;"	m	class:potentials::DiversePotentialHeuristics
options	abstract_task.h	/^namespace options {$/;"	n
options	cegar/subtask_generators.h	/^namespace options {$/;"	n
options	evaluators/max_evaluator.h	/^namespace options {$/;"	n
options	evaluators/sum_evaluator.h	/^namespace options {$/;"	n
options	evaluators/weighted_evaluator.h	/^namespace options {$/;"	n
options	heuristic.h	/^namespace options {$/;"	n
options	heuristics/hm_heuristic.h	/^namespace options {$/;"	n
options	heuristics/lm_cut_heuristic.h	/^namespace options {$/;"	n
options	landmarks/landmark_factory.h	/^namespace options {$/;"	n
options	lp/lp_solver.h	/^namespace options {$/;"	n
options	merge_and_shrink/label_reduction.h	/^namespace options {$/;"	n
options	merge_and_shrink/merge_scoring_function_single_random.h	/^namespace options {$/;"	n
options	merge_and_shrink/merge_scoring_function_total_order.h	/^namespace options {$/;"	n
options	merge_and_shrink/merge_selector_score_based_filtering.h	/^namespace options {$/;"	n
options	merge_and_shrink/merge_strategy_factory_precomputed.h	/^namespace options {$/;"	n
options	merge_and_shrink/merge_strategy_factory_stateless.h	/^namespace options {$/;"	n
options	merge_and_shrink/merge_tree_factory.h	/^namespace options {$/;"	n
options	merge_and_shrink/shrink_bisimulation.h	/^namespace options {$/;"	n
options	merge_and_shrink/shrink_bucket_based.h	/^namespace options {$/;"	n
options	merge_and_shrink/shrink_fh.h	/^namespace options {$/;"	n
options	merge_and_shrink/shrink_random.h	/^namespace options {$/;"	n
options	open_lists/alternation_open_list.h	/^    Options options;$/;"	m	class:AlternationOpenListFactory
options	open_lists/epsilon_greedy_open_list.h	/^    Options options;$/;"	m	class:EpsilonGreedyOpenListFactory
options	open_lists/pareto_open_list.h	/^    Options options;$/;"	m	class:ParetoOpenListFactory
options	open_lists/standard_scalar_open_list.h	/^    Options options;$/;"	m	class:StandardScalarOpenListFactory
options	open_lists/tiebreaking_open_list.h	/^    Options options;$/;"	m	class:TieBreakingOpenListFactory
options	open_lists/type_based_open_list.h	/^    Options options;$/;"	m	class:TypeBasedOpenListFactory
options	operator_cost.h	/^namespace options {$/;"	n
options	operator_counting/operator_counting_heuristic.h	/^namespace options {$/;"	n
options	operator_counting/pho_constraints.h	/^namespace options {$/;"	n
options	options/any.h	/^namespace options {$/;"	n
options	options/bounds.cc	/^namespace options {$/;"	n	file:
options	options/bounds.h	/^namespace options {$/;"	n
options	options/doc_printer.cc	/^namespace options {$/;"	n	file:
options	options/doc_printer.h	/^namespace options {$/;"	n
options	options/doc_store.cc	/^namespace options {$/;"	n	file:
options	options/doc_store.h	/^namespace options {$/;"	n
options	options/errors.cc	/^namespace options {$/;"	n	file:
options	options/errors.h	/^namespace options {$/;"	n
options	options/option_parser.cc	/^namespace options {$/;"	n	file:
options	options/option_parser.h	/^namespace options {$/;"	n
options	options/options.h	/^namespace options {$/;"	n
options	options/parse_tree.h	/^namespace options {$/;"	n
options	options/plugin.cc	/^namespace options {$/;"	n	file:
options	options/plugin.h	/^namespace options {$/;"	n
options	options/predefinitions.h	/^namespace options {$/;"	n
options	options/registries.cc	/^namespace options {$/;"	n	file:
options	options/registries.h	/^namespace options {$/;"	n
options	options/synergy.h	/^namespace options {$/;"	n
options	options/token_parser.h	/^namespace options {$/;"	n
options	options/type_documenter.h	/^namespace options {$/;"	n
options	options/type_namer.h	/^namespace options {$/;"	n
options	pdbs/pattern_collection_generator_genetic.h	/^namespace options {$/;"	n
options	pdbs/pattern_collection_generator_hillclimbing.h	/^namespace options {$/;"	n
options	pdbs/pattern_collection_generator_manual.h	/^namespace options {$/;"	n
options	pdbs/pattern_collection_generator_systematic.h	/^namespace options {$/;"	n
options	pdbs/pattern_generator_greedy.h	/^namespace options {$/;"	n
options	pdbs/pattern_generator_manual.h	/^namespace options {$/;"	n
options	pdbs/pdb_heuristic.h	/^namespace options {$/;"	n
options	potentials/potential_optimizer.h	/^namespace options {$/;"	n
options	potentials/util.h	/^namespace options {$/;"	n
options	search_engine.h	/^namespace options {$/;"	n
options	search_engines/eager_search.h	/^namespace options {$/;"	n
options	search_engines/enforced_hill_climbing_search.h	/^namespace options {$/;"	n
options	search_engines/iterated_search.h	/^namespace options {$/;"	n
options	search_engines/lazy_search.h	/^namespace options {$/;"	n
options	search_engines/search_common.h	/^namespace options {$/;"	n
options	search_engines/top_k_eager_search.h	/^namespace options {$/;"	n
options	structural_symmetries/graph_creator.h	/^namespace options {$/;"	n
options	structural_symmetries/group.h	/^namespace options {$/;"	n
options	tasks/cost_adapted_task.h	/^namespace options {$/;"	n
options	utils/rng_options.h	/^namespace options {$/;"	n
opts	options/option_parser.h	/^    Options opts;$/;"	m	class:options::OptionParser
orbit_size	bliss/orbit.cc	/^unsigned int Orbit::orbit_size(unsigned int element) const$/;"	f	class:bliss::Orbit
orbits	bliss/orbit.h	/^  OrbitEntry *orbits;$/;"	m	class:bliss::Orbit
order	structural_symmetries/permutation.h	/^    int order;$/;"	m	class:Permutation
order_facts	cegar/subtask_generators.cc	/^static void order_facts($/;"	f	namespace:cegar
ordered_buckets_use_map	merge_and_shrink/shrink_fh.cc	/^void ShrinkFH::ordered_buckets_use_map($/;"	f	class:merge_and_shrink::ShrinkFH
ordered_buckets_use_vector	merge_and_shrink/shrink_fh.cc	/^void ShrinkFH::ordered_buckets_use_vector($/;"	f	class:merge_and_shrink::ShrinkFH
ordered_items	algorithms/ordered_set.h	/^    std::vector<T> ordered_items;$/;"	m	class:ordered_set::OrderedSet
ordered_nodes	landmarks/landmark_graph.h	/^    std::vector<LandmarkNode *> ordered_nodes;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
ordered_set	algorithms/ordered_set.h	/^namespace ordered_set {$/;"	n
ordered_set	search_engine.h	/^namespace ordered_set {$/;"	n
original_op_id	heuristics/lm_cut_landmarks.h	/^    int original_op_id;$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
os	options/doc_printer.h	/^    std::ostream &os;$/;"	m	class:options::DocPrinter
other	merge_and_shrink/fts_factory.cc	/^        TransitionSystemData &operator=(TransitionSystemData &other) = delete;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
other	merge_and_shrink/fts_factory.cc	/^        TransitionSystemData(TransitionSystemData &other) = delete;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
other	options/option_parser.h	/^    OptionParser &operator=(const OptionParser &other) = delete;$/;"	m	class:options::OptionParser
other	options/option_parser.h	/^    OptionParser(const OptionParser &other) = delete;$/;"	m	class:options::OptionParser
other	options/plugin.h	/^    Plugin(const Plugin<T> &other) = delete;$/;"	m	class:options::Plugin
other	options/plugin.h	/^    PluginShared(const PluginShared<T> &other) = delete;$/;"	m	class:options::PluginShared
other	options/plugin.h	/^    PluginTypePlugin(const PluginTypePlugin &other) = delete;$/;"	m	class:options::PluginTypePlugin
out_of_memory_handler	structural_symmetries/graph_creator.cc	/^static void out_of_memory_handler() {$/;"	f	file:
out_of_memory_handler	utils/system_unix.cc	/^void out_of_memory_handler() {$/;"	f	namespace:utils
out_of_memory_handler	utils/system_windows.cc	/^void out_of_memory_handler() {$/;"	f	namespace:utils
outdegree_invariant	bliss/graph.cc	/^Digraph::outdegree_invariant(const Digraph* const g, const unsigned int vnum)$/;"	f	class:bliss::Digraph
outgoing_transitions	cegar/abstract_state.h	/^    Transitions outgoing_transitions;$/;"	m	class:cegar::AbstractState
outgoing_transitions	heuristics/cea_heuristic.cc	/^    vector<LocalTransition> outgoing_transitions;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
output_plans	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::output_plans() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
override	cegar/additive_cartesian_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:cegar::AdditiveCartesianHeuristic
override	cegar/subtask_generators.h	/^        const std::shared_ptr<AbstractTask> &task) const override;$/;"	m	class:cegar::GoalDecomposition
override	cegar/subtask_generators.h	/^        const std::shared_ptr<AbstractTask> &task) const override;$/;"	m	class:cegar::LandmarkDecomposition
override	cegar/subtask_generators.h	/^        const std::shared_ptr<AbstractTask> &task) const override;$/;"	m	class:cegar::TaskDuplicator
override	evaluators/combining_evaluator.h	/^        EvaluationContext &eval_context) override;$/;"	m	class:combining_evaluator::CombiningEvaluator
override	evaluators/combining_evaluator.h	/^    virtual bool dead_ends_are_reliable() const override;$/;"	m	class:combining_evaluator::CombiningEvaluator
override	evaluators/combining_evaluator.h	/^    virtual void get_involved_heuristics(std::set<Heuristic *> &hset) override;$/;"	m	class:combining_evaluator::CombiningEvaluator
override	evaluators/combining_evaluator.h	/^    virtual ~CombiningEvaluator() override;$/;"	m	class:combining_evaluator::CombiningEvaluator
override	evaluators/const_evaluator.h	/^    virtual int compute_heuristic(const GlobalState &) override;$/;"	m	class:const_evaluator::ConstEvaluator
override	evaluators/const_evaluator.h	/^    virtual ~ConstEvaluator() override = default;$/;"	m	class:const_evaluator::ConstEvaluator
override	evaluators/g_evaluator.h	/^        EvaluationContext &eval_context) override;$/;"	m	class:g_evaluator::GEvaluator
override	evaluators/g_evaluator.h	/^    virtual ~GEvaluator() override = default;$/;"	m	class:g_evaluator::GEvaluator
override	evaluators/max_evaluator.h	/^    virtual int combine_values(const std::vector<int> &values) override;$/;"	m	class:max_evaluator::MaxEvaluator
override	evaluators/max_evaluator.h	/^    virtual ~MaxEvaluator() override;$/;"	m	class:max_evaluator::MaxEvaluator
override	evaluators/pref_evaluator.h	/^        EvaluationContext &eval_context) override;$/;"	m	class:pref_evaluator::PrefEvaluator
override	evaluators/pref_evaluator.h	/^    virtual ~PrefEvaluator() override;$/;"	m	class:pref_evaluator::PrefEvaluator
override	evaluators/sum_evaluator.h	/^    virtual int combine_values(const std::vector<int> &values) override;$/;"	m	class:sum_evaluator::SumEvaluator
override	evaluators/sum_evaluator.h	/^    virtual ~SumEvaluator() override;$/;"	m	class:sum_evaluator::SumEvaluator
override	evaluators/weighted_evaluator.h	/^        EvaluationContext &eval_context) override;$/;"	m	class:weighted_evaluator::WeightedEvaluator
override	evaluators/weighted_evaluator.h	/^    virtual bool dead_ends_are_reliable() const override;$/;"	m	class:weighted_evaluator::WeightedEvaluator
override	evaluators/weighted_evaluator.h	/^    virtual void get_involved_heuristics(std::set<Heuristic *> &hset) override;$/;"	m	class:weighted_evaluator::WeightedEvaluator
override	evaluators/weighted_evaluator.h	/^    virtual ~WeightedEvaluator() override;$/;"	m	class:weighted_evaluator::WeightedEvaluator
override	heuristic.h	/^        EvaluationContext &eval_context) override;$/;"	m	class:Heuristic
override	heuristic.h	/^    virtual ~Heuristic() override;$/;"	m	class:Heuristic
override	heuristics/lm_cut_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:lm_cut_heuristic::LandmarkCutHeuristic
override	heuristics/lm_cut_heuristic.h	/^    virtual ~LandmarkCutHeuristic() override;$/;"	m	class:lm_cut_heuristic::LandmarkCutHeuristic
override	landmarks/exploration.h	/^    virtual int compute_heuristic(const GlobalState &state) override;$/;"	m	class:landmarks::Exploration
override	landmarks/lama_ff_synergy.cc	/^    virtual ~FFSlaveHeuristic() override = default;$/;"	m	class:landmarks::FFSlaveHeuristic	file:
override	landmarks/lama_ff_synergy.cc	/^    virtual ~LamaMasterHeuristic() override = default;$/;"	m	class:landmarks::LamaMasterHeuristic	file:
override	landmarks/landmark_cost_assignment.h	/^    virtual double cost_sharing_h_value() override;$/;"	m	class:landmarks::LandmarkEfficientOptimalSharedCostAssignment
override	landmarks/landmark_cost_assignment.h	/^    virtual double cost_sharing_h_value() override;$/;"	m	class:landmarks::LandmarkUniformSharedCostAssignment
override	landmarks/landmark_count_heuristic.h	/^                                         const GlobalState &state) override;$/;"	m	class:landmarks::LandmarkCountHeuristic
override	landmarks/landmark_count_heuristic.h	/^    virtual bool dead_ends_are_reliable() const override;$/;"	m	class:landmarks::LandmarkCountHeuristic
override	landmarks/landmark_count_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &state) override;$/;"	m	class:landmarks::LandmarkCountHeuristic
override	landmarks/landmark_count_heuristic.h	/^    virtual void notify_initial_state(const GlobalState &initial_state) override;$/;"	m	class:landmarks::LandmarkCountHeuristic
override	landmarks/landmark_factory_h_m.h	/^                                    Exploration &exploration) override;$/;"	m	class:landmarks::LandmarkFactoryHM
override	landmarks/landmark_factory_h_m.h	/^    virtual bool supports_conditional_effects() const override;$/;"	m	class:landmarks::LandmarkFactoryHM
override	landmarks/landmark_factory_h_m.h	/^    virtual void calc_achievers(const TaskProxy &task_proxy, Exploration &exploration) override;$/;"	m	class:landmarks::LandmarkFactoryHM
override	landmarks/landmark_factory_merged.h	/^    virtual bool supports_conditional_effects() const override;$/;"	m	class:landmarks::LandmarkFactoryMerged
override	landmarks/landmark_factory_merged.h	/^    virtual void generate_landmarks(const std::shared_ptr<AbstractTask> &task, Exploration &exploration) override;$/;"	m	class:landmarks::LandmarkFactoryMerged
override	landmarks/landmark_factory_rpg_exhaust.h	/^                                    Exploration &exploration) override;$/;"	m	class:landmarks::LandmarkFactoryRpgExhaust
override	landmarks/landmark_factory_rpg_exhaust.h	/^    virtual bool supports_conditional_effects() const override;$/;"	m	class:landmarks::LandmarkFactoryRpgExhaust
override	landmarks/landmark_factory_rpg_sasp.h	/^                                    Exploration &exploration) override;$/;"	m	class:landmarks::LandmarkFactoryRpgSasp
override	landmarks/landmark_factory_rpg_sasp.h	/^    virtual bool supports_conditional_effects() const override;$/;"	m	class:landmarks::LandmarkFactoryRpgSasp
override	landmarks/landmark_factory_zhu_givan.h	/^                                    Exploration &exploration) override;$/;"	m	class:landmarks::LandmarkFactoryZhuGivan
override	landmarks/landmark_factory_zhu_givan.h	/^    virtual bool supports_conditional_effects() const override;$/;"	m	class:landmarks::LandmarkFactoryZhuGivan
override	merge_and_shrink/merge_and_shrink_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
override	merge_and_shrink/merge_and_shrink_heuristic.h	/^    virtual ~MergeAndShrinkHeuristic() override = default;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
override	merge_and_shrink/merge_and_shrink_representation.h	/^        const std::vector<int> &abstraction_mapping) override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
override	merge_and_shrink/merge_and_shrink_representation.h	/^        const std::vector<int> &abstraction_mapping) override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
override	merge_and_shrink/merge_and_shrink_representation.h	/^    virtual int get_value(const State &state) const override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
override	merge_and_shrink/merge_and_shrink_representation.h	/^    virtual int get_value(const State &state) const override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
override	merge_and_shrink/merge_and_shrink_representation.h	/^    virtual void dump() const override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
override	merge_and_shrink/merge_and_shrink_representation.h	/^    virtual void dump() const override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
override	merge_and_shrink/merge_and_shrink_representation.h	/^    virtual void set_distances(const Distances &) override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
override	merge_and_shrink/merge_and_shrink_representation.h	/^    virtual void set_distances(const Distances &distances) override;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
override	merge_and_shrink/merge_scoring_function_dfp.h	/^        const std::vector<std::pair<int, int>> &merge_candidates) override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionDFP
override	merge_and_shrink/merge_scoring_function_dfp.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionDFP
override	merge_and_shrink/merge_scoring_function_dfp.h	/^    virtual ~MergeScoringFunctionDFP() override = default;$/;"	m	class:merge_and_shrink::MergeScoringFunctionDFP
override	merge_and_shrink/merge_scoring_function_goal_relevance.h	/^        const std::vector<std::pair<int, int>> &merge_candidates) override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionGoalRelevance
override	merge_and_shrink/merge_scoring_function_goal_relevance.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionGoalRelevance
override	merge_and_shrink/merge_scoring_function_goal_relevance.h	/^    virtual ~MergeScoringFunctionGoalRelevance() override = default;$/;"	m	class:merge_and_shrink::MergeScoringFunctionGoalRelevance
override	merge_and_shrink/merge_scoring_function_single_random.h	/^        const std::vector<std::pair<int, int>> &merge_candidates) override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionSingleRandom
override	merge_and_shrink/merge_scoring_function_single_random.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionSingleRandom
override	merge_and_shrink/merge_scoring_function_single_random.h	/^    virtual void dump_function_specific_options() const override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionSingleRandom
override	merge_and_shrink/merge_scoring_function_single_random.h	/^    virtual ~MergeScoringFunctionSingleRandom() override = default;$/;"	m	class:merge_and_shrink::MergeScoringFunctionSingleRandom
override	merge_and_shrink/merge_scoring_function_total_order.h	/^        const std::vector<std::pair<int, int>> &merge_candidates) override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
override	merge_and_shrink/merge_scoring_function_total_order.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
override	merge_and_shrink/merge_scoring_function_total_order.h	/^    virtual void dump_function_specific_options() const override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
override	merge_and_shrink/merge_scoring_function_total_order.h	/^    virtual void initialize(const TaskProxy &task_proxy) override;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
override	merge_and_shrink/merge_scoring_function_total_order.h	/^    virtual ~MergeScoringFunctionTotalOrder() override = default;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
override	merge_and_shrink/merge_selector_score_based_filtering.h	/^        const std::vector<int> &indices_subset = std::vector<int>()) const override;$/;"	m	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
override	merge_and_shrink/merge_selector_score_based_filtering.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
override	merge_and_shrink/merge_selector_score_based_filtering.h	/^    virtual void dump_specific_options() const override;$/;"	m	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
override	merge_and_shrink/merge_selector_score_based_filtering.h	/^    virtual void initialize(const TaskProxy &task_proxy) override;$/;"	m	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
override	merge_and_shrink/merge_selector_score_based_filtering.h	/^    virtual ~MergeSelectorScoreBasedFiltering() override = default;$/;"	m	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
override	merge_and_shrink/merge_strategy_factory_precomputed.h	/^        FactoredTransitionSystem &fts) override;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
override	merge_and_shrink/merge_strategy_factory_precomputed.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
override	merge_and_shrink/merge_strategy_factory_precomputed.h	/^    virtual void dump_strategy_specific_options() const override;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
override	merge_and_shrink/merge_strategy_factory_precomputed.h	/^    virtual ~MergeStrategyFactoryPrecomputed() override = default;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryPrecomputed
override	merge_and_shrink/merge_strategy_factory_stateless.h	/^        FactoredTransitionSystem &fts) override;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryStateless
override	merge_and_shrink/merge_strategy_factory_stateless.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryStateless
override	merge_and_shrink/merge_strategy_factory_stateless.h	/^    virtual void dump_strategy_specific_options() const override;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryStateless
override	merge_and_shrink/merge_strategy_factory_stateless.h	/^    virtual ~MergeStrategyFactoryStateless() override = default;$/;"	m	class:merge_and_shrink::MergeStrategyFactoryStateless
override	merge_and_shrink/merge_strategy_precomputed.h	/^    virtual std::pair<int, int> get_next() override;$/;"	m	class:merge_and_shrink::MergeStrategyPrecomputed
override	merge_and_shrink/merge_strategy_precomputed.h	/^    virtual ~MergeStrategyPrecomputed() override = default;$/;"	m	class:merge_and_shrink::MergeStrategyPrecomputed
override	merge_and_shrink/merge_strategy_stateless.h	/^    virtual std::pair<int, int> get_next() override;$/;"	m	class:merge_and_shrink::MergeStrategyStateless
override	merge_and_shrink/merge_strategy_stateless.h	/^    virtual ~MergeStrategyStateless() override = default;$/;"	m	class:merge_and_shrink::MergeStrategyStateless
override	merge_and_shrink/merge_tree_factory_linear.h	/^        const TaskProxy &task_proxy) override;$/;"	m	class:merge_and_shrink::MergeTreeFactoryLinear
override	merge_and_shrink/merge_tree_factory_linear.h	/^        const std::vector<int> &indices_subset) override;$/;"	m	class:merge_and_shrink::MergeTreeFactoryLinear
override	merge_and_shrink/merge_tree_factory_linear.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::MergeTreeFactoryLinear
override	merge_and_shrink/merge_tree_factory_linear.h	/^    virtual void dump_tree_specific_options() const override;$/;"	m	class:merge_and_shrink::MergeTreeFactoryLinear
override	merge_and_shrink/merge_tree_factory_linear.h	/^    virtual ~MergeTreeFactoryLinear() override = default;$/;"	m	class:merge_and_shrink::MergeTreeFactoryLinear
override	merge_and_shrink/shrink_bisimulation.h	/^        Verbosity verbosity) const override;$/;"	m	class:merge_and_shrink::ShrinkBisimulation
override	merge_and_shrink/shrink_bisimulation.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::ShrinkBisimulation
override	merge_and_shrink/shrink_bisimulation.h	/^    virtual void dump_strategy_specific_options() const override;$/;"	m	class:merge_and_shrink::ShrinkBisimulation
override	merge_and_shrink/shrink_bisimulation.h	/^    virtual ~ShrinkBisimulation() override = default;$/;"	m	class:merge_and_shrink::ShrinkBisimulation
override	merge_and_shrink/shrink_bucket_based.h	/^        Verbosity verbosity) const override;$/;"	m	class:merge_and_shrink::ShrinkBucketBased
override	merge_and_shrink/shrink_bucket_based.h	/^    virtual ~ShrinkBucketBased() override = default;$/;"	m	class:merge_and_shrink::ShrinkBucketBased
override	merge_and_shrink/shrink_fh.h	/^        std::vector<Bucket> &buckets) const override;$/;"	m	class:merge_and_shrink::ShrinkFH
override	merge_and_shrink/shrink_fh.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::ShrinkFH
override	merge_and_shrink/shrink_fh.h	/^    virtual void dump_strategy_specific_options() const override;$/;"	m	class:merge_and_shrink::ShrinkFH
override	merge_and_shrink/shrink_fh.h	/^    virtual ~ShrinkFH() override = default;$/;"	m	class:merge_and_shrink::ShrinkFH
override	merge_and_shrink/shrink_random.h	/^        std::vector<Bucket> &buckets) const override;$/;"	m	class:merge_and_shrink::ShrinkRandom
override	merge_and_shrink/shrink_random.h	/^    virtual std::string name() const override;$/;"	m	class:merge_and_shrink::ShrinkRandom
override	merge_and_shrink/shrink_random.h	/^    virtual ~ShrinkRandom() override = default;$/;"	m	class:merge_and_shrink::ShrinkRandom
override	open_lists/alternation_open_list.cc	/^                              const Entry &entry) override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^        EvaluationContext &eval_context) const override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual Entry remove_min(vector<int> *key = nullptr) override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual Entry top() override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual bool empty() const override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual void boost_preferred() override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual void clear() override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.cc	/^    virtual ~AlternationOpenList() override = default;$/;"	m	class:AlternationOpenList	file:
override	open_lists/alternation_open_list.h	/^    virtual std::unique_ptr<EdgeOpenList> create_edge_open_list() override;$/;"	m	class:AlternationOpenListFactory
override	open_lists/alternation_open_list.h	/^    virtual std::unique_ptr<StateOpenList> create_state_open_list() override;$/;"	m	class:AlternationOpenListFactory
override	open_lists/alternation_open_list.h	/^    virtual ~AlternationOpenListFactory() override = default;$/;"	m	class:AlternationOpenListFactory
override	open_lists/epsilon_greedy_open_list.cc	/^                              const Entry &entry) override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^        EvaluationContext &eval_context) const override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^    virtual Entry remove_min(vector<int> *key = nullptr) override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^    virtual Entry top() override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^    virtual bool empty() const override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^    virtual void clear() override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.cc	/^    virtual ~EpsilonGreedyOpenList() override = default;$/;"	m	class:EpsilonGreedyOpenList	file:
override	open_lists/epsilon_greedy_open_list.h	/^    virtual std::unique_ptr<EdgeOpenList> create_edge_open_list() override;$/;"	m	class:EpsilonGreedyOpenListFactory
override	open_lists/epsilon_greedy_open_list.h	/^    virtual std::unique_ptr<StateOpenList> create_state_open_list() override;$/;"	m	class:EpsilonGreedyOpenListFactory
override	open_lists/epsilon_greedy_open_list.h	/^    virtual ~EpsilonGreedyOpenListFactory() override = default;$/;"	m	class:EpsilonGreedyOpenListFactory
override	open_lists/pareto_open_list.cc	/^                              const Entry &entry) override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^        EvaluationContext &eval_context) const override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^    virtual Entry remove_min(vector<int> *key = nullptr) override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^    virtual Entry top() override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^    virtual bool empty() const override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^    virtual void clear() override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.cc	/^    virtual ~ParetoOpenList() override = default;$/;"	m	class:ParetoOpenList	file:
override	open_lists/pareto_open_list.h	/^    virtual std::unique_ptr<EdgeOpenList> create_edge_open_list() override;$/;"	m	class:ParetoOpenListFactory
override	open_lists/pareto_open_list.h	/^    virtual std::unique_ptr<StateOpenList> create_state_open_list() override;$/;"	m	class:ParetoOpenListFactory
override	open_lists/pareto_open_list.h	/^    virtual ~ParetoOpenListFactory() override = default;$/;"	m	class:ParetoOpenListFactory
override	open_lists/standard_scalar_open_list.cc	/^                              const Entry &entry) override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^        EvaluationContext &eval_context) const override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^    virtual Entry remove_min(vector<int> *key = nullptr) override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^    virtual Entry top() override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^    virtual bool empty() const override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^    virtual void clear() override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.cc	/^    virtual ~StandardScalarOpenList() override = default;$/;"	m	class:StandardScalarOpenList	file:
override	open_lists/standard_scalar_open_list.h	/^    virtual std::unique_ptr<EdgeOpenList> create_edge_open_list() override;$/;"	m	class:StandardScalarOpenListFactory
override	open_lists/standard_scalar_open_list.h	/^    virtual std::unique_ptr<StateOpenList> create_state_open_list() override;$/;"	m	class:StandardScalarOpenListFactory
override	open_lists/standard_scalar_open_list.h	/^    virtual ~StandardScalarOpenListFactory() override = default;$/;"	m	class:StandardScalarOpenListFactory
override	open_lists/tiebreaking_open_list.cc	/^                              const Entry &entry) override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^        EvaluationContext &eval_context) const override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^    virtual Entry remove_min(vector<int> *key = nullptr) override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^    virtual Entry top() override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^    virtual bool empty() const override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^    virtual void clear() override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.cc	/^    virtual ~TieBreakingOpenList() override = default;$/;"	m	class:TieBreakingOpenList	file:
override	open_lists/tiebreaking_open_list.h	/^    virtual std::unique_ptr<EdgeOpenList> create_edge_open_list() override;$/;"	m	class:TieBreakingOpenListFactory
override	open_lists/tiebreaking_open_list.h	/^    virtual std::unique_ptr<StateOpenList> create_state_open_list() override;$/;"	m	class:TieBreakingOpenListFactory
override	open_lists/tiebreaking_open_list.h	/^    virtual ~TieBreakingOpenListFactory() override = default;$/;"	m	class:TieBreakingOpenListFactory
override	open_lists/type_based_open_list.cc	/^        EvaluationContext &eval_context) const override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^        EvaluationContext &eval_context, const Entry &entry) override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual Entry remove_min(vector<int> *key = nullptr) override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual Entry top() override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual bool empty() const override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual bool is_dead_end(EvaluationContext &eval_context) const override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual void clear() override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.cc	/^    virtual ~TypeBasedOpenList() override = default;$/;"	m	class:TypeBasedOpenList	file:
override	open_lists/type_based_open_list.h	/^    virtual std::unique_ptr<EdgeOpenList> create_edge_open_list() override;$/;"	m	class:TypeBasedOpenListFactory
override	open_lists/type_based_open_list.h	/^    virtual std::unique_ptr<StateOpenList> create_state_open_list() override;$/;"	m	class:TypeBasedOpenListFactory
override	open_lists/type_based_open_list.h	/^    virtual ~TypeBasedOpenListFactory() override = default;$/;"	m	class:TypeBasedOpenListFactory
override	operator_counting/lm_cut_constraints.h	/^                                    lp::LPSolver &lp_solver) override;$/;"	m	class:operator_counting::LMCutConstraints
override	operator_counting/lm_cut_constraints.h	/^        double infinity) override;$/;"	m	class:operator_counting::LMCutConstraints
override	operator_counting/operator_counting_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:operator_counting::OperatorCountingHeuristic
override	operator_counting/pho_constraints.h	/^        const State &state, lp::LPSolver &lp_solver) override;$/;"	m	class:operator_counting::PhOConstraints
override	operator_counting/pho_constraints.h	/^        double infinity) override;$/;"	m	class:operator_counting::PhOConstraints
override	pdbs/canonical_pdbs_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &state) override;$/;"	m	class:pdbs::CanonicalPDBsHeuristic
override	pdbs/pattern_collection_generator_combo.h	/^        const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternCollectionGeneratorCombo
override	pdbs/pattern_collection_generator_genetic.h	/^        const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
override	pdbs/pattern_collection_generator_hillclimbing.h	/^        const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
override	pdbs/pattern_collection_generator_manual.h	/^        const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternCollectionGeneratorManual
override	pdbs/pattern_collection_generator_systematic.h	/^        const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternCollectionGeneratorSystematic
override	pdbs/pattern_generator_greedy.h	/^    virtual Pattern generate(const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternGeneratorGreedy
override	pdbs/pattern_generator_manual.h	/^    virtual Pattern generate(const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:pdbs::PatternGeneratorManual
override	pdbs/pdb_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:pdbs::PDBHeuristic
override	pdbs/pdb_heuristic.h	/^    virtual ~PDBHeuristic() override = default;$/;"	m	class:pdbs::PDBHeuristic
override	potentials/potential_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:potentials::PotentialHeuristic
override	potentials/potential_max_heuristic.h	/^    virtual int compute_heuristic(const GlobalState &global_state) override;$/;"	m	class:potentials::PotentialMaxHeuristic
override	pruning/null_pruning_method.h	/^    virtual void initialize(const std::shared_ptr<AbstractTask> &) override;$/;"	m	class:null_pruning_method::NullPruningMethod
override	pruning/stubborn_sets.h	/^                                 std::vector<int> &op_ids) override;$/;"	m	class:stubborn_sets::StubbornSets
override	pruning/stubborn_sets.h	/^    virtual void initialize(const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:stubborn_sets::StubbornSets
override	pruning/stubborn_sets.h	/^    virtual void print_statistics() const override;$/;"	m	class:stubborn_sets::StubbornSets
override	pruning/stubborn_sets_ec.h	/^    virtual void handle_stubborn_operator(const State &state, int op_no) override;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
override	pruning/stubborn_sets_ec.h	/^    virtual void initialize(const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
override	pruning/stubborn_sets_ec.h	/^    virtual void initialize_stubborn_set(const State &state) override;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
override	pruning/stubborn_sets_simple.h	/^                                          int op_no) override;$/;"	m	class:stubborn_sets_simple::StubbornSetsSimple
override	pruning/stubborn_sets_simple.h	/^    virtual void initialize(const std::shared_ptr<AbstractTask> &task) override;$/;"	m	class:stubborn_sets_simple::StubbornSetsSimple
override	pruning/stubborn_sets_simple.h	/^    virtual void initialize_stubborn_set(const State &state) override;$/;"	m	class:stubborn_sets_simple::StubbornSetsSimple
override	search_engines/eager_search.h	/^    virtual SearchStatus step() override;$/;"	m	class:eager_search::EagerSearch
override	search_engines/eager_search.h	/^    virtual void initialize() override;$/;"	m	class:eager_search::EagerSearch
override	search_engines/eager_search.h	/^    virtual void print_statistics() const override;$/;"	m	class:eager_search::EagerSearch
override	search_engines/enforced_hill_climbing_search.h	/^    virtual SearchStatus step() override;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
override	search_engines/enforced_hill_climbing_search.h	/^    virtual void initialize() override;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
override	search_engines/enforced_hill_climbing_search.h	/^    virtual void print_statistics() const override;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
override	search_engines/enforced_hill_climbing_search.h	/^    virtual ~EnforcedHillClimbingSearch() override;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
override	search_engines/iterated_search.h	/^    virtual SearchStatus step() override;$/;"	m	class:iterated_search::IteratedSearch
override	search_engines/iterated_search.h	/^    virtual void print_statistics() const override;$/;"	m	class:iterated_search::IteratedSearch
override	search_engines/iterated_search.h	/^    virtual void save_plan_if_necessary() const override;$/;"	m	class:iterated_search::IteratedSearch
override	search_engines/kstar.h	/^	void search() override;$/;"	m	class:kstar::KStar
override	search_engines/lazy_search.h	/^    virtual SearchStatus step() override;$/;"	m	class:lazy_search::LazySearch
override	search_engines/lazy_search.h	/^    virtual void initialize() override;$/;"	m	class:lazy_search::LazySearch
override	search_engines/lazy_search.h	/^    virtual void print_statistics() const override;$/;"	m	class:lazy_search::LazySearch
override	search_engines/top_k_eager_search.h	/^    virtual SearchStatus step() override;$/;"	m	class:top_k_eager_search::TopKEagerSearch
override	search_engines/top_k_eager_search.h	/^    virtual void initialize() override;$/;"	m	class:top_k_eager_search::TopKEagerSearch
override	search_engines/top_k_eager_search.h	/^    virtual void print_statistics() const override;$/;"	m	class:top_k_eager_search::TopKEagerSearch
override	tasks/cost_adapted_task.h	/^    virtual int get_operator_cost(int index, bool is_axiom) const override;$/;"	m	class:tasks::CostAdaptedTask
override	tasks/cost_adapted_task.h	/^    virtual ~CostAdaptedTask() override = default;$/;"	m	class:tasks::CostAdaptedTask
override	tasks/delegating_task.h	/^        const AbstractTask *ancestor_task) const final override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^        const FactPair &fact1, const FactPair &fact2) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^        int op_index, int eff_index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^        int op_index, int eff_index, int cond_index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^        int op_index, int fact_index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual FactPair get_goal_fact(int index) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual const GlobalOperator *get_global_operator(int index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_num_axioms() const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_num_goals() const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_num_operator_effects(int op_index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_num_operator_preconditions(int index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_num_operators() const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_num_variables() const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_operator_cost(int index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_variable_axiom_layer(int var) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_variable_default_axiom_value(int var) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual int get_variable_domain_size(int var) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual std::string get_fact_name(const FactPair &fact) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual std::string get_operator_name(int index, bool is_axiom) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual std::string get_variable_name(int var) const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual std::vector<int> get_initial_state_values() const override;$/;"	m	class:tasks::DelegatingTask
override	tasks/delegating_task.h	/^    virtual ~DelegatingTask() override = default;$/;"	m	class:tasks::DelegatingTask
override	tasks/domain_abstracted_task.h	/^        const FactPair &fact1, const FactPair &fact2) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^        int op_index, int eff_index, bool is_axiom) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^        int op_index, int fact_index, bool is_axiom) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^        std::vector<int> &values) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^    virtual FactPair get_goal_fact(int index) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^    virtual int get_variable_domain_size(int var) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^    virtual std::string get_fact_name(const FactPair &fact) const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/domain_abstracted_task.h	/^    virtual std::vector<int> get_initial_state_values() const override;$/;"	m	class:extra_tasks::DomainAbstractedTask
override	tasks/modified_goals_task.h	/^    virtual FactPair get_goal_fact(int index) const override;$/;"	m	class:extra_tasks::ModifiedGoalsTask
override	tasks/modified_goals_task.h	/^    virtual int get_num_goals() const override;$/;"	m	class:extra_tasks::ModifiedGoalsTask
override	tasks/modified_operator_costs_task.h	/^    virtual int get_operator_cost(int index, bool is_axiom) const override;$/;"	m	class:extra_tasks::ModifiedOperatorCostsTask
override	tasks/modified_operator_costs_task.h	/^    virtual ~ModifiedOperatorCostsTask() override = default;$/;"	m	class:extra_tasks::ModifiedOperatorCostsTask
override	tasks/plan_forbid_reformulated_task.h	/^        const FactPair &fact1, const FactPair &fact2) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^        int op_index, int eff_index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^        int op_index, int eff_index, int cond_index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^        int op_index, int fact_index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^        std::vector<int> &values) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual FactPair get_goal_fact(int index) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual const GlobalOperator *get_global_operator(int index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_num_goals() const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_num_operator_effects(int op_index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_num_operator_preconditions(int index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_num_operators() const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_num_variables() const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_operator_cost(int index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_variable_axiom_layer(int var) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_variable_default_axiom_value(int var) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual int get_variable_domain_size(int var) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual std::string get_fact_name(const FactPair &fact) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual std::string get_operator_name(int index, bool is_axiom) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual std::string get_variable_name(int var) const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual std::vector<int> get_initial_state_values() const override;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/plan_forbid_reformulated_task.h	/^    virtual ~PlanForbidReformulatedTask() override = default;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
override	tasks/root_task.h	/^        const AbstractTask *ancestor_task) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^        const FactPair &fact1, const FactPair &fact2) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^        int op_index, int eff_index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^        int op_index, int eff_index, int cond_index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^        int op_index, int fact_index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual FactPair get_goal_fact(int index) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual const GlobalOperator *get_global_operator(int index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_num_axioms() const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_num_goals() const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_num_operator_effects(int op_index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_num_operator_preconditions(int index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_num_operators() const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_num_variables() const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_operator_cost(int index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_variable_axiom_layer(int var) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_variable_default_axiom_value(int var) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual int get_variable_domain_size(int var) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual std::string get_fact_name(const FactPair &fact) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual std::string get_operator_name(int index, bool is_axiom) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual std::string get_variable_name(int var) const override;$/;"	m	class:tasks::RootTask
override	tasks/root_task.h	/^    virtual std::vector<int> get_initial_state_values() const override;$/;"	m	class:tasks::RootTask
owner	heuristics/cea_heuristic.cc	/^    LocalProblem *owner;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
owner	per_state_information.h	/^        const PerStateInformation<Entry> &owner;$/;"	m	class:PerStateInformation::const_iterator
owns_right_child	cegar/refinement_hierarchy.h	/^    bool owns_right_child() const {$/;"	f	class:cegar::Node
p	bliss/graph.h	/^  Partition p;$/;"	m	class:bliss::AbstractGraph
pack_bins	algorithms/int_packer.cc	/^void IntPacker::pack_bins(const vector<int> &ranges) {$/;"	f	class:int_packer::IntPacker
pack_one_bin	algorithms/int_packer.cc	/^int IntPacker::pack_one_bin(const vector<int> &ranges,$/;"	f	class:int_packer::IntPacker
padding_bytes	search_node_info.cc	/^    sizeof(SearchNodeInfo) == info_bytes + padding_bytes,$/;"	v
padding_bytes	search_node_info.cc	/^static const int padding_bytes = info_bytes % pointer_bytes;$/;"	v	file:
parent	ext/tree.hh	/^		tree_node_<T> *parent;$/;"	m	class:tree_node_
parent	ext/tree.hh	/^iter tree<T, tree_node_allocator>::parent(iter position) $/;"	f	class:tree
parent	merge_and_shrink/merge_tree.h	/^    MergeTreeNode *parent;$/;"	m	struct:merge_and_shrink::MergeTreeNode
parent	tasks/delegating_task.h	/^    const std::shared_ptr<AbstractTask> parent;$/;"	m	class:tasks::DelegatingTask
parent_	ext/tree.hh	/^				tree_node *parent_;$/;"	m	class:tree::sibling_iterator
parent_graph	domain_transition_graph.h	/^    DomainTransitionGraph *parent_graph;$/;"	m	struct:ValueNode
parent_state_id	search_node_info.h	/^    StateID parent_state_id;$/;"	m	struct:SearchNodeInfo
parents	landmarks/landmark_graph.h	/^    std::unordered_map<LandmarkNode *, EdgeType> parents;$/;"	m	class:landmarks::EdgeType::LandmarkNode
parse	options/option_parser.cc	/^Options OptionParser::parse() {$/;"	f	class:options::OptionParser
parse	options/token_parser.h	/^inline ParseTree TokenParser<ParseTree>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline ScalarEvaluator *TokenParser<ScalarEvaluator *>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline T *TokenParser<T *>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline T TokenParser<T>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline double TokenParser<double>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline int TokenParser<int>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline std::shared_ptr<T> TokenParser<std::shared_ptr<T>>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse	options/token_parser.h	/^inline std::vector<T> TokenParser<std::vector<T>>::parse(OptionParser &p) {$/;"	f	class:options::TokenParser
parse_cmd_line	options/option_parser.cc	/^SearchEngine *OptionParser::parse_cmd_line($/;"	f	class:options::OptionParser
parse_cmd_line_aux	options/option_parser.cc	/^SearchEngine *OptionParser::parse_cmd_line_aux($/;"	f	class:options::OptionParser
parse_int_arg	options/option_parser.cc	/^int OptionParser::parse_int_arg(const string &name, const string &value) {$/;"	f	class:options::OptionParser
parse_rng_from_options	utils/rng_options.cc	/^shared_ptr<RandomNumberGenerator> parse_rng_from_options($/;"	f	namespace:utils
parse_tree	options/errors.h	/^    ParseTree parse_tree;$/;"	m	struct:options::ParseError
parse_tree	options/option_parser.h	/^    const ParseTree parse_tree;$/;"	m	class:options::OptionParser
partition_bt_point	bliss/graph.cc	/^  Partition::BacktrackPoint partition_bt_point;$/;"	m	class:bliss::TreeNode	file:
partition_into_buckets	merge_and_shrink/shrink_fh.cc	/^void ShrinkFH::partition_into_buckets($/;"	f	class:merge_and_shrink::ShrinkFH
partition_into_buckets	merge_and_shrink/shrink_random.cc	/^void ShrinkRandom::partition_into_buckets($/;"	f	class:merge_and_shrink::ShrinkRandom
pass_bound	search_engines/iterated_search.h	/^    bool pass_bound;$/;"	m	class:iterated_search::IteratedSearch
pattern	pdbs/match_tree.h	/^    Pattern pattern;$/;"	m	class:pdbs::MatchTree
pattern	pdbs/pattern_database.h	/^    Pattern pattern;$/;"	m	class:pdbs::PatternDatabase
pattern	pdbs/pattern_generator_manual.h	/^    Pattern pattern;$/;"	m	class:pdbs::PatternGeneratorManual
pattern_collections	pdbs/pattern_collection_generator_genetic.h	/^    std::vector<std::vector<std::vector<bool>>> pattern_collections;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
pattern_databases	pdbs/incremental_canonical_pdbs.h	/^    std::shared_ptr<PDBCollection> pattern_databases;$/;"	m	class:pdbs::IncrementalCanonicalPDBs
pattern_databases	pdbs/zero_one_pdbs.h	/^    PDBCollection pattern_databases;$/;"	m	class:pdbs::ZeroOnePDBs
pattern_generator	operator_counting/pho_constraints.h	/^    std::shared_ptr<pdbs::PatternCollectionGenerator> pattern_generator;$/;"	m	class:operator_counting::PhOConstraints
pattern_set	pdbs/pattern_collection_generator_systematic.h	/^    PatternSet pattern_set;  \/\/ Cleared after pattern computation.$/;"	m	class:pdbs::PatternCollectionGeneratorSystematic
patterns	pdbs/incremental_canonical_pdbs.h	/^    std::shared_ptr<PatternCollection> patterns;$/;"	m	class:pdbs::IncrementalCanonicalPDBs
patterns	pdbs/pattern_collection_generator_manual.h	/^    std::shared_ptr<PatternCollection> patterns;$/;"	m	class:pdbs::PatternCollectionGeneratorManual
patterns	pdbs/pattern_collection_generator_systematic.h	/^    std::shared_ptr<PatternCollection> patterns;$/;"	m	class:pdbs::PatternCollectionGeneratorSystematic
patterns	pdbs/pattern_collection_information.h	/^    std::shared_ptr<PatternCollection> patterns;$/;"	m	class:pdbs::PatternCollectionInformation
patterns_are_disjoint	pdbs/pattern_collection_generator_systematic.cc	/^static bool patterns_are_disjoint($/;"	f	namespace:pdbs
pc	landmarks/landmark_factory_h_m.h	/^    std::vector<int> pc;$/;"	m	struct:landmarks::PMOp
pc_for	landmarks/landmark_factory_h_m.h	/^    std::vector<FactPair> pc_for;$/;"	m	struct:landmarks::HMEntry
pdb	pdbs/pdb_heuristic.h	/^    PatternDatabase pdb;$/;"	m	class:pdbs::PDBHeuristic
pdb_max_size	pdbs/pattern_collection_generator_genetic.h	/^    const int pdb_max_size;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
pdb_max_size	pdbs/pattern_collection_generator_hillclimbing.h	/^    const int pdb_max_size;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
pdbs	operator_counting/pho_constraints.h	/^    std::shared_ptr<pdbs::PDBCollection> pdbs;$/;"	m	class:operator_counting::PhOConstraints
pdbs	operator_counting/pho_constraints.h	/^namespace pdbs {$/;"	n
pdbs	options/option_parser.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/canonical_pdbs.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/canonical_pdbs.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/canonical_pdbs_heuristic.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/canonical_pdbs_heuristic.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/dominance_pruning.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/dominance_pruning.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/incremental_canonical_pdbs.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/incremental_canonical_pdbs.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/match_tree.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/match_tree.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/max_additive_pdb_sets.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/max_additive_pdb_sets.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_collection_generator_combo.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_collection_generator_combo.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_collection_generator_genetic.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_collection_generator_genetic.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_collection_generator_hillclimbing.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_collection_generator_hillclimbing.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_collection_generator_manual.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_collection_generator_manual.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_collection_generator_systematic.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_collection_generator_systematic.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_collection_information.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_collection_information.h	/^    std::shared_ptr<PDBCollection> pdbs;$/;"	m	class:pdbs::PatternCollectionInformation
pdbs	pdbs/pattern_collection_information.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_database.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_database.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_generator.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_generator.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_generator_greedy.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_generator_greedy.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pattern_generator_manual.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pattern_generator_manual.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/pdb_heuristic.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/pdb_heuristic.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/types.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/validation.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/validation.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/zero_one_pdbs.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/zero_one_pdbs.h	/^namespace pdbs {$/;"	n
pdbs	pdbs/zero_one_pdbs_heuristic.cc	/^namespace pdbs {$/;"	n	file:
pdbs	pdbs/zero_one_pdbs_heuristic.h	/^namespace pdbs {$/;"	n
permute	bliss/graph.cc	/^Digraph::permute(const std::vector<unsigned int>& perm) const$/;"	f	class:bliss::Digraph
permute	bliss/graph.cc	/^Digraph::permute(const unsigned int* const perm) const$/;"	f	class:bliss::Digraph
permute	bliss/graph.cc	/^Graph::permute(const std::vector<unsigned int>& perm) const$/;"	f	class:bliss::Graph
permute	bliss/graph.cc	/^Graph::permute(const unsigned int* perm) const$/;"	f	class:bliss::Graph
permute_state	state_registry.cc	/^GlobalState StateRegistry::permute_state(const GlobalState &state, const Permutation &permutation) {$/;"	f	class:StateRegistry
phase	search_engines/iterated_search.h	/^    int phase;$/;"	m	class:iterated_search::IteratedSearch
pick	cegar/split_selector.h	/^    const PickSplit pick;$/;"	m	class:cegar::SplitSelector
pick_split	cegar/cost_saturation.h	/^    const PickSplit pick_split;$/;"	m	class:cegar::CostSaturation
pick_split	cegar/split_selector.cc	/^const Split &SplitSelector::pick_split(const AbstractState &state,$/;"	f	class:cegar::SplitSelector
plan	search_engine.h	/^    Plan plan;$/;"	m	class:SearchEngine
plan_for_disj	landmarks/exploration.cc	/^bool Exploration::plan_for_disj($/;"	f	class:landmarks::Exploration
plan_graph_node	landmarks/landmark_factory_zhu_givan.h	/^    class plan_graph_node {$/;"	c	class:landmarks::LandmarkFactoryZhuGivan
plan_operators_indexes	tasks/plan_forbid_reformulated_task.h	/^	std::vector<int> plan_operators_indexes;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
plan_operators_indexes_by_parent_operator	tasks/plan_forbid_reformulated_task.h	/^	std::vector<std::vector<int>> plan_operators_indexes_by_parent_operator;$/;"	m	class:extra_tasks::PlanForbidReformulatedTask
pm_ops_	landmarks/landmark_factory_h_m.h	/^    std::vector<PMOp> pm_ops_;$/;"	m	class:landmarks::LandmarkFactoryHM
pointer	ext/tree.hh	/^				typedef T*                              pointer;$/;"	t	class:tree::iterator_base
pointer_bytes	search_node_info.cc	/^static const int pointer_bytes = sizeof(void *);$/;"	v	file:
pop	algorithms/priority_queues.h	/^    Entry pop() {$/;"	f	class:priority_queues::AdaptiveQueue
pop	algorithms/priority_queues.h	/^    virtual Entry pop() {$/;"	f	class:priority_queues::BucketQueue
pop	algorithms/priority_queues.h	/^    virtual Entry pop() {$/;"	f	class:priority_queues::HeapQueue
pop	bliss/kstack.h	/^  Type pop()$/;"	f	class:bliss::KStack
pop_as_vector	algorithms/ordered_set.h	/^    std::vector<T> pop_as_vector() {$/;"	f	class:ordered_set::OrderedSet
pop_back	algorithms/segmented_vector.h	/^    void pop_back() {$/;"	f	class:segmented_vector::SegmentedArrayVector
pop_back	algorithms/segmented_vector.h	/^    void pop_back() {$/;"	f	class:segmented_vector::SegmentedVector
pop_front	bliss/kqueue.h	/^Type KQueue<Type>::pop_front()$/;"	f	class:bliss::KQueue
pos	per_state_information.h	/^        StateID pos;$/;"	m	class:PerStateInformation::const_iterator
pos	task_proxy.h	/^    std::size_t pos;$/;"	m	class:ProxyIterator
possible_achievers	landmarks/landmark_graph.h	/^    std::set<int> possible_achievers;$/;"	m	class:landmarks::EdgeType::LandmarkNode
possible_noop_set	landmarks/landmark_factory_h_m.cc	/^bool LandmarkFactoryHM::possible_noop_set(const VariablesProxy &variables,$/;"	f	class:landmarks::LandmarkFactoryHM
post_order_iterator	ext/tree.hh	/^		class post_order_iterator : public iterator_base {$/;"	c	class:tree
post_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator() $/;"	f	class:tree::post_order_iterator
post_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(const iterator_base &other)$/;"	f	class:tree::post_order_iterator
post_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(const sibling_iterator& other)$/;"	f	class:tree::post_order_iterator
post_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::post_order_iterator::post_order_iterator(tree_node *tn)$/;"	f	class:tree::post_order_iterator
postconditions_by_operator	cegar/transition_updater.h	/^    std::vector<std::vector<FactPair>> postconditions_by_operator;$/;"	m	class:cegar::TransitionUpdater
potentials	potentials/diverse_potential_heuristics.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/diverse_potential_heuristics.h	/^namespace potentials {$/;"	n
potentials	potentials/potential_function.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/potential_function.h	/^namespace potentials {$/;"	n
potentials	potentials/potential_heuristic.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/potential_heuristic.h	/^namespace potentials {$/;"	n
potentials	potentials/potential_max_heuristic.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/potential_max_heuristic.h	/^namespace potentials {$/;"	n
potentials	potentials/potential_optimizer.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/potential_optimizer.h	/^namespace potentials {$/;"	n
potentials	potentials/sample_based_potential_heuristics.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/single_potential_heuristics.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/util.cc	/^namespace potentials {$/;"	n	file:
potentials	potentials/util.h	/^namespace potentials {$/;"	n
potentials_are_bounded	potentials/potential_optimizer.cc	/^bool PotentialOptimizer::potentials_are_bounded() const {$/;"	f	class:potentials::PotentialOptimizer
pre_eff_builder	causal_graph.cc	/^    IntRelationBuilder pre_eff_builder;$/;"	m	struct:CausalGraphBuilder	file:
pre_order_iterator	ext/tree.hh	/^		class pre_order_iterator : public iterator_base { $/;"	c	class:tree
pre_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator() $/;"	f	class:tree::pre_order_iterator
pre_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(const iterator_base &other)$/;"	f	class:tree::pre_order_iterator
pre_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(const sibling_iterator& other)$/;"	f	class:tree::pre_order_iterator
pre_order_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::pre_order_iterator::pre_order_iterator(tree_node *tn)$/;"	f	class:tree::pre_order_iterator
pre_to_eff	causal_graph.h	/^    IntRelation pre_to_eff;$/;"	m	class:CausalGraph
precond	domain_transition_graph.h	/^    std::vector<LocalAssignment> precond;$/;"	m	struct:ValueTransitionLabel
precondition	heuristics/relaxation_heuristic.h	/^    std::vector<Proposition *> precondition;$/;"	m	struct:relaxation_heuristic::UnaryOperator
precondition	landmarks/exploration.h	/^    std::vector<ExProposition *> precondition;$/;"	m	struct:landmarks::ExUnaryOperator
precondition_of	heuristics/lm_cut_landmarks.h	/^    std::vector<RelaxedOperator *> precondition_of;$/;"	m	struct:lm_cut_heuristic::RelaxedProposition
precondition_of	heuristics/relaxation_heuristic.h	/^    std::vector<UnaryOperator *> precondition_of;$/;"	m	struct:relaxation_heuristic::Proposition
precondition_of	landmarks/exploration.h	/^    std::vector<ExUnaryOperator *> precondition_of;$/;"	m	struct:landmarks::ExProposition
preconditions	global_operator.h	/^    std::vector<GlobalCondition> preconditions;$/;"	m	class:GlobalOperator
preconditions	heuristics/lm_cut_landmarks.h	/^    std::vector<RelaxedProposition *> preconditions;$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
preconditions_by_operator	cegar/transition_updater.h	/^    std::vector<std::vector<FactPair>> preconditions_by_operator;$/;"	m	class:cegar::TransitionUpdater
pred_builder	causal_graph.cc	/^    IntRelationBuilder pred_builder;$/;"	m	struct:CausalGraphBuilder	file:
predecessors	causal_graph.h	/^    IntRelation predecessors;$/;"	m	class:CausalGraph
predefine	options/predefinitions.h	/^    void predefine(std::string k, T obj) {$/;"	f	class:options::Predefinitions
predefine_heuristic	options/option_parser.cc	/^static void predefine_heuristic(string s, bool dry_run) {$/;"	f	namespace:options
predefine_lmgraph	options/option_parser.cc	/^static void predefine_lmgraph(string s, bool dry_run) {$/;"	f	namespace:options
predefine_symmetries	options/option_parser.cc	/^static void predefine_symmetries(std::string s, bool dry_run) {$/;"	f	namespace:options
predefined	options/predefinitions.h	/^    std::map<std::string, T> predefined;$/;"	m	class:options::Predefinitions
pref_evaluator	evaluators/pref_evaluator.cc	/^namespace pref_evaluator {$/;"	n	file:
pref_evaluator	evaluators/pref_evaluator.h	/^namespace pref_evaluator {$/;"	n
preferred	evaluation_context.h	/^    bool preferred;$/;"	m	class:EvaluationContext
preferred_operator_heuristics	search_engines/eager_search.h	/^    std::vector<Heuristic *> preferred_operator_heuristics;$/;"	m	class:eager_search::EagerSearch
preferred_operator_heuristics	search_engines/enforced_hill_climbing_search.h	/^    std::vector<Heuristic *> preferred_operator_heuristics;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
preferred_operator_heuristics	search_engines/lazy_search.h	/^    std::vector<Heuristic *> preferred_operator_heuristics;$/;"	m	class:lazy_search::LazySearch
preferred_operator_heuristics	search_engines/top_k_eager_search.h	/^    std::vector<Heuristic *> preferred_operator_heuristics;$/;"	m	class:top_k_eager_search::TopKEagerSearch
preferred_operators	evaluation_result.h	/^    std::vector<const GlobalOperator *> preferred_operators;$/;"	m	class:EvaluationResult
preferred_operators	heuristic.h	/^    ordered_set::OrderedSet<const GlobalOperator *> preferred_operators;$/;"	m	class:Heuristic
preferred_successors_first	search_engines/lazy_search.h	/^    bool preferred_successors_first;$/;"	m	class:lazy_search::LazySearch
preferred_usage	search_engines/enforced_hill_climbing_search.h	/^    PreferredUsage preferred_usage;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
prepare_heuristic_computation	landmarks/exploration.cc	/^void Exploration::prepare_heuristic_computation(const State &state) {$/;"	f	class:landmarks::Exploration
prepare_parser_for_admissible_potentials	potentials/util.cc	/^void prepare_parser_for_admissible_potentials(OptionParser &parser) {$/;"	f	namespace:potentials
prepend_child	ext/tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position)$/;"	f	class:tree
prepend_child	ext/tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position, const T& x)$/;"	f	class:tree
prepend_child	ext/tree.hh	/^iter tree<T, tree_node_allocator>::prepend_child(iter position, iter other)$/;"	f	class:tree
prepend_children	ext/tree.hh	/^iter tree<T, tree_node_allocator>::prepend_children(iter position, sibling_iterator from, sibling_iterator to)$/;"	f	class:tree
prev	bliss/partition.h	/^    Cell* prev;$/;"	m	class:bliss::Partition::Cell
prev_next_ptr	bliss/partition.h	/^    CRCell** prev_next_ptr;$/;"	m	class:bliss::Partition::CRCell
prev_nonsingleton	bliss/partition.h	/^    Cell* prev_nonsingleton;$/;"	m	class:bliss::Partition::Cell
prev_nonsingleton_first	bliss/partition.h	/^    int prev_nonsingleton_first;$/;"	m	class:bliss::Partition::RefInfo
prev_sibling	ext/tree.hh	/^		tree_node_<T> *prev_sibling, *next_sibling;$/;"	m	class:tree_node_
previous_sibling	ext/tree.hh	/^iter tree<T, tree_node_allocator>::previous_sibling(iter position) const$/;"	f	class:tree
print	bliss/bignum.h	/^  size_t print(FILE* const fp) const {return mpz_out_str(fp, 10, v); }$/;"	f	class:bliss::BigNum
print	bliss/graph.h	/^  size_t print(FILE* const fp) const$/;"	f	class:bliss::Stats
print	bliss/partition.cc	/^Partition::print(FILE* const fp, const bool add_newline) const$/;"	f	class:bliss::Partition
print_affected_variables_by_cycles	structural_symmetries/permutation.cc	/^void Permutation::print_affected_variables_by_cycles() const {$/;"	f	class:Permutation
print_all	options/doc_printer.cc	/^void DocPrinter::print_all() {$/;"	f	class:options::DocPrinter
print_all	options/doc_printer.h	/^    bool print_all; \/\/if this is false, notes, properties and language_features are omitted$/;"	m	class:options::PlainPrinter
print_arguments	options/doc_printer.cc	/^void PlainPrinter::print_arguments(const DocStruct &info) {$/;"	f	class:options::PlainPrinter
print_arguments	options/doc_printer.cc	/^void Txt2TagsPrinter::print_arguments(const DocStruct &info) {$/;"	f	class:options::Txt2TagsPrinter
print_basic_statistics	search_statistics.cc	/^void SearchStatistics::print_basic_statistics() const {$/;"	f	class:SearchStatistics
print_category	options/doc_printer.cc	/^void DocPrinter::print_category(string category_name) {$/;"	f	class:options::DocPrinter
print_category_footer	options/doc_printer.cc	/^void PlainPrinter::print_category_footer() {$/;"	f	class:options::PlainPrinter
print_category_footer	options/doc_printer.cc	/^void Txt2TagsPrinter::print_category_footer() {$/;"	f	class:options::Txt2TagsPrinter
print_category_header	options/doc_printer.cc	/^void PlainPrinter::print_category_header(string category_name) {$/;"	f	class:options::PlainPrinter
print_category_header	options/doc_printer.cc	/^void Txt2TagsPrinter::print_category_header(string category_name) {$/;"	f	class:options::Txt2TagsPrinter
print_checkpoint_line	search_engines/eager_search.cc	/^void EagerSearch::print_checkpoint_line(int g) const {$/;"	f	class:eager_search::EagerSearch
print_checkpoint_line	search_engines/lazy_search.cc	/^void LazySearch::print_checkpoint_line(int g) const {$/;"	f	class:lazy_search::LazySearch
print_checkpoint_line	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::print_checkpoint_line(int g) const {$/;"	f	class:top_k_eager_search::TopKEagerSearch
print_cycle_notation	structural_symmetries/permutation.cc	/^void Permutation::print_cycle_notation() const {$/;"	f	class:Permutation
print_detailed_statistics	search_statistics.cc	/^void SearchStatistics::print_detailed_statistics() const {$/;"	f	class:SearchStatistics
print_element	options/doc_printer.cc	/^void DocPrinter::print_element(string call_name, const DocStruct &info) {$/;"	f	class:options::DocPrinter
print_f_line	search_statistics.cc	/^void SearchStatistics::print_f_line() const {$/;"	f	class:SearchStatistics
print_fluentset	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::print_fluentset(const VariablesProxy &variables, const FluentSet &fs) {$/;"	f	class:landmarks::LandmarkFactoryHM
print_goal	utils/util.h	/^inline void print_goal()$/;"	f
print_in_blue	utils/util.h	/^inline void print_in_blue(string str)$/;"	f
print_in_green	utils/util.h	/^inline void print_in_green(string str)$/;"	f
print_in_red	utils/util.h	/^inline void print_in_red(string str) $/;"	f
print_initial_h_values	search_engine.cc	/^void print_initial_h_values(const EvaluationContext &eval_context) {$/;"	f
print_language_features	options/doc_printer.cc	/^void PlainPrinter::print_language_features(const DocStruct &info) {$/;"	f	class:options::PlainPrinter
print_language_features	options/doc_printer.cc	/^void Txt2TagsPrinter::print_language_features(const DocStruct &info) {$/;"	f	class:options::Txt2TagsPrinter
print_notes	options/doc_printer.cc	/^void PlainPrinter::print_notes(const DocStruct &info) {$/;"	f	class:options::PlainPrinter
print_notes	options/doc_printer.cc	/^void Txt2TagsPrinter::print_notes(const DocStruct &info) {$/;"	f	class:options::Txt2TagsPrinter
print_peak_memory_reentrant	utils/system_unix.cc	/^void print_peak_memory_reentrant() {$/;"	f	namespace:utils
print_permutation	bliss/utils.cc	/^print_permutation(FILE* const fp,$/;"	f	namespace:bliss
print_plan	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::print_plan(Plan plan,$/;"	f	class:top_k_eager_search::TopKEagerSearch
print_pm_op	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::print_pm_op(const VariablesProxy &variables, const PMOp &op) {$/;"	f	class:landmarks::LandmarkFactoryHM
print_properties	options/doc_printer.cc	/^void PlainPrinter::print_properties(const DocStruct &info) {$/;"	f	class:options::PlainPrinter
print_properties	options/doc_printer.cc	/^void Txt2TagsPrinter::print_properties(const DocStruct &info) {$/;"	f	class:options::Txt2TagsPrinter
print_proposition	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::print_proposition(const VariablesProxy &variables, const FactPair &fluent) const {$/;"	f	class:landmarks::LandmarkFactoryHM
print_set	utils/util.h	/^void print_set(std::set<T> set)$/;"	f
print_set_of_operators	utils/util.h	/^inline void print_set_of_operators(vector<GlobalOperator>& ops, string description)$/;"	f
print_set_of_operators	utils/util.h	/^inline void print_set_of_operators(vector<const GlobalOperator*>& ops, string description)$/;"	f
print_signature	bliss/partition.cc	/^Partition::print_signature(FILE* const fp, const bool add_newline) const$/;"	f	class:bliss::Partition
print_state	utils/util.h	/^inline void print_state(const GlobalState& s, std::string description)$/;"	f
print_statistics	cegar/abstraction.cc	/^void Abstraction::print_statistics() {$/;"	f	class:cegar::Abstraction
print_statistics	cegar/cost_saturation.cc	/^void CostSaturation::print_statistics() const {$/;"	f	class:cegar::CostSaturation
print_statistics	lp/lp_solver.cc	/^void LPSolver::print_statistics() const {$/;"	f	class:lp::LPSolver
print_statistics	pruning/stubborn_sets.cc	/^void StubbornSets::print_statistics() const {$/;"	f	class:stubborn_sets::StubbornSets
print_statistics	search_engine.cc	/^void SearchEngine::print_statistics() const {$/;"	f	class:SearchEngine
print_statistics	search_engines/eager_search.cc	/^void EagerSearch::print_statistics() const {$/;"	f	class:eager_search::EagerSearch
print_statistics	search_engines/enforced_hill_climbing_search.cc	/^void EnforcedHillClimbingSearch::print_statistics() const {$/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
print_statistics	search_engines/iterated_search.cc	/^void IteratedSearch::print_statistics() const {$/;"	f	class:iterated_search::IteratedSearch
print_statistics	search_engines/lazy_search.cc	/^void LazySearch::print_statistics() const {$/;"	f	class:lazy_search::LazySearch
print_statistics	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::print_statistics() const {$/;"	f	class:top_k_eager_search::TopKEagerSearch
print_statistics	search_space.cc	/^void SearchSpace::print_statistics() const {$/;"	f	class:SearchSpace
print_subtree_bracketed	ext/tree_util.hh	/^void print_subtree_bracketed(const tree<T>& t, typename tree<T>::iterator iRoot, std::ostream& str) $/;"	f	namespace:kptree
print_synopsis	options/doc_printer.cc	/^void PlainPrinter::print_synopsis(const DocStruct &info) {$/;"	f	class:options::PlainPrinter
print_synopsis	options/doc_printer.cc	/^void Txt2TagsPrinter::print_synopsis(const DocStruct &info) {$/;"	f	class:options::Txt2TagsPrinter
print_time	merge_and_shrink/merge_and_shrink_heuristic.cc	/^static void print_time(const utils::Timer &timer, string text) {$/;"	f	namespace:merge_and_shrink
print_trace_message	utils/logging.cc	/^void MemoryTracer::print_trace_message(const string &msg) {$/;"	f	class:utils::MemoryTracer
print_tree_bracketed	ext/tree_util.hh	/^void print_tree_bracketed(const tree<T>& t, std::ostream& str) $/;"	f	namespace:kptree
print_usage	options/doc_printer.cc	/^void PlainPrinter::print_usage(string call_name, const DocStruct &info) {$/;"	f	class:options::PlainPrinter
print_usage	options/doc_printer.cc	/^void Txt2TagsPrinter::print_usage(string call_name, const DocStruct &info) {$/;"	f	class:options::Txt2TagsPrinter
print_value	utils/util.h	/^void print_value(T var, string s , const char* func, int line) {$/;"	f
prio_queues	heuristics/cg_heuristic.h	/^    std::vector<priority_queues::AdaptiveQueue<ValueNode *> *> prio_queues;$/;"	m	class:cg_heuristic::CGHeuristic
priorities	open_lists/alternation_open_list.cc	/^    vector<int> priorities;$/;"	m	class:AlternationOpenList	file:
priority_queue	heuristics/lm_cut_landmarks.h	/^    priority_queues::AdaptiveQueue<RelaxedProposition *> priority_queue;$/;"	m	class:lm_cut_heuristic::LandmarkCutLandmarks
priority_queues	algorithms/priority_queues.h	/^namespace priority_queues {$/;"	n
process_effect	domain_transition_graph.cc	/^void DTGFactory::process_effect(const EffectProxy &eff, const OperatorProxy &op,$/;"	f	class:DTGFactory
process_heuristic_value	search_progress.cc	/^bool SearchProgress::process_heuristic_value(const Heuristic *heuristic, int h) {$/;"	f	class:SearchProgress
product_ts_order	merge_and_shrink/merge_scoring_function_total_order.h	/^    ProductTSOrder product_ts_order;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
prop_queue	landmarks/exploration.h	/^    priority_queues::AdaptiveQueue<ExProposition *> prop_queue;$/;"	m	class:landmarks::Exploration
propagate_pm_fact	landmarks/landmark_factory_h_m.cc	/^void LandmarkFactoryHM::propagate_pm_fact(int factindex, bool newly_discovered,$/;"	f	class:landmarks::LandmarkFactoryHM
property	options/doc_store.h	/^    std::string property;$/;"	m	struct:options::PropertyInfo
property_help	options/doc_store.h	/^    std::vector<PropertyInfo> property_help;$/;"	m	struct:options::DocStruct
propositions	heuristics/lm_cut_landmarks.h	/^    std::vector<std::vector<RelaxedProposition>> propositions;$/;"	m	class:lm_cut_heuristic::LandmarkCutLandmarks
propositions	heuristics/relaxation_heuristic.h	/^    std::vector<std::vector<Proposition>> propositions;$/;"	m	class:relaxation_heuristic::RelaxationHeuristic
propositions	landmarks/exploration.h	/^    std::vector<std::vector<ExProposition>> propositions;$/;"	m	class:landmarks::Exploration
propositions	operator_counting/state_equation_constraints.h	/^    std::vector<std::vector<Proposition>> propositions;$/;"	m	class:operator_counting::StateEquationConstraints
prune_dominated_subsets	pdbs/dominance_pruning.cc	/^shared_ptr<MaxAdditivePDBSubsets> prune_dominated_subsets($/;"	f	namespace:pdbs
prune_operators	pruning/stubborn_sets.cc	/^void StubbornSets::prune_operators($/;"	f	class:stubborn_sets::StubbornSets
prune_operators	pruning_method.cc	/^void PruningMethod::prune_operators(const GlobalState &global_state,$/;"	f	class:PruningMethod
pruning_condition	domain_transition_graph.h	/^    std::function<bool(int, int)> pruning_condition;$/;"	m	class:DTGFactory
pruning_method	search_engines/eager_search.h	/^    std::shared_ptr<PruningMethod> pruning_method;$/;"	m	class:eager_search::EagerSearch
pruning_method	search_engines/top_k_eager_search.h	/^    std::shared_ptr<PruningMethod> pruning_method;$/;"	m	class:top_k_eager_search::TopKEagerSearch
push	algorithms/priority_queues.h	/^    virtual void push(int key, const Value &value) {$/;"	f	class:priority_queues::BucketQueue
push	algorithms/priority_queues.h	/^    virtual void push(int key, const Value &value) {$/;"	f	class:priority_queues::HeapQueue
push	algorithms/priority_queues.h	/^    void push(int key, const Value &value) {$/;"	f	class:priority_queues::AdaptiveQueue
push	bliss/kstack.h	/^  void push(Type e)$/;"	f	class:bliss::KStack
push_back	algorithms/segmented_vector.h	/^    void push_back(const Element *entry) {$/;"	f	class:segmented_vector::SegmentedArrayVector
push_back	algorithms/segmented_vector.h	/^    void push_back(const Entry &entry) {$/;"	f	class:segmented_vector::SegmentedVector
push_back	bliss/kqueue.h	/^void KQueue<Type>::push_back(Type e)$/;"	f	class:bliss::KQueue
push_front	bliss/kqueue.h	/^void KQueue<Type>::push_front(Type e)$/;"	f	class:bliss::KQueue
queue	axioms.h	/^    std::vector<AxiomLiteral *> queue;$/;"	m	class:AxiomEvaluator
queue	heuristics/additive_heuristic.h	/^    priority_queues::AdaptiveQueue<Proposition *> queue;$/;"	m	class:additive_heuristic::AdditiveHeuristic
queue	heuristics/max_heuristic.h	/^    priority_queues::AdaptiveQueue<Proposition *> queue;$/;"	m	class:max_heuristic::HSPMaxHeuristic
queue_djkstra	search_engines/kstar.h	/^	priority_queues::AdaptiveQueue<top_k_eager_search::StateActionPair> queue_djkstra;$/;"	m	class:kstar::KStar
random_seed	merge_and_shrink/merge_scoring_function_single_random.h	/^    int random_seed; \/\/ only for dump options$/;"	m	class:merge_and_shrink::MergeScoringFunctionSingleRandom
random_seed	merge_and_shrink/merge_scoring_function_total_order.h	/^    int random_seed; \/\/ only for dump options$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
randomize_successors	search_engines/lazy_search.h	/^    bool randomize_successors;$/;"	m	class:lazy_search::LazySearch
range	algorithms/int_packer.cc	/^    int range;$/;"	m	class:int_packer::IntPacker::VariableInfo	file:
range_first	ext/tree.hh	/^typename tree<T, tree_node_allocator>::tree_node *tree<T, tree_node_allocator>::sibling_iterator::range_first() const$/;"	f	class:tree::sibling_iterator
range_last	ext/tree.hh	/^typename tree<T, tree_node_allocator>::tree_node *tree<T, tree_node_allocator>::sibling_iterator::range_last() const$/;"	f	class:tree::sibling_iterator
rate_split	cegar/split_selector.cc	/^double SplitSelector::rate_split(const AbstractState &state, const Split &split) const {$/;"	f	class:cegar::SplitSelector
reach_state	search_engines/enforced_hill_climbing_search.cc	/^void EnforcedHillClimbingSearch::reach_state($/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
reachability_map	pruning/stubborn_sets_ec.h	/^    std::vector<std::vector<std::vector<bool>>> reachability_map;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
reached	landmarks/landmark_factory_zhu_givan.h	/^        inline bool reached() const {$/;"	f	class:landmarks::LandmarkFactoryZhuGivan::plan_graph_node
reached_by	domain_transition_graph.h	/^    ValueTransitionLabel *reached_by;$/;"	m	struct:ValueNode
reached_by	heuristics/cea_heuristic.cc	/^    LocalTransition *reached_by;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
reached_by	heuristics/relaxation_heuristic.h	/^    UnaryOperator *reached_by;$/;"	m	struct:relaxation_heuristic::Proposition
reached_by	landmarks/exploration.h	/^    ExUnaryOperator *reached_by;$/;"	m	struct:landmarks::ExProposition
reached_cost	landmarks/landmark_graph.h	/^    int reached_cost;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
reached_from	domain_transition_graph.h	/^    ValueNode *reached_from;$/;"	m	struct:ValueNode
reached_lms	landmarks/landmark_status_manager.h	/^    PerStateInformation<std::vector<bool>> reached_lms;$/;"	m	class:landmarks::LandmarkStatusManager
read_and_verify_version	globals.cc	/^void read_and_verify_version(istream &in) {$/;"	f
read_axioms	globals.cc	/^void read_axioms(istream &in) {$/;"	f
read_char_reentrant	utils/system_unix.cc	/^bool read_char_reentrant(int filedescr, char *c) {$/;"	f	namespace:utils
read_dimacs	bliss/graph.cc	/^Digraph::read_dimacs(FILE* const fp, FILE* const errstr)$/;"	f	class:bliss::Digraph
read_dimacs	bliss/graph.cc	/^Graph::read_dimacs(FILE* const fp, FILE* const errstr)$/;"	f	class:bliss::Graph
read_everything	globals.cc	/^void read_everything(istream &in) {$/;"	f
read_goal	globals.cc	/^void read_goal(istream &in) {$/;"	f
read_mask	algorithms/int_packer.cc	/^    Bin read_mask;$/;"	m	class:int_packer::IntPacker::VariableInfo	file:
read_metric	globals.cc	/^void read_metric(istream &in) {$/;"	f
read_mutexes	globals.cc	/^void read_mutexes(istream &in) {$/;"	f
read_operators	globals.cc	/^void read_operators(istream &in) {$/;"	f
read_pre_post	global_operator.cc	/^void GlobalOperator::read_pre_post(istream &in) {$/;"	f	class:GlobalOperator
read_variables	globals.cc	/^void read_variables(istream &in) {$/;"	f
real_g	search_node_info.h	/^    int real_g;$/;"	m	struct:SearchNodeInfo
reasonable	landmarks/landmark_graph.h	/^    reasonable = 1,$/;"	m	class:landmarks::EdgeType
reasonable_orders	landmarks/landmark_factory.h	/^    const bool reasonable_orders;$/;"	m	class:landmarks::LandmarkFactory
recompute_max_additive_subsets	pdbs/incremental_canonical_pdbs.cc	/^void IncrementalCanonicalPDBs::recompute_max_additive_subsets() {$/;"	f	class:pdbs::IncrementalCanonicalPDBs
recurse_forwards	pruning/stubborn_sets_ec.cc	/^void recurse_forwards(const StubbornDTG &dtg,$/;"	f	namespace:stubborn_sets_ec
reduce	merge_and_shrink/label_reduction.cc	/^bool LabelReduction::reduce($/;"	f	class:merge_and_shrink::LabelReduction
reduce_before_merging	merge_and_shrink/label_reduction.h	/^    bool reduce_before_merging() const {$/;"	f	class:merge_and_shrink::LabelReduction
reduce_before_shrinking	merge_and_shrink/label_reduction.h	/^    bool reduce_before_shrinking() const {$/;"	f	class:merge_and_shrink::LabelReduction
reduce_labels	merge_and_shrink/labels.cc	/^void Labels::reduce_labels(const vector<int> &old_label_nos) {$/;"	f	class:merge_and_shrink::Labels
reduce_remaining_costs	cegar/cost_saturation.cc	/^void CostSaturation::reduce_remaining_costs($/;"	f	class:cegar::CostSaturation
reference	ext/tree.hh	/^				typedef T&                              reference;$/;"	t	class:tree::iterator_base
refine	algorithms/equivalence_relation.cc	/^void EquivalenceRelation::refine(ElementListConstIter block_X_begin,$/;"	f	class:equivalence_relation::EquivalenceRelation
refine	algorithms/equivalence_relation.cc	/^void EquivalenceRelation::refine(const Block &block_X) {$/;"	f	class:equivalence_relation::EquivalenceRelation
refine	algorithms/equivalence_relation.cc	/^void EquivalenceRelation::refine(const EquivalenceRelation &other) {$/;"	f	class:equivalence_relation::EquivalenceRelation
refine	cegar/abstraction.cc	/^void Abstraction::refine(AbstractState *state, int var, const vector<int> &wanted) {$/;"	f	class:cegar::Abstraction
refine_according_to_invariant	bliss/graph.cc	/^Digraph::refine_according_to_invariant(unsigned int (*inv)(const Digraph* const g,$/;"	f	class:bliss::Digraph
refine_according_to_invariant	bliss/graph.cc	/^Graph::refine_according_to_invariant(unsigned int (*inv)(const Graph* const g,$/;"	f	class:bliss::Graph
refine_best_path_subcertificate_end	bliss/graph.h	/^  unsigned int refine_best_path_subcertificate_end;$/;"	m	class:bliss::AbstractGraph
refine_cmp_to_best	bliss/graph.h	/^  int refine_cmp_to_best;$/;"	m	class:bliss::AbstractGraph
refine_compare_certificate	bliss/graph.h	/^  bool refine_compare_certificate;$/;"	m	class:bliss::AbstractGraph
refine_current_path_certificate_index	bliss/graph.h	/^  unsigned int refine_current_path_certificate_index;$/;"	m	class:bliss::AbstractGraph
refine_equal_to_first	bliss/graph.h	/^  bool refine_equal_to_first;$/;"	m	class:bliss::AbstractGraph
refine_first_path_subcertificate_end	bliss/graph.h	/^  unsigned int refine_first_path_subcertificate_end;$/;"	m	class:bliss::AbstractGraph
refine_to_equitable	bliss/graph.cc	/^AbstractGraph::refine_to_equitable()$/;"	f	class:bliss::AbstractGraph
refine_to_equitable	bliss/graph.cc	/^AbstractGraph::refine_to_equitable(Partition::Cell* const unit_cell)$/;"	f	class:bliss::AbstractGraph
refine_to_equitable	bliss/graph.cc	/^AbstractGraph::refine_to_equitable(Partition::Cell* const unit_cell1,$/;"	f	class:bliss::AbstractGraph
refinement_hierarchy	cegar/abstraction.h	/^    RefinementHierarchy refinement_hierarchy;$/;"	m	class:cegar::Abstraction
refinement_hierarchy	cegar/cartesian_heuristic_function.h	/^    RefinementHierarchy refinement_hierarchy;$/;"	m	class:cegar::CartesianHeuristicFunction
refinement_stack	bliss/partition.h	/^  KStack<RefInfo> refinement_stack;$/;"	m	class:bliss::Partition
refinement_stack_size	bliss/partition.h	/^    unsigned int refinement_stack_size;$/;"	m	class:bliss::Partition::BacktrackInfo
register_event_handlers	utils/system_unix.cc	/^void register_event_handlers() {$/;"	f	namespace:utils
register_event_handlers	utils/system_windows.cc	/^void register_event_handlers() {$/;"	f	namespace:utils
register_object	options/doc_store.cc	/^void DocStore::register_object(string k, string type) {$/;"	f	class:options::DocStore
register_plugin_type_plugin	options/plugin.cc	/^void register_plugin_type_plugin($/;"	f	namespace:options
register_state_buffer	state_registry.cc	/^GlobalState StateRegistry::register_state_buffer(const int *state) {$/;"	f	class:StateRegistry
registered	options/doc_store.h	/^    std::map<std::string, DocStruct> registered;$/;"	m	class:options::DocStore
registered	options/registries.h	/^    std::map<std::string, Factory> registered;$/;"	m	class:options::Registry
registered_states	state_registry.h	/^    StateIDSet registered_states;$/;"	m	class:StateRegistry
registry	global_state.h	/^    const StateRegistry *registry;$/;"	m	class:GlobalState
registry	options/registries.h	/^    Map registry;$/;"	m	class:options::PluginTypeRegistry
registry	per_state_information.h	/^        const StateRegistry *registry;$/;"	m	class:PerStateInformation::const_iterator
regress	cegar/abstract_state.cc	/^AbstractState AbstractState::regress(OperatorProxy op) const {$/;"	f	class:cegar::AbstractState
regression_preconditions	pdbs/pattern_database.h	/^    std::vector<FactPair> regression_preconditions;$/;"	m	class:pdbs::AbstractOperator
relaxation_heuristic	heuristics/relaxation_heuristic.cc	/^namespace relaxation_heuristic {$/;"	n	file:
relaxation_heuristic	heuristics/relaxation_heuristic.h	/^namespace relaxation_heuristic {$/;"	n
relaxed_exploration	heuristics/additive_heuristic.cc	/^void AdditiveHeuristic::relaxed_exploration() {$/;"	f	class:additive_heuristic::AdditiveHeuristic
relaxed_exploration	heuristics/max_heuristic.cc	/^void HSPMaxHeuristic::relaxed_exploration() {$/;"	f	class:max_heuristic::HSPMaxHeuristic
relaxed_exploration	landmarks/exploration.cc	/^void Exploration::relaxed_exploration(bool use_h_max, bool level_out) {$/;"	f	class:landmarks::Exploration
relaxed_operators	heuristics/lm_cut_landmarks.h	/^    std::vector<RelaxedOperator> relaxed_operators;$/;"	m	class:lm_cut_heuristic::LandmarkCutLandmarks
relaxed_plan	heuristics/ff_heuristic.h	/^    RelaxedPlan relaxed_plan;$/;"	m	class:ff_heuristic::FFHeuristic
relaxed_task_solvable	landmarks/landmark_factory.cc	/^bool LandmarkFactory::relaxed_task_solvable(const TaskProxy &task_proxy,$/;"	f	class:landmarks::LandmarkFactory
relaxed_task_solvable	landmarks/landmark_factory.h	/^    inline bool relaxed_task_solvable(const TaskProxy &task_proxy, Exploration &exploration,$/;"	f	class:landmarks::LandmarkFactory
release_extra_memory_padding	utils/memory.cc	/^void release_extra_memory_padding() {$/;"	f	namespace:utils
release_vector_memory	utils/collections.h	/^void release_vector_memory(std::vector<T> &vec) {$/;"	f	namespace:utils
relevant_labels	merge_and_shrink/fts_factory.cc	/^        vector<bool> relevant_labels;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
remaining_costs	cegar/cost_saturation.h	/^    std::vector<int> remaining_costs;$/;"	m	class:cegar::CostSaturation
remaining_vars	variable_order_finder.h	/^    std::vector<int> remaining_vars;$/;"	m	class:VariableOrderFinder
remove	bliss/heap.cc	/^unsigned int Heap::remove()$/;"	f	class:bliss::Heap
remove	cegar/domains.cc	/^void Domains::remove(int var, int value) {$/;"	f	class:cegar::Domains
remove_all	cegar/domains.cc	/^void Domains::remove_all(int var) {$/;"	f	class:cegar::Domains
remove_covered_samples	potentials/diverse_potential_heuristics.cc	/^void DiversePotentialHeuristics::remove_covered_samples($/;"	f	class:potentials::DiversePotentialHeuristics
remove_duplicate_edges	bliss/graph.cc	/^Digraph::Vertex::remove_duplicate_edges(std::vector<bool>& tmp)$/;"	f	class:bliss::Digraph::Vertex
remove_duplicate_edges	bliss/graph.cc	/^Digraph::remove_duplicate_edges()$/;"	f	class:bliss::Digraph
remove_duplicate_edges	bliss/graph.cc	/^Graph::Vertex::remove_duplicate_edges(std::vector<bool>& tmp)$/;"	f	class:bliss::Graph::Vertex
remove_duplicate_edges	bliss/graph.cc	/^Graph::remove_duplicate_edges()$/;"	f	class:bliss::Graph
remove_first_weakest_cycle_edge	landmarks/landmark_factory.cc	/^bool LandmarkFactory::remove_first_weakest_cycle_edge(LandmarkNode *cur,$/;"	f	class:landmarks::LandmarkFactory
remove_incoming_transition	cegar/abstract_state.cc	/^void AbstractState::remove_incoming_transition(int op_id, AbstractState *other) {$/;"	f	class:cegar::AbstractState
remove_incoming_transition	cegar/transition_updater.cc	/^void TransitionUpdater::remove_incoming_transition($/;"	f	class:cegar::TransitionUpdater
remove_initial_state_facts	cegar/subtask_generators.cc	/^static void remove_initial_state_facts($/;"	f	namespace:cegar
remove_irrelevant_variables	pdbs/pattern_collection_generator_genetic.cc	/^void PatternCollectionGeneratorGenetic::remove_irrelevant_variables($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
remove_key	open_lists/pareto_open_list.cc	/^void ParetoOpenList<Entry>::remove_key(const KeyType &key) {$/;"	f	class:ParetoOpenList
remove_min	open_lists/alternation_open_list.cc	/^Entry AlternationOpenList<Entry>::remove_min(vector<int> *key) {$/;"	f	class:AlternationOpenList
remove_min	open_lists/epsilon_greedy_open_list.cc	/^Entry EpsilonGreedyOpenList<Entry>::remove_min(vector<int> *key) {$/;"	f	class:EpsilonGreedyOpenList
remove_min	open_lists/pareto_open_list.cc	/^Entry ParetoOpenList<Entry>::remove_min(vector<int> *key) {$/;"	f	class:ParetoOpenList
remove_min	open_lists/standard_scalar_open_list.cc	/^Entry StandardScalarOpenList<Entry>::remove_min(vector<int> *key) {$/;"	f	class:StandardScalarOpenList
remove_min	open_lists/tiebreaking_open_list.cc	/^Entry TieBreakingOpenList<Entry>::remove_min(vector<int> *key) {$/;"	f	class:TieBreakingOpenList
remove_min	open_lists/type_based_open_list.cc	/^Entry TypeBasedOpenList<Entry>::remove_min(vector<int> *key) {$/;"	f	class:TypeBasedOpenList
remove_non_looping_transition	cegar/abstract_state.cc	/^void AbstractState::remove_non_looping_transition($/;"	f	class:cegar::AbstractState
remove_outgoing_transition	cegar/abstract_state.cc	/^void AbstractState::remove_outgoing_transition(int op_id, AbstractState *other) {$/;"	f	class:cegar::AbstractState
remove_outgoing_transition	cegar/transition_updater.cc	/^void TransitionUpdater::remove_outgoing_transition($/;"	f	class:cegar::TransitionUpdater
remove_state_registry	per_state_information.h	/^    void remove_state_registry(StateRegistry *registry) {$/;"	f	class:PerStateInformation
reopen	search_space.cc	/^void SearchNode::reopen(const SearchNode &parent_node,$/;"	f	class:SearchNode
reopen_closed_nodes	search_engines/eager_search.h	/^    const bool reopen_closed_nodes;$/;"	m	class:eager_search::EagerSearch
reopen_closed_nodes	search_engines/lazy_search.h	/^    bool reopen_closed_nodes; \/\/ whether to reopen closed nodes upon finding lower g paths$/;"	m	class:lazy_search::LazySearch
reopen_closed_nodes	search_engines/top_k_eager_search.h	/^    const bool reopen_closed_nodes;$/;"	m	class:top_k_eager_search::TopKEagerSearch
reopened_states	search_statistics.h	/^    int reopened_states;  \/\/ no of *closed* states which we reopened$/;"	m	class:SearchStatistics
reparent	ext/tree.hh	/^iter tree<T, tree_node_allocator>::reparent(iter position, sibling_iterator begin, sibling_iterator end)$/;"	f	class:tree
reparent	ext/tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::reparent(iter position, iter from)$/;"	f	class:tree
repeat_last_phase	search_engines/iterated_search.h	/^    bool repeat_last_phase;$/;"	m	class:iterated_search::IteratedSearch
replace	ext/tree.hh	/^iter tree<T, tree_node_allocator>::replace(iter position, const T& x)$/;"	f	class:tree
replace	ext/tree.hh	/^iter tree<T, tree_node_allocator>::replace(iter position, const iterator_base& from)$/;"	f	class:tree
replace	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::replace($/;"	f	class:tree
replace_if_less	structural_symmetries/permutation.cc	/^bool Permutation::replace_if_less(int* state) const {$/;"	f	class:Permutation
report_exit_code_reentrant	utils/system_unix.cc	/^void report_exit_code_reentrant(ExitCode exitcode) {$/;"	f	namespace:utils
report_exit_code_reentrant	utils/system_windows.cc	/^void report_exit_code_reentrant(ExitCode exitcode) {$/;"	f	namespace:utils
report_f_value_progress	search_statistics.cc	/^void SearchStatistics::report_f_value_progress(int f) {$/;"	f	class:SearchStatistics
report_hook	bliss/graph.h	/^  void (*report_hook)(void *user_param,$/;"	m	class:bliss::AbstractGraph
report_peak_memory_delta	merge_and_shrink/merge_and_shrink_heuristic.cc	/^void MergeAndShrinkHeuristic::report_peak_memory_delta(bool final) const {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
report_user_param	bliss/graph.h	/^  void *report_user_param;$/;"	m	class:bliss::AbstractGraph
reserve_extra_memory_padding	utils/memory.cc	/^void reserve_extra_memory_padding(int memory_in_mb) {$/;"	f	namespace:utils
reset	algorithms/dynamic_bitset.h	/^    void reset() {$/;"	f	class:dynamic_bitset::DynamicBitset
reset	algorithms/dynamic_bitset.h	/^    void reset(std::size_t pos) {$/;"	f	class:dynamic_bitset::DynamicBitset
reset	bliss/graph.h	/^  void reset()$/;"	f	class:bliss::Stats
reset	bliss/orbit.cc	/^void Orbit::reset()$/;"	f	class:bliss::Orbit
reset	bliss/timer.cc	/^void Timer::reset()$/;"	f	class:bliss::Timer
reset	bliss/uintseqhash.h	/^  void reset() {h = 0; }$/;"	f	class:bliss::UintSeqHash
reset	cegar/abstract_search.cc	/^void AbstractSearch::reset() {$/;"	f	class:cegar::AbstractSearch
reset	cegar/abstract_state.h	/^    void reset() {$/;"	f	class:cegar::AbstractSearchInfo
reset	cegar/cost_saturation.cc	/^void CostSaturation::reset(const TaskProxy &task_proxy) {$/;"	f	class:cegar::CostSaturation
reset	utils/timer.cc	/^double Timer::reset() {$/;"	f	class:utils::Timer
reset_permutation	bliss/graph.cc	/^AbstractGraph::reset_permutation(unsigned int* perm)$/;"	f	class:bliss::AbstractGraph
resize	algorithms/segmented_vector.h	/^    void resize(size_t new_size, Entry entry = Entry()) {$/;"	f	class:segmented_vector::SegmentedVector
resize	algorithms/segmented_vector.h	/^    void resize(size_t new_size, const Element *entry) {$/;"	f	class:segmented_vector::SegmentedArrayVector
resume	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::resume(SearchControl& search_control) {$/;"	f	class:top_k_eager_search::TopKEagerSearch
resume	utils/timer.cc	/^void Timer::resume() {$/;"	f	class:utils::Timer
revert_new_local_vars	domain_transition_graph.cc	/^void DTGFactory::revert_new_local_vars(DomainTransitionGraph *dtg,$/;"	f	class:DTGFactory
reward_progress	search_engines/eager_search.cc	/^void EagerSearch::reward_progress() {$/;"	f	class:eager_search::EagerSearch
reward_progress	search_engines/lazy_search.cc	/^void LazySearch::reward_progress() {$/;"	f	class:lazy_search::LazySearch
reward_progress	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::reward_progress() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
rewire	cegar/transition_updater.cc	/^void TransitionUpdater::rewire($/;"	f	class:cegar::TransitionUpdater
rewire_incoming_transitions	cegar/transition_updater.cc	/^void TransitionUpdater::rewire_incoming_transitions($/;"	f	class:cegar::TransitionUpdater
rewire_loops	cegar/transition_updater.cc	/^void TransitionUpdater::rewire_loops($/;"	f	class:cegar::TransitionUpdater
rewire_outgoing_transitions	cegar/transition_updater.cc	/^void TransitionUpdater::rewire_outgoing_transitions($/;"	f	class:cegar::TransitionUpdater
right_child	cegar/refinement_hierarchy.h	/^    Node *right_child;$/;"	m	class:cegar::Node
right_child	merge_and_shrink/merge_and_shrink_representation.h	/^    std::unique_ptr<MergeAndShrinkRepresentation> right_child;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
right_child	merge_and_shrink/merge_tree.h	/^    MergeTreeNode *right_child;$/;"	m	struct:merge_and_shrink::MergeTreeNode
rm_landmark_node	landmarks/landmark_graph.cc	/^void LandmarkGraph::rm_landmark_node(LandmarkNode *node) {$/;"	f	class:landmarks::LandmarkGraph
rng	cegar/cost_saturation.h	/^    utils::RandomNumberGenerator &rng;$/;"	m	class:cegar::CostSaturation
rng	cegar/subtask_generators.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:cegar::GoalDecomposition
rng	cegar/subtask_generators.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:cegar::LandmarkDecomposition
rng	merge_and_shrink/label_reduction.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:merge_and_shrink::LabelReduction
rng	merge_and_shrink/merge_scoring_function_single_random.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:merge_and_shrink::MergeScoringFunctionSingleRandom
rng	merge_and_shrink/merge_scoring_function_total_order.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:merge_and_shrink::MergeScoringFunctionTotalOrder
rng	merge_and_shrink/merge_tree.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:merge_and_shrink::MergeTree
rng	merge_and_shrink/merge_tree_factory.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:merge_and_shrink::MergeTreeFactory
rng	merge_and_shrink/shrink_bucket_based.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:merge_and_shrink::ShrinkBucketBased
rng	open_lists/epsilon_greedy_open_list.cc	/^    shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:EpsilonGreedyOpenList	file:
rng	open_lists/pareto_open_list.cc	/^    shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:ParetoOpenList	file:
rng	open_lists/type_based_open_list.cc	/^    shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:TypeBasedOpenList	file:
rng	pdbs/pattern_collection_generator_genetic.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
rng	pdbs/pattern_collection_generator_hillclimbing.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:pdbs::PatternCollectionGeneratorHillclimbing
rng	potentials/diverse_potential_heuristics.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:potentials::DiversePotentialHeuristics
rng	search_engines/lazy_search.h	/^    std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:lazy_search::LazySearch
rng	structural_symmetries/group.h	/^    const std::shared_ptr<utils::RandomNumberGenerator> rng;$/;"	m	class:Group
rng	utils/rng.h	/^    std::mt19937 rng;$/;"	m	class:utils::RandomNumberGenerator
root	cegar/refinement_hierarchy.h	/^    std::unique_ptr<Node> root;$/;"	m	class:cegar::RefinementHierarchy
root	merge_and_shrink/merge_tree.h	/^    MergeTreeNode *root;$/;"	m	class:merge_and_shrink::MergeTree
root	pdbs/match_tree.h	/^    Node *root;$/;"	m	class:pdbs::MatchTree
root	successor_generator.h	/^    std::unique_ptr<GeneratorBase> root;$/;"	m	class:SuccessorGenerator
row_lb	lp/lp_solver.h	/^    std::vector<double> row_lb;$/;"	m	class:lp::LPSolver
row_ub	lp/lp_solver.h	/^    std::vector<double> row_ub;$/;"	m	class:lp::LPSolver
rows	lp/lp_solver.h	/^    std::vector<CoinPackedVectorBase *> rows;$/;"	m	class:lp::LPSolver
rtab	bliss/uintseqhash.cc	/^static unsigned int rtab[256] = {$/;"	m	namespace:bliss	file:
rules	axioms.h	/^    std::vector<AxiomRule> rules;$/;"	m	class:AxiomEvaluator
rw_length_or_number_symmetric_states	structural_symmetries/group.h	/^    int rw_length_or_number_symmetric_states;$/;"	m	class:Group
sample_states	pdbs/pattern_collection_generator_hillclimbing.cc	/^void PatternCollectionGeneratorHillclimbing::sample_states($/;"	f	class:pdbs::PatternCollectionGeneratorHillclimbing
sample_states_with_random_walks	sampling.cc	/^vector<State> sample_states_with_random_walks($/;"	f
sample_without_dead_end_detection	potentials/util.cc	/^vector<State> sample_without_dead_end_detection($/;"	f	namespace:potentials
satisfies_goal_conditions	landmarks/landmark_factory_zhu_givan.cc	/^bool LandmarkFactoryZhuGivan::satisfies_goal_conditions($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
save_plan	globals.cc	/^void save_plan(const vector<const GlobalOperator *> &plan,$/;"	f
save_plan_if_necessary	search_engine.cc	/^void SearchEngine::save_plan_if_necessary() const {$/;"	f	class:SearchEngine
save_plan_if_necessary	search_engines/iterated_search.cc	/^void IteratedSearch::save_plan_if_necessary() const {$/;"	f	class:iterated_search::IteratedSearch
search	bliss/graph.cc	/^AbstractGraph::search(const bool canonical, Stats& stats)$/;"	f	class:bliss::AbstractGraph
search	search_engine.cc	/^void SearchEngine::search() {$/;"	f	class:SearchEngine
search	search_engines/kstar.cc	/^void KStar::search() {$/;"	f	class:kstar::KStar
search_common	search_engines/search_common.cc	/^namespace search_common {$/;"	n	file:
search_common	search_engines/search_common.h	/^namespace search_common {$/;"	n
search_info	cegar/abstract_state.h	/^    AbstractSearchInfo search_info;$/;"	m	class:cegar::AbstractState
search_node_infos	search_space.h	/^    PerStateInformation<SearchNodeInfo> search_node_infos;$/;"	m	class:SearchSpace
search_progress	search_engine.h	/^    SearchProgress search_progress;$/;"	m	class:SearchEngine
search_space	search_engine.h	/^    SearchSpace search_space;$/;"	m	class:SearchEngine
search_symmetries	structural_symmetries/group.h	/^    SearchSymmetries search_symmetries;$/;"	m	class:Group
second_exploration	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::second_exploration($/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
seed	utils/rng.cc	/^void RandomNumberGenerator::seed(int seed) {$/;"	f	class:utils::RandomNumberGenerator
segmented_vector	algorithms/segmented_vector.h	/^namespace segmented_vector {$/;"	n
segments	algorithms/segmented_vector.h	/^    std::vector<Element *> segments;$/;"	m	class:segmented_vector::SegmentedArrayVector
segments	algorithms/segmented_vector.h	/^    std::vector<Entry *> segments;$/;"	m	class:segmented_vector::SegmentedVector
select	pdbs/pattern_collection_generator_genetic.cc	/^void PatternCollectionGeneratorGenetic::select($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
select_merge	merge_and_shrink/merge_selector_score_based_filtering.cc	/^pair<int, int> MergeSelectorScoreBasedFiltering::select_merge($/;"	f	class:merge_and_shrink::MergeSelectorScoreBasedFiltering
select_next	variable_order_finder.cc	/^void VariableOrderFinder::select_next(int position, int var_no) {$/;"	f	class:VariableOrderFinder
selected_vars	variable_order_finder.h	/^    std::vector<int> selected_vars;$/;"	m	class:VariableOrderFinder
selfloop_invariant	bliss/graph.cc	/^Digraph::selfloop_invariant(const Digraph* const g, const unsigned int vnum)$/;"	f	class:bliss::Digraph
selfloop_invariant	bliss/graph.cc	/^Graph::selfloop_invariant(const Graph* const g, const unsigned int v)$/;"	f	class:bliss::Graph
separate_facts_unreachable_before_goal	cegar/abstraction.cc	/^void Abstraction::separate_facts_unreachable_before_goal() {$/;"	f	class:cegar::Abstraction
set	algorithms/dynamic_bitset.h	/^    void set() {$/;"	f	class:dynamic_bitset::DynamicBitset
set	algorithms/dynamic_bitset.h	/^    void set(std::size_t pos) {$/;"	f	class:dynamic_bitset::DynamicBitset
set	algorithms/int_packer.cc	/^    void set(Bin *buffer, int value) const {$/;"	f	class:int_packer::IntPacker::VariableInfo
set	algorithms/int_packer.cc	/^void IntPacker::set(Bin *buffer, int var, int value) const {$/;"	f	class:int_packer::IntPacker
set	options/options.h	/^    void set(std::string key, T value) {$/;"	f	class:options::Options
set_additional_goals	landmarks/exploration.cc	/^void Exploration::set_additional_goals(const vector<FactPair> &add_goals) {$/;"	f	class:landmarks::Exploration
set_affected	structural_symmetries/permutation.cc	/^void Permutation::set_affected(int ind, int val) {$/;"	f	class:Permutation
set_backtrack_point	bliss/partition.cc	/^Partition::set_backtrack_point()$/;"	f	class:bliss::Partition
set_bound	search_engine.h	/^    void set_bound(int b) {bound = b; }$/;"	f	class:SearchEngine
set_component_recursion	bliss/graph.h	/^  void set_component_recursion(const bool active) {assert(!in_search); opt_use_comprec = active;}$/;"	f	class:bliss::AbstractGraph
set_constraint_lower_bound	lp/lp_solver.cc	/^void LPSolver::set_constraint_lower_bound(int index, double bound) {$/;"	f	class:lp::LPSolver
set_constraint_upper_bound	lp/lp_solver.cc	/^void LPSolver::set_constraint_upper_bound(int index, double bound) {$/;"	f	class:lp::LPSolver
set_cost	merge_and_shrink/label_equivalence_relation.h	/^    void set_cost(int cost_) {$/;"	f	class:merge_and_shrink::LabelGroup
set_count_evaluation	evaluation_result.cc	/^void EvaluationResult::set_count_evaluation(bool count_eval) {$/;"	f	class:EvaluationResult
set_distances	merge_and_shrink/merge_and_shrink_representation.cc	/^void MergeAndShrinkRepresentationLeaf::set_distances($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
set_distances	merge_and_shrink/merge_and_shrink_representation.cc	/^void MergeAndShrinkRepresentationMerge::set_distances($/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentationMerge
set_exploration_goals	landmarks/landmark_count_heuristic.cc	/^void LandmarkCountHeuristic::set_exploration_goals(const GlobalState &global_state) {$/;"	f	class:landmarks::LandmarkCountHeuristic
set_failure_recording	bliss/graph.h	/^  void set_failure_recording(const bool active) {assert(!in_search); opt_use_failure_recording = active;}$/;"	f	class:bliss::AbstractGraph
set_group	state_registry.h	/^    void set_group(const std::shared_ptr<Group> &group_) {$/;"	f	class:StateRegistry
set_h_value	cegar/abstract_state.cc	/^void AbstractState::set_h_value(int new_h) {$/;"	f	class:cegar::AbstractState
set_h_value	evaluation_result.cc	/^void EvaluationResult::set_h_value(int value) {$/;"	f	class:EvaluationResult
set_head	ext/tree.hh	/^typename tree<T, tree_node_allocator>::pre_order_iterator tree<T, tree_node_allocator>::set_head(const T& x)$/;"	f	class:tree
set_help_mode	options/option_parser.cc	/^void OptionParser::set_help_mode(bool m) {$/;"	f	class:options::OptionParser
set_help_mode	options/options.h	/^    void set_help_mode(bool hm) {$/;"	f	class:options::Options
set_incoming_transition	cegar/abstract_state.h	/^    void set_incoming_transition(const Transition &transition) {$/;"	f	class:cegar::AbstractSearchInfo
set_indices_	landmarks/landmark_factory_h_m.h	/^    FluentSetToIntMap set_indices_;$/;"	m	class:landmarks::LandmarkFactoryHM
set_landmark_cost	landmarks/landmark_graph.h	/^    void set_landmark_cost(int cost) {$/;"	f	class:landmarks::EdgeType::LandmarkGraph
set_landmark_ids	landmarks/landmark_graph.cc	/^void LandmarkGraph::set_landmark_ids() {$/;"	f	class:landmarks::LandmarkGraph
set_landmarks_for_initial_state	landmarks/landmark_status_manager.cc	/^void LandmarkStatusManager::set_landmarks_for_initial_state($/;"	f	class:landmarks::LandmarkStatusManager
set_long_prune_activity	bliss/graph.h	/^  void set_long_prune_activity(const bool active) {$/;"	f	class:bliss::AbstractGraph
set_lower_bound	lp/lp_solver.h	/^    void set_lower_bound(double lb) {lower_bound = lb; }$/;"	f	class:lp::LPConstraint
set_max_additive_subsets	pdbs/pattern_collection_information.cc	/^void PatternCollectionInformation::set_max_additive_subsets($/;"	f	class:pdbs::PatternCollectionInformation
set_minus	landmarks/landmark_factory_h_m.cc	/^void set_minus(list<T> &alist, const list<T> &other) {$/;"	f	namespace:landmarks
set_objective_coefficient	lp/lp_solver.cc	/^void LPSolver::set_objective_coefficient(int index, double coefficient) {$/;"	f	class:lp::LPSolver
set_objective_coefficients	lp/lp_solver.cc	/^void LPSolver::set_objective_coefficients(const vector<double> &coefficients) {$/;"	f	class:lp::LPSolver
set_parent_	ext/tree.hh	/^void tree<T, tree_node_allocator>::sibling_iterator::set_parent_()$/;"	f	class:tree::sibling_iterator
set_pdbs	pdbs/pattern_collection_information.cc	/^void PatternCollectionInformation::set_pdbs(const shared_ptr<PDBCollection> &pdbs_) {$/;"	f	class:pdbs::PatternCollectionInformation
set_plan	search_engine.cc	/^void SearchEngine::set_plan(const Plan &p) {$/;"	f	class:SearchEngine
set_pref_operator_heuristics	search_engines/lazy_search.cc	/^void LazySearch::set_pref_operator_heuristics($/;"	f	class:lazy_search::LazySearch
set_preferred	heuristic.cc	/^void Heuristic::set_preferred(const GlobalOperator *op) {$/;"	f	class:Heuristic
set_preferred	heuristic.cc	/^void Heuristic::set_preferred(const OperatorProxy &op) {$/;"	f	class:Heuristic
set_preferred_operators	evaluation_result.cc	/^void EvaluationResult::set_preferred_operators($/;"	f	class:EvaluationResult
set_recompute_heuristic	landmarks/exploration.h	/^    void set_recompute_heuristic() {heuristic_recomputation_needed = true; }$/;"	f	class:landmarks::Exploration
set_single_value	cegar/domains.cc	/^void Domains::set_single_value(int var, int value) {$/;"	f	class:cegar::Domains
set_splitting_heuristic	bliss/graph.h	/^  void set_splitting_heuristic(SplittingHeuristic shs) {sh = shs; }$/;"	f	class:bliss::Digraph
set_splitting_heuristic	bliss/graph.h	/^  void set_splitting_heuristic(const SplittingHeuristic shs) {sh = shs; }$/;"	f	class:bliss::Graph
set_synopsis	options/doc_store.cc	/^void DocStore::set_synopsis(string k,$/;"	f	class:options::DocStore
set_time_limit	bliss/graph.h	/^  void set_time_limit(double time_limit_) {time_limit = time_limit_; }$/;"	f	class:bliss::AbstractGraph
set_unparsed_config	options/option_parser.cc	/^void OptionParser::set_unparsed_config() {$/;"	f	class:options::OptionParser
set_unparsed_config	options/options.h	/^    void set_unparsed_config(const std::string &config) {$/;"	f	class:options::Options
set_up_local_problem	heuristics/cea_heuristic.cc	/^void ContextEnhancedAdditiveHeuristic::set_up_local_problem($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
set_upper_bound	lp/lp_solver.h	/^    void set_upper_bound(double ub) {upper_bound = ub; }$/;"	f	class:lp::LPConstraint
set_value	structural_symmetries/operator_permutation.cc	/^void OperatorPermutation::set_value(int op_no, int to_op_no) {$/;"	f	class:OperatorPermutation
set_value	structural_symmetries/permutation.cc	/^void Permutation::set_value(int ind, int val) {$/;"	f	class:Permutation
set_variable_lower_bound	lp/lp_solver.cc	/^void LPSolver::set_variable_lower_bound(int index, double bound) {$/;"	f	class:lp::LPSolver
set_variable_upper_bound	lp/lp_solver.cc	/^void LPSolver::set_variable_upper_bound(int index, double bound) {$/;"	f	class:lp::LPSolver
set_verbose_file	bliss/graph.cc	/^AbstractGraph::set_verbose_file(FILE* const fp)$/;"	f	class:bliss::AbstractGraph
set_verbose_level	bliss/graph.cc	/^AbstractGraph::set_verbose_level(const unsigned int level)$/;"	f	class:bliss::AbstractGraph
setup_domain_transition_graphs	heuristics/cg_heuristic.cc	/^void CGHeuristic::setup_domain_transition_graphs() {$/;"	f	class:cg_heuristic::CGHeuristic
setup_exploration_queue	heuristics/additive_heuristic.cc	/^void AdditiveHeuristic::setup_exploration_queue() {$/;"	f	class:additive_heuristic::AdditiveHeuristic
setup_exploration_queue	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::setup_exploration_queue() {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
setup_exploration_queue	heuristics/max_heuristic.cc	/^void HSPMaxHeuristic::setup_exploration_queue() {$/;"	f	class:max_heuristic::HSPMaxHeuristic
setup_exploration_queue	landmarks/exploration.cc	/^void Exploration::setup_exploration_queue(const State &state,$/;"	f	class:landmarks::Exploration
setup_exploration_queue	landmarks/exploration.h	/^    void setup_exploration_queue(const State &state, bool h_max) {$/;"	f	class:landmarks::Exploration
setup_exploration_queue_state	heuristics/additive_heuristic.cc	/^void AdditiveHeuristic::setup_exploration_queue_state(const State &state) {$/;"	f	class:additive_heuristic::AdditiveHeuristic
setup_exploration_queue_state	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::setup_exploration_queue_state(const State &state) {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
setup_exploration_queue_state	heuristics/max_heuristic.cc	/^void HSPMaxHeuristic::setup_exploration_queue_state(const State &state) {$/;"	f	class:max_heuristic::HSPMaxHeuristic
sh	bliss/graph.h	/^  SplittingHeuristic sh;$/;"	m	class:bliss::Digraph
sh	bliss/graph.h	/^  SplittingHeuristic sh;$/;"	m	class:bliss::Graph
sh_first	bliss/graph.cc	/^Digraph::sh_first()$/;"	f	class:bliss::Digraph
sh_first	bliss/graph.cc	/^Graph::sh_first()$/;"	f	class:bliss::Graph
sh_first_largest	bliss/graph.cc	/^Digraph::sh_first_largest()$/;"	f	class:bliss::Digraph
sh_first_largest	bliss/graph.cc	/^Graph::sh_first_largest()$/;"	f	class:bliss::Graph
sh_first_largest_max_neighbours	bliss/graph.cc	/^Digraph::sh_first_largest_max_neighbours()$/;"	f	class:bliss::Digraph
sh_first_largest_max_neighbours	bliss/graph.cc	/^Graph::sh_first_largest_max_neighbours()$/;"	f	class:bliss::Graph
sh_first_max_neighbours	bliss/graph.cc	/^Digraph::sh_first_max_neighbours()$/;"	f	class:bliss::Digraph
sh_first_max_neighbours	bliss/graph.cc	/^Graph::sh_first_max_neighbours()$/;"	f	class:bliss::Graph
sh_first_smallest	bliss/graph.cc	/^Digraph::sh_first_smallest()$/;"	f	class:bliss::Digraph
sh_first_smallest	bliss/graph.cc	/^Graph::sh_first_smallest()$/;"	f	class:bliss::Graph
sh_first_smallest_max_neighbours	bliss/graph.cc	/^Digraph::sh_first_smallest_max_neighbours()$/;"	f	class:bliss::Digraph
sh_first_smallest_max_neighbours	bliss/graph.cc	/^Graph::sh_first_smallest_max_neighbours()$/;"	f	class:bliss::Graph
shared_cost	landmarks/landmark_graph.h	/^    double shared_cost;$/;"	m	class:landmarks::EdgeType::LandmarkNode
shellsort_cell	bliss/partition.cc	/^Partition::shellsort_cell(Partition::Cell* const cell)$/;"	f	class:bliss::Partition
shift	algorithms/int_packer.cc	/^    int shift;$/;"	m	class:int_packer::IntPacker::VariableInfo	file:
shrink	merge_and_shrink/shrink_bisimulation.cc	/^bool ShrinkBisimulation::shrink($/;"	f	class:merge_and_shrink::ShrinkBisimulation
shrink	merge_and_shrink/shrink_bucket_based.cc	/^bool ShrinkBucketBased::shrink($/;"	f	class:merge_and_shrink::ShrinkBucketBased
shrink_before_merge	merge_and_shrink/merge_and_shrink_heuristic.cc	/^pair<bool, bool> MergeAndShrinkHeuristic::shrink_before_merge($/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
shrink_fts	merge_and_shrink/shrink_strategy.cc	/^bool ShrinkStrategy::shrink_fts($/;"	f	class:merge_and_shrink::ShrinkStrategy
shrink_strategy	merge_and_shrink/merge_and_shrink_heuristic.h	/^    std::shared_ptr<ShrinkStrategy> shrink_strategy;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
shrink_threshold_before_merge	merge_and_shrink/merge_and_shrink_heuristic.h	/^    const int shrink_threshold_before_merge;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
shrink_transition_system	merge_and_shrink/utils.cc	/^bool shrink_transition_system($/;"	f	namespace:merge_and_shrink
shs_f	bliss/graph.h	/^    shs_f = 0,$/;"	e	enum:bliss::Digraph::__anon2
shs_f	bliss/graph.h	/^    shs_f = 0,$/;"	e	enum:bliss::Graph::__anon1
shs_fl	bliss/graph.h	/^    shs_fl,$/;"	e	enum:bliss::Digraph::__anon2
shs_fl	bliss/graph.h	/^    shs_fl,$/;"	e	enum:bliss::Graph::__anon1
shs_flm	bliss/graph.h	/^    shs_flm$/;"	e	enum:bliss::Digraph::__anon2
shs_flm	bliss/graph.h	/^    shs_flm$/;"	e	enum:bliss::Graph::__anon1
shs_fm	bliss/graph.h	/^    shs_fm,$/;"	e	enum:bliss::Digraph::__anon2
shs_fm	bliss/graph.h	/^    shs_fm,$/;"	e	enum:bliss::Graph::__anon1
shs_fs	bliss/graph.h	/^    shs_fs,$/;"	e	enum:bliss::Digraph::__anon2
shs_fs	bliss/graph.h	/^    shs_fs,$/;"	e	enum:bliss::Graph::__anon1
shs_fsm	bliss/graph.h	/^    shs_fsm,$/;"	e	enum:bliss::Digraph::__anon2
shs_fsm	bliss/graph.h	/^    shs_fsm,$/;"	e	enum:bliss::Graph::__anon1
shuffle	algorithms/ordered_set.h	/^    void shuffle(utils::RandomNumberGenerator &rng) {$/;"	f	class:ordered_set::OrderedSet
shuffle	utils/rng.h	/^    void shuffle(std::vector<T> &vec) {$/;"	f	class:utils::RandomNumberGenerator
sibling	ext/tree.hh	/^typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::sibling(const iterator_base& it, unsigned int num)$/;"	f	class:tree
sibling_iterator	ext/tree.hh	/^		class sibling_iterator : public iterator_base {$/;"	c	class:tree
sibling_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator() $/;"	f	class:tree::sibling_iterator
sibling_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const iterator_base& other)$/;"	f	class:tree::sibling_iterator
sibling_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(const sibling_iterator& other)$/;"	f	class:tree::sibling_iterator
sibling_iterator	ext/tree.hh	/^tree<T, tree_node_allocator>::sibling_iterator::sibling_iterator(tree_node *tn)$/;"	f	class:tree::sibling_iterator
signal_handler	utils/system_unix.cc	/^void signal_handler(int signal_number) {$/;"	f	namespace:utils
signal_handler	utils/system_windows.cc	/^void signal_handler(int signal_number) {$/;"	f	namespace:utils
simple_landmark_exists	landmarks/landmark_graph.cc	/^bool LandmarkGraph::simple_landmark_exists(const FactPair &lm) const {$/;"	f	class:landmarks::LandmarkGraph
simple_lms_to_nodes	landmarks/landmark_graph.h	/^    std::unordered_map<FactPair, LandmarkNode *> simple_lms_to_nodes;$/;"	m	class:landmarks::EdgeType::LandmarkGraph
simplify	heuristics/relaxation_heuristic.cc	/^void RelaxationHeuristic::simplify() {$/;"	f	class:relaxation_heuristic::RelaxationHeuristic
simplify_labels	domain_transition_graph.cc	/^void DTGFactory::simplify_labels(vector<ValueTransitionLabel> &labels) {$/;"	f	class:DTGFactory
simplify_transitions	domain_transition_graph.cc	/^void DTGFactory::simplify_transitions(vector<DomainTransitionGraph *> &dtgs) {$/;"	f	class:DTGFactory
size	algorithms/dynamic_bitset.h	/^    std::size_t size() const {$/;"	f	class:dynamic_bitset::DynamicBitset
size	algorithms/ordered_set.h	/^    int size() const {$/;"	f	class:ordered_set::OrderedSet
size	algorithms/segmented_vector.h	/^    size_t size() const {$/;"	f	class:segmented_vector::SegmentedArrayVector
size	algorithms/segmented_vector.h	/^    size_t size() const {$/;"	f	class:segmented_vector::SegmentedVector
size	bliss/heap.h	/^  unsigned int size() const {return n; }$/;"	f	class:bliss::Heap
size	bliss/kqueue.h	/^unsigned int KQueue<Type>::size() const$/;"	f	class:bliss::KQueue
size	bliss/kstack.h	/^  unsigned int size() const {return(cursor - entries); }$/;"	f	class:bliss::KStack
size	bliss/orbit.h	/^    unsigned int size;$/;"	m	class:bliss::Orbit::OrbitEntry
size	ext/tree.hh	/^size_t tree<T, tree_node_allocator>::size() const$/;"	f	class:tree
size	ext/tree.hh	/^size_t tree<T, tree_node_allocator>::size(const iterator_base& top) const$/;"	f	class:tree
size	open_lists/epsilon_greedy_open_list.cc	/^    int size;$/;"	m	class:EpsilonGreedyOpenList	file:
size	open_lists/standard_scalar_open_list.cc	/^    int size;$/;"	m	class:StandardScalarOpenList	file:
size	open_lists/tiebreaking_open_list.cc	/^    int size;$/;"	m	class:TieBreakingOpenList	file:
size	pdbs/incremental_canonical_pdbs.h	/^    int size;$/;"	m	class:pdbs::IncrementalCanonicalPDBs
size	state_registry.h	/^    size_t size() const {$/;"	f	class:StateRegistry
size	task_proxy.h	/^    std::size_t size() const {$/;"	f	class:AxiomsProxy
size	task_proxy.h	/^    std::size_t size() const {$/;"	f	class:EffectsProxy
size	task_proxy.h	/^    std::size_t size() const {$/;"	f	class:OperatorsProxy
size	task_proxy.h	/^    std::size_t size() const {$/;"	f	class:State
size	task_proxy.h	/^    std::size_t size() const {$/;"	f	class:VariablesProxy
size_type	ext/tree.hh	/^				typedef size_t                          size_type;$/;"	t	class:tree::iterator_base
skip_children	ext/tree.hh	/^void tree<T, tree_node_allocator>::iterator_base::skip_children()$/;"	f	class:tree::iterator_base
skip_children	ext/tree.hh	/^void tree<T, tree_node_allocator>::iterator_base::skip_children(bool skip)$/;"	f	class:tree::iterator_base
skip_current_children_	ext/tree.hh	/^				bool skip_current_children_;$/;"	m	class:tree::iterator_base
smaller_variable_id	successor_generator.cc	/^bool smaller_variable_id(const FactProxy &f1, const FactProxy &f2) {$/;"	f
solution	cegar/abstract_search.h	/^    Solution solution;$/;"	m	class:cegar::AbstractSearch
solution_found	search_engine.h	/^    bool solution_found;$/;"	m	class:SearchEngine
solve	lp/lp_solver.cc	/^void LPSolver::solve() {$/;"	f	class:lp::LPSolver
solve_and_extract	potentials/potential_optimizer.cc	/^void PotentialOptimizer::solve_and_extract() {$/;"	f	class:potentials::PotentialOptimizer
sometimes_produced_by	operator_counting/state_equation_constraints.h	/^    std::set<int> sometimes_produced_by;$/;"	m	struct:operator_counting::Proposition
sort	ext/tree.hh	/^void tree<T, tree_node_allocator>::sort(sibling_iterator from, sibling_iterator to, $/;"	f	class:tree
sort	ext/tree.hh	/^void tree<T, tree_node_allocator>::sort(sibling_iterator from, sibling_iterator to, bool deep)$/;"	f	class:tree
sort_and_split_cell1	bliss/partition.cc	/^Partition::sort_and_split_cell1(Partition::Cell* const cell)$/;"	f	class:bliss::Partition
sort_and_split_cell255	bliss/partition.cc	/^Partition::sort_and_split_cell255(Partition::Cell* const cell,$/;"	f	class:bliss::Partition
sort_edges	bliss/graph.cc	/^Digraph::Vertex::sort_edges()$/;"	f	class:bliss::Digraph::Vertex
sort_edges	bliss/graph.cc	/^Digraph::sort_edges()$/;"	f	class:bliss::Digraph
sort_edges	bliss/graph.cc	/^Graph::Vertex::sort_edges()$/;"	f	class:bliss::Graph::Vertex
sort_edges	bliss/graph.cc	/^Graph::sort_edges()$/;"	f	class:bliss::Graph
sorted	utils/collections.h	/^std::vector<T> sorted(Collection &&collection) {$/;"	f	namespace:utils
sorted_goals	pruning/stubborn_sets.h	/^    std::vector<FactPair> sorted_goals;$/;"	m	class:stubborn_sets::StubbornSets
sorted_op_effects	pruning/stubborn_sets.h	/^    std::vector<std::vector<FactPair>> sorted_op_effects;$/;"	m	class:stubborn_sets::StubbornSets
sorted_op_preconditions	pruning/stubborn_sets.h	/^    std::vector<std::vector<FactPair>> sorted_op_preconditions;$/;"	m	class:stubborn_sets::StubbornSets
source	heuristics/cea_heuristic.cc	/^    LocalProblemNode *source;$/;"	m	struct:cea_heuristic::LocalTransition	file:
split	cegar/abstract_state.cc	/^pair<AbstractState *, AbstractState *> AbstractState::split($/;"	f	class:cegar::AbstractState
split	cegar/refinement_hierarchy.cc	/^pair<Node *, Node *> Node::split(int var, const vector<int> &values) {$/;"	f	class:cegar::Node
split_cell	bliss/partition.cc	/^Partition::split_cell(Partition::Cell* const original_cell)$/;"	f	class:bliss::Partition
split_cell_first	bliss/graph.cc	/^  unsigned int split_cell_first;$/;"	m	class:bliss::TreeNode	file:
split_cell_first	bliss/partition.h	/^    unsigned int split_cell_first;$/;"	m	class:bliss::Partition::RefInfo
split_element	bliss/graph.cc	/^  int split_element;$/;"	m	class:bliss::TreeNode	file:
split_level	bliss/partition.h	/^    unsigned int split_level;$/;"	m	class:bliss::Partition::Cell
split_neighbourhood_of_cell	bliss/graph.cc	/^Digraph::split_neighbourhood_of_cell(Partition::Cell* const cell)$/;"	f	class:bliss::Digraph
split_neighbourhood_of_cell	bliss/graph.cc	/^Graph::split_neighbourhood_of_cell(Partition::Cell* const cell)$/;"	f	class:bliss::Graph
split_neighbourhood_of_unit_cell	bliss/graph.cc	/^Digraph::split_neighbourhood_of_unit_cell(Partition::Cell* const unit_cell)$/;"	f	class:bliss::Digraph
split_neighbourhood_of_unit_cell	bliss/graph.cc	/^Graph::split_neighbourhood_of_unit_cell(Partition::Cell* const unit_cell)$/;"	f	class:bliss::Graph
split_selector	cegar/abstraction.h	/^    SplitSelector split_selector;$/;"	m	class:cegar::Abstraction
splitted_level_trail_index	bliss/partition.h	/^    unsigned int splitted_level_trail_index;$/;"	m	class:bliss::Partition::CR_BTInfo
splitting_element	bliss/graph.cc	/^  unsigned int splitting_element;$/;"	m	struct:bliss::__anon3	file:
splitting_queue	bliss/partition.h	/^  KQueue<Cell*> splitting_queue;$/;"	m	class:bliss::Partition
splitting_queue_add	bliss/partition.cc	/^Partition::splitting_queue_add(Cell* const cell)$/;"	f	class:bliss::Partition
splitting_queue_clear	bliss/partition.cc	/^Partition::splitting_queue_clear()$/;"	f	class:bliss::Partition
splitting_queue_is_empty	bliss/partition.h	/^Partition::splitting_queue_is_empty() const$/;"	f	class:bliss::Partition
splitting_queue_pop	bliss/partition.h	/^Partition::splitting_queue_pop()$/;"	f	class:bliss::Partition
src	merge_and_shrink/transition_system.h	/^    int src;$/;"	m	struct:merge_and_shrink::Transition
stabilize_initial_state	structural_symmetries/graph_creator.h	/^    bool stabilize_initial_state;$/;"	m	class:GraphCreator
stabilize_initial_state	structural_symmetries/group.h	/^    bool stabilize_initial_state;$/;"	m	class:Group
standard_out_of_memory_handler	utils/memory.cc	/^static void (*standard_out_of_memory_handler)() = nullptr;$/;"	m	namespace:utils	file:
star_successor	pdbs/match_tree.cc	/^    Node *star_successor;$/;"	m	struct:pdbs::MatchTree::Node	file:
start_f_value_statistics	search_engines/eager_search.cc	/^void EagerSearch::start_f_value_statistics(EvaluationContext &eval_context) {$/;"	f	class:eager_search::EagerSearch
start_f_value_statistics	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::start_f_value_statistics(EvaluationContext &eval_context) {$/;"	f	class:top_k_eager_search::TopKEagerSearch
start_parsing	options/option_parser.h	/^T OptionParser::start_parsing() {$/;"	f	class:options::OptionParser
start_ticks	utils/timer.h	/^    LARGE_INTEGER start_ticks;$/;"	m	class:utils::Timer
start_time	bliss/timer.h	/^  double start_time;$/;"	m	class:bliss::Timer
starting_peak_memory	merge_and_shrink/merge_and_shrink_heuristic.h	/^    long starting_peak_memory;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
starts	lp/lp_solver.h	/^    std::vector<int> starts;$/;"	m	class:lp::LPSolver
state	heuristic_cache.h	/^    GlobalState state;$/;"	m	class:HeuristicCache
state	merge_and_shrink/shrink_bisimulation.cc	/^    int state;$/;"	m	struct:merge_and_shrink::Signature	file:
state_data_pool	state_registry.h	/^        const segmented_vector::SegmentedArrayVector<PackedStateBin> &state_data_pool;$/;"	m	struct:StateRegistry::StateIDSemanticEqual
state_data_pool	state_registry.h	/^        const segmented_vector::SegmentedArrayVector<PackedStateBin> &state_data_pool;$/;"	m	struct:StateRegistry::StateIDSemanticHash
state_data_pool	state_registry.h	/^    segmented_vector::SegmentedArrayVector<PackedStateBin> state_data_pool;$/;"	m	class:StateRegistry
state_id	search_space.h	/^    StateID state_id;$/;"	m	class:SearchNode
state_is_dead_end	cegar/cost_saturation.cc	/^bool CostSaturation::state_is_dead_end(const State &state) const {$/;"	f	class:cegar::CostSaturation
state_label	utils/util.h	/^inline std::string state_label(GlobalState& s)$/;"	f
state_label	utils/util.h	/^inline std::string state_label(const GlobalState& s)$/;"	f
state_packer	state_registry.h	/^    const int_packer::IntPacker &state_packer;$/;"	m	class:StateRegistry
state_registry	search_engine.h	/^    StateRegistry state_registry;$/;"	m	class:SearchEngine
state_registry	search_space.h	/^    StateRegistry &state_registry;$/;"	m	class:SearchSpace
state_registry	search_space.h	/^    const StateRegistry &state_registry;$/;"	m	class:SearchNode
state_size	state_registry.h	/^        int state_size;$/;"	m	struct:StateRegistry::StateIDSemanticEqual
state_size	state_registry.h	/^        int state_size;$/;"	m	struct:StateRegistry::StateIDSemanticHash
state_uniform_selection	open_lists/pareto_open_list.cc	/^    bool state_uniform_selection;$/;"	m	class:ParetoOpenList	file:
states	cegar/abstract_search.h	/^    AbstractStates &states;$/;"	m	class:cegar::AbstractSearch
states	cegar/abstraction.h	/^    AbstractStates states;$/;"	m	class:cegar::Abstraction
statistics	evaluation_context.h	/^    SearchStatistics *statistics;$/;"	m	class:EvaluationContext
statistics	merge_and_shrink/distances.cc	/^void Distances::statistics() const {$/;"	f	class:merge_and_shrink::Distances
statistics	merge_and_shrink/factored_transition_system.cc	/^void FactoredTransitionSystem::statistics(int index) const {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
statistics	merge_and_shrink/transition_system.cc	/^void TransitionSystem::statistics() const {$/;"	f	class:merge_and_shrink::TransitionSystem
statistics	search_engine.h	/^    SearchStatistics statistics;$/;"	m	class:SearchEngine
statistics	structural_symmetries/group.cc	/^void Group::statistics() const {$/;"	f	class:Group
status	heuristics/lm_cut_landmarks.h	/^    PropositionStatus status;$/;"	m	struct:lm_cut_heuristic::RelaxedProposition
status	landmarks/landmark_graph.h	/^    landmark_status status;$/;"	m	class:landmarks::EdgeType::LandmarkNode
status	search_engine.h	/^	SearchStatus status;$/;"	m	class:SearchEngine
status	search_node_info.h	/^    unsigned int status : 2;$/;"	m	struct:SearchNodeInfo
std	abstract_task.h	/^namespace std {$/;"	n
std	cegar/utils.h	/^namespace std {$/;"	n
std	state_id.h	/^namespace std {$/;"	n
std	task_proxy.h	/^namespace std {$/;"	n
std	utils/hash.h	/^namespace std {$/;"	n
std	utils/logging.h	/^namespace std {$/;"	n
step	search_engines/eager_search.cc	/^SearchStatus EagerSearch::step() {$/;"	f	class:eager_search::EagerSearch
step	search_engines/enforced_hill_climbing_search.cc	/^SearchStatus EnforcedHillClimbingSearch::step() {$/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
step	search_engines/iterated_search.cc	/^SearchStatus IteratedSearch::step() {$/;"	f	class:iterated_search::IteratedSearch
step	search_engines/lazy_search.cc	/^SearchStatus LazySearch::step() {$/;"	f	class:lazy_search::LazySearch
step	search_engines/top_k_eager_search.cc	/^SearchStatus TopKEagerSearch::step() {$/;"	f	class:top_k_eager_search::TopKEagerSearch
step_return_value	search_engines/iterated_search.cc	/^SearchStatus IteratedSearch::step_return_value() {$/;"	f	class:iterated_search::IteratedSearch
stop	utils/timer.cc	/^double Timer::stop() {$/;"	f	class:utils::Timer
stopped	utils/timer.h	/^    bool stopped;$/;"	m	class:utils::Timer
storage	options/options.h	/^    std::map<std::string, Any> storage;$/;"	m	class:options::Options
store	heuristics/cg_cache.h	/^    void store(int var, const State &state,$/;"	f	class:cg_heuristic::CGCache
store_helpful_transition	heuristics/cg_cache.h	/^    void store_helpful_transition($/;"	f	class:cg_heuristic::CGCache
str_to_lower	options/option_parser.cc	/^static string str_to_lower(string s) {$/;"	f	namespace:options
stubborn	pruning/stubborn_sets.h	/^    std::vector<bool> stubborn;$/;"	m	class:stubborn_sets::StubbornSets
stubborn_queue	pruning/stubborn_sets.h	/^    std::vector<int> stubborn_queue;$/;"	m	class:stubborn_sets::StubbornSets
stubborn_sets	pruning/stubborn_sets.cc	/^namespace stubborn_sets {$/;"	n	file:
stubborn_sets	pruning/stubborn_sets.h	/^namespace stubborn_sets {$/;"	n
stubborn_sets_ec	pruning/stubborn_sets_ec.cc	/^namespace stubborn_sets_ec {$/;"	n	file:
stubborn_sets_ec	pruning/stubborn_sets_ec.h	/^namespace stubborn_sets_ec {$/;"	n
stubborn_sets_simple	pruning/stubborn_sets_simple.cc	/^namespace stubborn_sets_simple {$/;"	n	file:
stubborn_sets_simple	pruning/stubborn_sets_simple.h	/^namespace stubborn_sets_simple {$/;"	n
subcertificate_length	bliss/graph.cc	/^  unsigned int subcertificate_length;$/;"	m	class:bliss::TreeNode	file:
subcertificate_length	bliss/graph.cc	/^  unsigned int subcertificate_length;$/;"	m	struct:bliss::__anon3	file:
subevaluators	evaluators/combining_evaluator.h	/^    std::vector<ScalarEvaluator *> subevaluators;$/;"	m	class:combining_evaluator::CombiningEvaluator
subscribe	state_registry.cc	/^void StateRegistry::subscribe(PerStateInformationBase *psi) const {$/;"	f	class:StateRegistry
subscribers	state_registry.h	/^    mutable std::set<PerStateInformationBase *> subscribers;$/;"	m	class:StateRegistry
substr	options/errors.h	/^    std::string substr;$/;"	m	struct:options::ParseError
subtask_generators	cegar/cost_saturation.h	/^    const std::vector<std::shared_ptr<SubtaskGenerator>> subtask_generators;$/;"	m	class:cegar::CostSaturation
subtree	ext/tree.hh	/^tree<T, tree_node_allocator> tree<T, tree_node_allocator>::subtree(sibling_iterator from, sibling_iterator to) const$/;"	f	class:tree
subtree	ext/tree.hh	/^void tree<T, tree_node_allocator>::subtree(tree& tmp, sibling_iterator from, sibling_iterator to) const$/;"	f	class:tree
subtree	options/parse_tree.h	/^tree<T> subtree($/;"	f	namespace:options
succ_builder	causal_graph.cc	/^    IntRelationBuilder succ_builder;$/;"	m	struct:CausalGraphBuilder	file:
succ_signature	merge_and_shrink/shrink_bisimulation.cc	/^    SuccessorSignature succ_signature;$/;"	m	struct:merge_and_shrink::Signature	file:
successors	causal_graph.h	/^    IntRelation successors;$/;"	m	class:CausalGraph
successors	pdbs/match_tree.cc	/^    Node **successors;$/;"	m	struct:pdbs::MatchTree::Node	file:
sum_evaluator	evaluators/sum_evaluator.cc	/^namespace sum_evaluator {$/;"	n	file:
sum_evaluator	evaluators/sum_evaluator.h	/^namespace sum_evaluator {$/;"	n
support_help	options/doc_store.h	/^    std::vector<LanguageSupportInfo> support_help;$/;"	m	struct:options::DocStruct
supports_conditional_effects	landmarks/landmark_factory_h_m.cc	/^bool LandmarkFactoryHM::supports_conditional_effects() const {$/;"	f	class:landmarks::LandmarkFactoryHM
supports_conditional_effects	landmarks/landmark_factory_merged.cc	/^bool LandmarkFactoryMerged::supports_conditional_effects() const {$/;"	f	class:landmarks::LandmarkFactoryMerged
supports_conditional_effects	landmarks/landmark_factory_rpg_exhaust.cc	/^bool LandmarkFactoryRpgExhaust::supports_conditional_effects() const {$/;"	f	class:landmarks::LandmarkFactoryRpgExhaust
supports_conditional_effects	landmarks/landmark_factory_rpg_sasp.cc	/^bool LandmarkFactoryRpgSasp::supports_conditional_effects() const {$/;"	f	class:landmarks::LandmarkFactoryRpgSasp
supports_conditional_effects	landmarks/landmark_factory_zhu_givan.cc	/^bool LandmarkFactoryZhuGivan::supports_conditional_effects() const {$/;"	f	class:landmarks::LandmarkFactoryZhuGivan
swap	ext/tree.hh	/^void tree<T, tree_node_allocator>::swap(iterator one, iterator two)$/;"	f	class:tree
swap	ext/tree.hh	/^void tree<T, tree_node_allocator>::swap(sibling_iterator it)$/;"	f	class:tree
swap	options/any.h	/^    Any &swap(Any &rhs) {$/;"	f	class:options::Any
swap_and_pop_from_vector	utils/collections.h	/^T swap_and_pop_from_vector(std::vector<T> &vec, size_t pos) {$/;"	f	namespace:utils
switch_var	successor_generator.cc	/^    VariableProxy switch_var;$/;"	m	class:GeneratorSwitch	file:
symmetrical_lookups	structural_symmetries/group.h	/^    SymmetricalLookups symmetrical_lookups;$/;"	m	class:Group
synergy	landmarks/lama_ff_synergy.cc	/^    LamaFFSynergy *synergy;$/;"	m	class:landmarks::FFSlaveHeuristic	file:
synergy	landmarks/lama_ff_synergy.cc	/^    LamaFFSynergy *synergy;$/;"	m	class:landmarks::LamaMasterHeuristic	file:
synopsis	options/doc_store.h	/^    std::string synopsis;$/;"	m	struct:options::DocStruct
synopsis	options/type_documenter.h	/^    static std::string synopsis() {$/;"	f	struct:options::TypeDocumenter
t2t_escape	utils/markup.cc	/^static string t2t_escape(const string &s) {$/;"	f	namespace:utils
tag	merge_and_shrink/transition_system.cc	/^string TransitionSystem::tag() const {$/;"	f	class:merge_and_shrink::TransitionSystem
tail	bliss/kqueue.h	/^  Type *head, *tail;$/;"	m	class:bliss::KQueue
target	cegar/transition.h	/^    AbstractState *target;$/;"	m	struct:cegar::Transition
target	domain_transition_graph.h	/^    ValueNode *target;$/;"	m	struct:ValueTransition
target	heuristics/cea_heuristic.cc	/^    LocalProblemNode *target;$/;"	m	struct:cea_heuristic::LocalTransition	file:
target	merge_and_shrink/transition_system.h	/^    int target;$/;"	m	struct:merge_and_shrink::Transition
target_cost	heuristics/cea_heuristic.cc	/^    int target_cost;$/;"	m	struct:cea_heuristic::LocalTransition	file:
task	cegar/cartesian_heuristic_function.h	/^    const std::shared_ptr<AbstractTask> task;$/;"	m	class:cegar::CartesianHeuristicFunction
task	cegar/split_selector.h	/^    const std::shared_ptr<AbstractTask> task;$/;"	m	class:cegar::SplitSelector
task	heuristic.h	/^    const std::shared_ptr<AbstractTask> task;$/;"	m	class:Heuristic
task	pdbs/pattern_collection_generator_genetic.h	/^    std::shared_ptr<AbstractTask> task;$/;"	m	class:pdbs::PatternCollectionGeneratorGenetic
task	potentials/potential_optimizer.h	/^    std::shared_ptr<AbstractTask> task;$/;"	m	class:potentials::PotentialOptimizer
task	pruning_method.h	/^    std::shared_ptr<AbstractTask> task;$/;"	m	class:PruningMethod
task	state_registry.h	/^    const AbstractTask &task;$/;"	m	class:StateRegistry
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:AxiomsProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:ConditionsProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:EffectProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:EffectsProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:FactProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:FactsProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:FactsProxyIterator
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:OperatorProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:OperatorsProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:State
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:TaskProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:VariableProxy
task	task_proxy.h	/^    const AbstractTask *task;$/;"	m	class:VariablesProxy
task	tasks/domain_abstracted_task_factory.cc	/^    shared_ptr<AbstractTask> task;$/;"	m	class:extra_tasks::DomainAbstractedTaskFactory	file:
task_has_axioms	axioms.h	/^    bool task_has_axioms;$/;"	m	class:AxiomEvaluator
task_has_conditional_effects	merge_and_shrink/fts_factory.cc	/^    int task_has_conditional_effects;$/;"	m	class:merge_and_shrink::FTSFactory	file:
task_proxy	cegar/abstraction.h	/^    const TaskProxy task_proxy;$/;"	m	class:cegar::Abstraction
task_proxy	cegar/cartesian_heuristic_function.h	/^    TaskProxy task_proxy;$/;"	m	class:cegar::CartesianHeuristicFunction
task_proxy	cegar/split_selector.h	/^    const TaskProxy task_proxy;$/;"	m	class:cegar::SplitSelector
task_proxy	domain_transition_graph.h	/^    const TaskProxy &task_proxy;$/;"	m	class:DTGFactory
task_proxy	heuristic.h	/^    TaskProxy task_proxy;$/;"	m	class:Heuristic
task_proxy	heuristics/cg_cache.h	/^    TaskProxy task_proxy;$/;"	m	class:cg_heuristic::CGCache
task_proxy	merge_and_shrink/fts_factory.cc	/^    const TaskProxy &task_proxy;$/;"	m	class:merge_and_shrink::FTSFactory	file:
task_proxy	pdbs/incremental_canonical_pdbs.h	/^    TaskProxy task_proxy;$/;"	m	class:pdbs::IncrementalCanonicalPDBs
task_proxy	pdbs/match_tree.h	/^    TaskProxy task_proxy;$/;"	m	class:pdbs::MatchTree
task_proxy	pdbs/pattern_collection_information.h	/^    TaskProxy task_proxy;$/;"	m	class:pdbs::PatternCollectionInformation
task_proxy	potentials/potential_optimizer.h	/^    TaskProxy task_proxy;$/;"	m	class:potentials::PotentialOptimizer
task_proxy	successor_generator.h	/^    TaskProxy task_proxy;$/;"	m	class:SuccessorGenerator
task_proxy	variable_order_finder.h	/^    TaskProxy task_proxy;$/;"	m	class:VariableOrderFinder
tasks	tasks/cost_adapted_task.cc	/^namespace tasks {$/;"	n	file:
tasks	tasks/cost_adapted_task.h	/^namespace tasks {$/;"	n
tasks	tasks/delegating_task.cc	/^namespace tasks {$/;"	n	file:
tasks	tasks/delegating_task.h	/^namespace tasks {$/;"	n
tasks	tasks/root_task.cc	/^namespace tasks {$/;"	n	file:
tasks	tasks/root_task.h	/^namespace tasks {$/;"	n
termination_propositions	landmarks/exploration.h	/^    std::vector<ExProposition *> termination_propositions;$/;"	m	class:landmarks::Exploration
test	algorithms/dynamic_bitset.h	/^    bool test(std::size_t pos) const {$/;"	f	class:dynamic_bitset::DynamicBitset
test	cegar/domains.h	/^    bool test(int var, int value) const {$/;"	f	class:cegar::Domains
test_goal	globals.cc	/^bool test_goal(const GlobalState &state) {$/;"	f
the_size	algorithms/segmented_vector.h	/^    size_t the_size;$/;"	m	class:segmented_vector::SegmentedArrayVector
the_size	algorithms/segmented_vector.h	/^    size_t the_size;$/;"	m	class:segmented_vector::SegmentedVector
time_bound	structural_symmetries/graph_creator.h	/^    int time_bound;$/;"	m	class:GraphCreator
time_limit	bliss/graph.h	/^  double time_limit; \/\/ time limit for find_automorphism. 0 means no time limit$/;"	m	class:bliss::AbstractGraph
timer	bliss/graph.h	/^  Timer *timer;$/;"	m	class:bliss::AbstractGraph
timer	cegar/abstraction.h	/^    utils::CountdownTimer timer;$/;"	m	class:cegar::Abstraction
timer	utils/countdown_timer.h	/^    Timer timer;$/;"	m	class:utils::CountdownTimer
to	search_engines/top_k_eager_search.h	/^	StateID to = StateID::no_state;$/;"	m	struct:top_k_eager_search::StateActionPair
to_list	options/option_parser.cc	/^static vector<string> to_list(string s) {$/;"	f	namespace:options
to_ops_no	structural_symmetries/operator_permutation.h	/^    std::vector<int> to_ops_no;$/;"	m	class:OperatorPermutation
to_str	options/option_parser.h	/^    static std::string to_str(T in) {$/;"	f	class:options::OptionParser
top	algorithms/priority_queues.h	/^	Entry top() {$/;"	f	class:priority_queues::AdaptiveQueue
top	algorithms/priority_queues.h	/^	virtual Entry top() {$/;"	f	class:priority_queues::BucketQueue
top	algorithms/priority_queues.h	/^	virtual Entry top() {$/;"	f	class:priority_queues::HeapQueue
top	bliss/kstack.h	/^  Type top() const {BLISS_ASSERT(cursor > entries); return *cursor; }$/;"	f	class:bliss::KStack
top	open_lists/alternation_open_list.cc	/^Entry AlternationOpenList<Entry>::top() { $/;"	f	class:AlternationOpenList
top	open_lists/epsilon_greedy_open_list.cc	/^Entry EpsilonGreedyOpenList<Entry>::top() {$/;"	f	class:EpsilonGreedyOpenList
top	open_lists/pareto_open_list.cc	/^Entry ParetoOpenList<Entry>::top() {$/;"	f	class:ParetoOpenList
top	open_lists/standard_scalar_open_list.cc	/^Entry StandardScalarOpenList<Entry>::top() {$/;"	f	class:StandardScalarOpenList
top	open_lists/tiebreaking_open_list.cc	/^Entry TieBreakingOpenList<Entry>::top() {$/;"	f	class:TieBreakingOpenList
top	open_lists/type_based_open_list.cc	/^Entry TypeBasedOpenList<Entry>::top() {$/;"	f	class:TypeBasedOpenList
top_k_eager_search	search_engines/top_k_eager_search.cc	/^namespace top_k_eager_search {$/;"	n	file:
top_k_eager_search	search_engines/top_k_eager_search.h	/^namespace top_k_eager_search {$/;"	n
top_k_plans	search_engines/top_k_eager_search.h	/^	std::vector<Plan> top_k_plans;	$/;"	m	class:top_k_eager_search::TopKEagerSearch
top_node	ext/tree.hh	/^				tree_node *top_node;$/;"	m	class:tree::fixed_depth_iterator
top_node	ext/tree.hh	/^				tree_node *top_node;$/;"	m	class:tree::leaf_iterator
trace	utils/logging.cc	/^void trace(const string &msg) {$/;"	f	namespace:utils
trace_path	search_space.cc	/^void SearchSpace::trace_path(const GlobalState &goal_state,$/;"	f	class:SearchSpace
trace_path_with_symmetries	search_space.cc	/^void SearchSpace::trace_path_with_symmetries(const GlobalState &goal_state,$/;"	f	class:SearchSpace
transform_to_pattern_normal_form	pdbs/pattern_collection_generator_genetic.cc	/^Pattern PatternCollectionGeneratorGenetic::transform_to_pattern_normal_form($/;"	f	class:pdbs::PatternCollectionGeneratorGenetic
transition_graphs	heuristics/cea_heuristic.h	/^    std::vector<DomainTransitionGraph *> transition_graphs;$/;"	m	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
transition_graphs	heuristics/cg_heuristic.h	/^    std::vector<DomainTransitionGraph *> transition_graphs;$/;"	m	class:cg_heuristic::CGHeuristic
transition_index	domain_transition_graph.h	/^    std::vector<std::unordered_map<std::pair<int, int>, int>> transition_index;$/;"	m	class:DTGFactory
transition_system	merge_and_shrink/distances.h	/^    const TransitionSystem &transition_system;$/;"	m	class:merge_and_shrink::Distances
transition_system_data_by_var	merge_and_shrink/fts_factory.cc	/^    vector<TransitionSystemData> transition_system_data_by_var;$/;"	m	class:merge_and_shrink::FTSFactory	file:
transition_system_order	merge_and_shrink/label_reduction.h	/^    std::vector<int> transition_system_order;$/;"	m	class:merge_and_shrink::LabelReduction
transition_systems	merge_and_shrink/factored_transition_system.h	/^    std::vector<std::unique_ptr<TransitionSystem>> transition_systems;$/;"	m	class:merge_and_shrink::FactoredTransitionSystem
transition_updater	cegar/abstraction.h	/^    TransitionUpdater transition_updater;$/;"	m	class:cegar::Abstraction
transitions	domain_transition_graph.h	/^    std::vector<ValueTransition> transitions;$/;"	m	struct:ValueNode
transitions	merge_and_shrink/transition_system.h	/^    const std::vector<Transition> &transitions;$/;"	m	struct:merge_and_shrink::GroupAndTransitions
transitions_by_group_id	merge_and_shrink/transition_system.h	/^    const std::vector<std::vector<Transition>> &transitions_by_group_id;$/;"	m	class:merge_and_shrink::TSConstIterator
transitions_by_group_id	merge_and_shrink/transition_system.h	/^    std::vector<std::vector<Transition>> transitions_by_group_id;$/;"	m	class:merge_and_shrink::TransitionSystem
transitions_by_label	merge_and_shrink/fts_factory.cc	/^        vector<vector<Transition>> transitions_by_label;$/;"	m	struct:merge_and_shrink::FTSFactory::TransitionSystemData	file:
traversal_queue	ext/tree.hh	/^				std::queue<tree_node *> traversal_queue;$/;"	m	class:tree::breadth_first_queued_iterator
tree	ext/tree.hh	/^class tree {$/;"	c
tree	ext/tree.hh	/^tree<T, tree_node_allocator>::tree() $/;"	f	class:tree
tree	ext/tree.hh	/^tree<T, tree_node_allocator>::tree(const T& x) $/;"	f	class:tree
tree	ext/tree.hh	/^tree<T, tree_node_allocator>::tree(const iterator_base& other)$/;"	f	class:tree
tree	ext/tree.hh	/^tree<T, tree_node_allocator>::tree(const tree<T, tree_node_allocator>& other)$/;"	f	class:tree
tree_hh_	ext/tree.hh	25;"	d
tree_node	ext/tree.hh	/^		typedef tree_node_<T> tree_node;$/;"	t	class:tree
tree_node_	ext/tree.hh	/^class tree_node_ { \/\/ size: 5*4=20 bytes (on 32 bit arch), can be reduced by 8.$/;"	c
tree_util_hh_	ext/tree_util.hh	28;"	d
try_to_fire_transition	heuristics/cea_heuristic.cc	/^void ContextEnhancedAdditiveHeuristic::try_to_fire_transition($/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
ts_index	merge_and_shrink/merge_tree.h	/^    int ts_index;$/;"	m	struct:merge_and_shrink::MergeTreeNode
type	options/any.h	/^        virtual const std::type_info &type() const {$/;"	f	class:options::Any::Holder
type	options/any.h	/^    const std::type_info &type() const {$/;"	f	class:options::Any
type	options/doc_store.h	/^    std::string type;$/;"	m	struct:options::DocStruct
type	options/registries.h	/^    std::type_index type;$/;"	m	class:options::PluginTypeInfo
type_name	options/doc_store.h	/^    std::string type_name;$/;"	m	struct:options::ArgumentInfo
type_name	options/registries.h	/^    std::string type_name;$/;"	m	class:options::PluginTypeInfo
unary_operators	heuristics/relaxation_heuristic.h	/^    std::vector<UnaryOperator> unary_operators;$/;"	m	class:relaxation_heuristic::RelaxationHeuristic
unary_operators	landmarks/exploration.h	/^    std::vector<ExUnaryOperator> unary_operators;$/;"	m	class:landmarks::Exploration
union_of_condition_labels	landmarks/landmark_factory_zhu_givan.cc	/^lm_set LandmarkFactoryZhuGivan::union_of_condition_labels($/;"	f	class:landmarks::LandmarkFactoryZhuGivan
union_of_precondition_labels	landmarks/landmark_factory_zhu_givan.cc	/^lm_set LandmarkFactoryZhuGivan::union_of_precondition_labels(const OperatorProxy &op,$/;"	f	class:landmarks::LandmarkFactoryZhuGivan
union_with	landmarks/landmark_factory_h_m.cc	/^void union_with(list<T> &alist, const list<T> &other) {$/;"	f	namespace:landmarks
unlimited	options/bounds.h	/^    static Bounds unlimited() {$/;"	f	struct:options::Bounds
unmet_goals	cegar/abstraction.h	/^    int unmet_goals;$/;"	m	class:cegar::Abstraction
unmet_preconditions	cegar/abstraction.h	/^    int unmet_preconditions;$/;"	m	class:cegar::Abstraction
unordered_items	algorithms/ordered_set.h	/^    std::unordered_set<T> unordered_items;$/;"	m	class:ordered_set::OrderedSet
unparsed_config	options/option_parser.h	/^    std::string unparsed_config;$/;"	m	class:options::OptionParser
unparsed_config	options/options.h	/^    std::string unparsed_config;$/;"	m	class:options::Options
unreached_conditions	heuristics/cea_heuristic.cc	/^    int unreached_conditions;$/;"	m	struct:cea_heuristic::LocalTransition	file:
unsat_pc_count_	landmarks/landmark_factory_h_m.h	/^    std::vector<std::pair<int, std::vector<int>>> unsat_pc_count_;$/;"	m	class:landmarks::LandmarkFactoryHM
unsatisfied_conditions	axioms.h	/^        int unsatisfied_conditions;$/;"	m	struct:AxiomEvaluator::AxiomRule
unsatisfied_preconditions	heuristics/lm_cut_landmarks.h	/^    int unsatisfied_preconditions;$/;"	m	struct:lm_cut_heuristic::RelaxedOperator
unsatisfied_preconditions	heuristics/relaxation_heuristic.h	/^    int unsatisfied_preconditions;$/;"	m	struct:relaxation_heuristic::UnaryOperator
unsatisfied_preconditions	landmarks/exploration.h	/^    int unsatisfied_preconditions;$/;"	m	struct:landmarks::ExUnaryOperator
unsolvable_index	merge_and_shrink/factored_transition_system.h	/^    int unsolvable_index; \/\/ -1 if solvable, index of an unsolvable entry otw.$/;"	m	class:merge_and_shrink::FactoredTransitionSystem
unsubscribe	state_registry.cc	/^void StateRegistry::unsubscribe(PerStateInformationBase *const psi) const {$/;"	f	class:StateRegistry
unused_variable	utils/language.h	/^void unused_variable(const T &) {$/;"	f	namespace:utils
update	bliss/uintseqhash.cc	/^void UintSeqHash::update(unsigned int i)$/;"	f	class:bliss::UintSeqHash
update	merge_and_shrink/merge_tree.cc	/^void MergeTree::update(pair<int, int> merge, int new_index) {$/;"	f	class:merge_and_shrink::MergeTree
update_constraints	operator_counting/lm_cut_constraints.cc	/^bool LMCutConstraints::update_constraints(const State &state,$/;"	f	class:operator_counting::LMCutConstraints
update_constraints	operator_counting/pho_constraints.cc	/^bool PhOConstraints::update_constraints(const State &state,$/;"	f	class:operator_counting::PhOConstraints
update_constraints	operator_counting/state_equation_constraints.cc	/^bool StateEquationConstraints::update_constraints(const State &state,$/;"	f	class:operator_counting::StateEquationConstraints
update_current_bucket_no	algorithms/priority_queues.h	/^    void update_current_bucket_no() const {$/;"	f	class:priority_queues::BucketQueue
update_f_value_statistics	search_engines/eager_search.cc	/^void EagerSearch::update_f_value_statistics(const SearchNode &node) {$/;"	f	class:eager_search::EagerSearch
update_f_value_statistics	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::update_f_value_statistics(const SearchNode &node) {$/;"	f	class:top_k_eager_search::TopKEagerSearch
update_h_and_g_values	cegar/abstraction.cc	/^void Abstraction::update_h_and_g_values() {$/;"	f	class:cegar::Abstraction
update_h_max_supporter	heuristics/lm_cut_landmarks.h	/^inline void RelaxedOperator::update_h_max_supporter() {$/;"	f	class:lm_cut_heuristic::RelaxedOperator
update_hm_entry	heuristics/hm_heuristic.cc	/^int HMHeuristic::update_hm_entry(const Tuple &t, int val) {$/;"	f	class:hm_heuristic::HMHeuristic
update_hm_table	heuristics/hm_heuristic.cc	/^void HMHeuristic::update_hm_table() {$/;"	f	class:hm_heuristic::HMHeuristic
update_labeling	bliss/graph.cc	/^AbstractGraph::update_labeling(unsigned int* const labeling)$/;"	f	class:bliss::AbstractGraph
update_labeling_and_its_inverse	bliss/graph.cc	/^AbstractGraph::update_labeling_and_its_inverse(unsigned int* const labeling,$/;"	f	class:bliss::AbstractGraph
update_lm_status	landmarks/landmark_status_manager.cc	/^bool LandmarkStatusManager::update_lm_status(const GlobalState &global_state) {$/;"	f	class:landmarks::LandmarkStatusManager
update_maximum	utils/util.h	/^inline void update_maximum(int& current_value, int& old_value) {$/;"	f
update_option	merge_and_shrink/merge_tree.h	/^    UpdateOption update_option;$/;"	m	class:merge_and_shrink::MergeTree
update_option	merge_and_shrink/merge_tree_factory.h	/^    UpdateOption update_option;$/;"	m	class:merge_and_shrink::MergeTreeFactory
update_orbit_information	bliss/graph.cc	/^AbstractGraph::update_orbit_information(Orbit& o, const unsigned int* perm)$/;"	f	class:bliss::AbstractGraph
update_parent	search_space.cc	/^void SearchNode::update_parent(const SearchNode &parent_node,$/;"	f	class:SearchNode
update_path_graph	search_engines/top_k_eager_search.cc	/^void TopKEagerSearch::update_incomming_edges(SearchNode node, $/;"	f	class:top_k_eager_search::TopKEagerSearch
update_reached_lms	landmarks/landmark_status_manager.cc	/^bool LandmarkStatusManager::update_reached_lms(const GlobalState &parent_global_state,$/;"	f	class:landmarks::LandmarkStatusManager
update_transition_condition	domain_transition_graph.cc	/^void DTGFactory::update_transition_condition(const FactProxy &fact,$/;"	f	class:DTGFactory
upheap	bliss/heap.cc	/^void Heap::upheap(unsigned int index)$/;"	f	class:bliss::Heap
upper_bound	lp/lp_solver.h	/^    double upper_bound;$/;"	m	class:lp::LPConstraint
upper_bound	lp/lp_solver.h	/^    double upper_bound;$/;"	m	struct:lp::LPVariable
usage	options/option_parser.cc	/^string OptionParser::usage(string progname) {$/;"	f	class:options::OptionParser
use_action_landmarks	landmarks/landmark_cost_assignment.h	/^    bool use_action_landmarks;$/;"	m	class:landmarks::LandmarkUniformSharedCostAssignment
use_disjunctive_landmarks	landmarks/landmark_factory.h	/^    bool use_disjunctive_landmarks() const {return disjunctive_landmarks; }$/;"	f	class:landmarks::LandmarkFactory
use_dks	search_engines/eager_search.cc	/^bool EagerSearch::use_dks() const {$/;"	f	class:eager_search::EagerSearch
use_general_costs	cegar/abstraction.h	/^    const bool use_general_costs;$/;"	m	class:cegar::Abstraction
use_general_costs	cegar/cost_saturation.h	/^    const bool use_general_costs;$/;"	m	class:cegar::CostSaturation
use_multi_path_dependence	search_engines/eager_search.h	/^    const bool use_multi_path_dependence;$/;"	m	class:eager_search::EagerSearch
use_orders	landmarks/landmark_factory.h	/^    bool use_orders() const {return !no_orders; }  \/\/ only needed by HMLandmark$/;"	f	class:landmarks::LandmarkFactory
use_oss	search_engines/eager_search.cc	/^bool EagerSearch::use_oss() const {$/;"	f	class:eager_search::EagerSearch
use_preferred	search_engines/enforced_hill_climbing_search.h	/^    bool use_preferred;$/;"	m	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
use_preferred_operators	landmarks/landmark_count_heuristic.h	/^    const bool use_preferred_operators;$/;"	m	class:landmarks::LandmarkCountHeuristic
use_reasonable_orders	landmarks/landmark_factory.h	/^    bool use_reasonable_orders() const {return reasonable_orders; }$/;"	f	class:landmarks::LandmarkFactory
utils	cegar/abstraction.h	/^namespace utils {$/;"	n
utils	cegar/cost_saturation.h	/^namespace utils {$/;"	n
utils	cegar/split_selector.h	/^namespace utils {$/;"	n
utils	cegar/subtask_generators.h	/^namespace utils {$/;"	n
utils	globals.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/label_reduction.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/merge_and_shrink_heuristic.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/merge_scoring_function_single_random.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/merge_scoring_function_total_order.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/merge_tree.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/merge_tree_factory.h	/^namespace utils {$/;"	n
utils	merge_and_shrink/shrink_bucket_based.h	/^namespace utils {$/;"	n
utils	pdbs/pattern_collection_generator_genetic.h	/^namespace utils {$/;"	n
utils	pdbs/pattern_collection_generator_hillclimbing.h	/^namespace utils {$/;"	n
utils	potentials/diverse_potential_heuristics.h	/^namespace utils {$/;"	n
utils	potentials/util.h	/^namespace utils {$/;"	n
utils	sampling.h	/^namespace utils {$/;"	n
utils	structural_symmetries/group.h	/^namespace utils {$/;"	n
utils	utils/collections.h	/^namespace utils {$/;"	n
utils	utils/countdown_timer.cc	/^namespace utils {$/;"	n	file:
utils	utils/countdown_timer.h	/^namespace utils {$/;"	n
utils	utils/hash.h	/^namespace utils {$/;"	n
utils	utils/language.h	/^namespace utils {$/;"	n
utils	utils/logging.cc	/^namespace utils {$/;"	n	file:
utils	utils/logging.h	/^namespace utils {$/;"	n
utils	utils/markup.cc	/^namespace utils {$/;"	n	file:
utils	utils/markup.h	/^namespace utils {$/;"	n
utils	utils/math.cc	/^namespace utils {$/;"	n	file:
utils	utils/math.h	/^namespace utils {$/;"	n
utils	utils/memory.cc	/^namespace utils {$/;"	n	file:
utils	utils/memory.h	/^namespace utils {$/;"	n
utils	utils/rng.cc	/^namespace utils {$/;"	n	file:
utils	utils/rng.h	/^namespace utils {$/;"	n
utils	utils/rng_options.cc	/^namespace utils {$/;"	n	file:
utils	utils/rng_options.h	/^namespace utils {$/;"	n
utils	utils/system.cc	/^namespace utils {$/;"	n	file:
utils	utils/system.h	/^namespace utils {$/;"	n
utils	utils/system_unix.cc	/^namespace utils {$/;"	n	file:
utils	utils/system_windows.cc	/^namespace utils {$/;"	n	file:
utils	utils/timer.cc	/^namespace utils {$/;"	n	file:
utils	utils/timer.h	/^namespace utils {$/;"	n
v	bliss/bignum.h	/^  mpz_t v;$/;"	m	class:bliss::BigNum
val	global_operator.h	/^    int val;$/;"	m	struct:GlobalCondition
val	global_operator.h	/^    int val;$/;"	m	struct:GlobalEffect
valid_keys	options/option_parser.h	/^    std::vector<std::string> valid_keys;$/;"	m	class:options::OptionParser
validate_and_normalize_pattern	pdbs/validation.cc	/^void validate_and_normalize_pattern(const TaskProxy &task_proxy,$/;"	f	namespace:pdbs
validate_and_normalize_patterns	pdbs/validation.cc	/^void validate_and_normalize_patterns(const TaskProxy &task_proxy,$/;"	f	namespace:pdbs
validate_h_max	heuristics/lm_cut_landmarks.cc	/^void LandmarkCutLandmarks::validate_h_max() const {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
value	abstract_task.h	/^    int value;$/;"	m	struct:FactPair
value	cegar/refinement_hierarchy.h	/^    int value;$/;"	m	class:cegar::Node
value	domain_transition_graph.h	/^    int value;$/;"	m	struct:ValueNode
value	domain_transition_graph.h	/^    short value;$/;"	m	struct:LocalAssignment
value	evaluators/const_evaluator.h	/^    int value;$/;"	m	class:const_evaluator::ConstEvaluator
value	options/parse_tree.h	/^    std::string value;$/;"	m	struct:options::ParseNode
value	state_id.h	/^    int value;$/;"	m	class:StateID
value	structural_symmetries/permutation.h	/^    int* value;$/;"	m	class:Permutation
value	task_proxy.h	/^    int value;$/;"	m	class:FactsProxyIterator
value_explanations	options/doc_store.h	/^    std::vector<std::pair<std::string, std::string>> value_explanations;$/;"	m	struct:options::ArgumentInfo
value_map	tasks/domain_abstracted_task.h	/^    const std::vector<std::vector<int>> value_map;$/;"	m	class:extra_tasks::DomainAbstractedTask
value_map	tasks/domain_abstracted_task_factory.cc	/^    vector<vector<int>> value_map;$/;"	m	class:extra_tasks::DomainAbstractedTaskFactory	file:
value_type	ext/tree.hh	/^				typedef T                               value_type;$/;"	t	class:tree::iterator_base
value_type	ext/tree.hh	/^		typedef T value_type;$/;"	t	class:tree
values	cegar/split_selector.h	/^    const std::vector<int> values;$/;"	m	struct:cegar::Split
values	task_proxy.h	/^    std::vector<int> values;$/;"	m	class:State
var	abstract_task.h	/^    int var;$/;"	m	struct:FactPair
var	cegar/refinement_hierarchy.h	/^    int var;$/;"	m	class:cegar::Node
var	domain_transition_graph.h	/^    int var;$/;"	m	class:DomainTransitionGraph
var	global_operator.h	/^    int var;$/;"	m	struct:GlobalCondition
var	global_operator.h	/^    int var;$/;"	m	struct:GlobalEffect
var_by_val	structural_symmetries/permutation.cc	/^vector<int> Permutation::var_by_val;$/;"	m	class:Permutation	file:
var_by_val	structural_symmetries/permutation.h	/^    static std::vector<int> var_by_val;$/;"	m	class:Permutation
var_domain_size	pdbs/match_tree.cc	/^    int var_domain_size;$/;"	m	struct:pdbs::MatchTree::Node	file:
var_id	cegar/split_selector.h	/^    const int var_id;$/;"	m	struct:cegar::Split
var_id	merge_and_shrink/merge_and_shrink_representation.h	/^    const int var_id;$/;"	m	class:merge_and_shrink::MergeAndShrinkRepresentationLeaf
var_id	pdbs/match_tree.cc	/^    int var_id;$/;"	m	struct:pdbs::MatchTree::Node	file:
var_id	task_proxy.h	/^    int var_id;$/;"	m	class:FactsProxyIterator
var_infos	algorithms/int_packer.h	/^    std::vector<VariableInfo> var_infos;$/;"	m	class:int_packer::IntPacker
var_no	axioms.h	/^        int var_no;$/;"	m	struct:AxiomEvaluator::NegationByFailureInfo
variable_order_type	merge_and_shrink/merge_tree_factory_linear.h	/^    VariableOrderType variable_order_type;$/;"	m	class:merge_and_shrink::MergeTreeFactoryLinear
variable_order_type	variable_order_finder.h	/^    const VariableOrderType variable_order_type;$/;"	m	class:VariableOrderFinder
variables	lp/lp_solver.h	/^    std::vector<int> variables;$/;"	m	class:lp::LPConstraint
vars_affected	structural_symmetries/permutation.h	/^    std::vector<int> vars_affected;$/;"	m	class:Permutation
verbose_level	bliss/graph.h	/^  unsigned int verbose_level;$/;"	m	class:bliss::AbstractGraph
verbosity	merge_and_shrink/merge_and_shrink_heuristic.h	/^    const Verbosity verbosity;$/;"	m	class:merge_and_shrink::MergeAndShrinkHeuristic
verbstr	bliss/graph.h	/^  FILE *verbstr;$/;"	m	class:bliss::AbstractGraph
verify_list_non_empty	options/options.h	/^    void verify_list_non_empty(std::string key) const {$/;"	f	class:options::Options
verify_no_axioms	globals.cc	/^void verify_no_axioms() {$/;"	f
verify_no_axioms	task_tools.cc	/^void verify_no_axioms(TaskProxy task) {$/;"	f
verify_no_axioms_no_conditional_effects	globals.cc	/^void verify_no_axioms_no_conditional_effects() {$/;"	f
verify_no_conditional_effects	globals.cc	/^void verify_no_conditional_effects() {$/;"	f
verify_no_conditional_effects	task_tools.cc	/^void verify_no_conditional_effects(TaskProxy task) {$/;"	f
version	bliss/defs.h	/^static const char * const version = "0.72";$/;"	m	namespace:bliss
vertex_color_invariant	bliss/graph.cc	/^Digraph::vertex_color_invariant(const Digraph* const g, const unsigned int vnum)$/;"	f	class:bliss::Digraph
vertex_color_invariant	bliss/graph.cc	/^Graph::vertex_color_invariant(const Graph* const g, const unsigned int v)$/;"	f	class:bliss::Graph
vertices	bliss/graph.h	/^  std::vector<Vertex> vertices;$/;"	m	class:bliss::Digraph
vertices	bliss/graph.h	/^  std::vector<Vertex> vertices;$/;"	m	class:bliss::Graph
w	evaluators/weighted_evaluator.h	/^    int w;$/;"	m	class:weighted_evaluator::WeightedEvaluator
waiting_list	heuristics/cea_heuristic.cc	/^    vector<LocalTransition *> waiting_list;$/;"	m	struct:cea_heuristic::LocalProblemNode	file:
warn_on_unusual_options	merge_and_shrink/merge_and_shrink_heuristic.cc	/^void MergeAndShrinkHeuristic::warn_on_unusual_options() const {$/;"	f	class:merge_and_shrink::MergeAndShrinkHeuristic
warning	options/option_parser.cc	/^void OptionParser::warning(string msg) {$/;"	f	class:options::OptionParser
was_updated	heuristics/hm_heuristic.h	/^    bool was_updated;$/;"	m	class:hm_heuristic::HMHeuristic
weighted_evaluator	evaluators/weighted_evaluator.cc	/^namespace weighted_evaluator {$/;"	n	file:
weighted_evaluator	evaluators/weighted_evaluator.h	/^namespace weighted_evaluator {$/;"	n
wrap	ext/tree.hh	/^template <typename iter> iter tree<T, tree_node_allocator>::wrap(iter position, const T& x)$/;"	f	class:tree
wrapped_queue	algorithms/priority_queues.h	/^    AbstractQueue<Value> *wrapped_queue;$/;"	m	class:priority_queues::AdaptiveQueue
write_dimacs	bliss/graph.cc	/^Digraph::write_dimacs(FILE* const fp)$/;"	f	class:bliss::Digraph
write_dimacs	bliss/graph.cc	/^Graph::write_dimacs(FILE* const fp)$/;"	f	class:bliss::Graph
write_dot	bliss/graph.cc	/^Digraph::write_dot(FILE* const fp)$/;"	f	class:bliss::Digraph
write_dot	bliss/graph.cc	/^Digraph::write_dot(const char* const filename)$/;"	f	class:bliss::Digraph
write_dot	bliss/graph.cc	/^Graph::write_dot(FILE* const fp)$/;"	f	class:bliss::Graph
write_dot	bliss/graph.cc	/^Graph::write_dot(const char* const filename)$/;"	f	class:bliss::Graph
write_overflow_warning	heuristics/additive_heuristic.cc	/^void AdditiveHeuristic::write_overflow_warning() {$/;"	f	class:additive_heuristic::AdditiveHeuristic
write_overflow_warning	landmarks/exploration.cc	/^void Exploration::write_overflow_warning() {$/;"	f	class:landmarks::Exploration
write_reentrant	utils/system_unix.cc	/^void write_reentrant(int filedescr, const char *message, int len) {$/;"	f	namespace:utils
write_reentrant_char	utils/system_unix.cc	/^void write_reentrant_char(int filedescr, char c) {$/;"	f	namespace:utils
write_reentrant_int	utils/system_unix.cc	/^void write_reentrant_int(int filedescr, int value) {$/;"	f	namespace:utils
write_reentrant_str	utils/system_unix.cc	/^void write_reentrant_str(int filedescr, const char *message) {$/;"	f	namespace:utils
written_vars	pruning/stubborn_sets_ec.h	/^    std::vector<bool> written_vars;$/;"	m	class:stubborn_sets_ec::StubbornSetsEC
zero_one_pdbs	pdbs/zero_one_pdbs_heuristic.h	/^    ZeroOnePDBs zero_one_pdbs;$/;"	m	class:pdbs::ZeroOnePDBsHeuristic
zero_unused_bits	algorithms/dynamic_bitset.h	/^    void zero_unused_bits() {$/;"	f	class:dynamic_bitset::DynamicBitset
zeros	algorithms/dynamic_bitset.h	/^    static const Block zeros;$/;"	m	class:dynamic_bitset::DynamicBitset
zeros	algorithms/dynamic_bitset.h	/^const Block DynamicBitset<Block>::zeros = Block(0);$/;"	m	class:dynamic_bitset::DynamicBitset
zplit_cell	bliss/partition.cc	/^Partition::zplit_cell(Partition::Cell* const cell,$/;"	f	class:bliss::Partition
~AbstractGraph	bliss/graph.cc	/^AbstractGraph::~AbstractGraph()$/;"	f	class:bliss::AbstractGraph
~AbstractOperator	pdbs/pattern_database.cc	/^AbstractOperator::~AbstractOperator() {$/;"	f	class:pdbs::AbstractOperator
~AbstractQueue	algorithms/priority_queues.h	/^    virtual ~AbstractQueue() {}$/;"	f	class:priority_queues::AbstractQueue
~Abstraction	cegar/abstraction.cc	/^Abstraction::~Abstraction() {$/;"	f	class:cegar::Abstraction
~AdaptiveQueue	algorithms/priority_queues.h	/^    ~AdaptiveQueue() {$/;"	f	class:priority_queues::AdaptiveQueue
~AdditiveHeuristic	heuristics/additive_heuristic.cc	/^AdditiveHeuristic::~AdditiveHeuristic() {$/;"	f	class:additive_heuristic::AdditiveHeuristic
~BigNum	bliss/bignum.h	/^  ~BigNum() {mpz_clear(v); }$/;"	f	class:bliss::BigNum
~BlindSearchHeuristic	heuristics/blind_search_heuristic.cc	/^BlindSearchHeuristic::~BlindSearchHeuristic() {$/;"	f	class:blind_search_heuristic::BlindSearchHeuristic
~BucketQueue	algorithms/priority_queues.h	/^    virtual ~BucketQueue() {$/;"	f	class:priority_queues::BucketQueue
~CGCache	heuristics/cg_cache.cc	/^CGCache::~CGCache() {$/;"	f	class:cg_heuristic::CGCache
~CGHeuristic	heuristics/cg_heuristic.cc	/^CGHeuristic::~CGHeuristic() {$/;"	f	class:cg_heuristic::CGHeuristic
~CausalGraphBuilder	causal_graph.cc	/^    ~CausalGraphBuilder() {$/;"	f	struct:CausalGraphBuilder
~CombiningEvaluator	evaluators/combining_evaluator.cc	/^CombiningEvaluator::~CombiningEvaluator() {$/;"	f	class:combining_evaluator::CombiningEvaluator
~ContextEnhancedAdditiveHeuristic	heuristics/cea_heuristic.cc	/^ContextEnhancedAdditiveHeuristic::~ContextEnhancedAdditiveHeuristic() {$/;"	f	class:cea_heuristic::ContextEnhancedAdditiveHeuristic
~CountdownTimer	utils/countdown_timer.cc	/^CountdownTimer::~CountdownTimer() {$/;"	f	class:utils::CountdownTimer
~Digraph	bliss/graph.cc	/^Digraph::~Digraph()$/;"	f	class:bliss::Digraph
~Distances	merge_and_shrink/distances.cc	/^Distances::~Distances() {$/;"	f	class:merge_and_shrink::Distances
~DocPrinter	options/doc_printer.cc	/^DocPrinter::~DocPrinter() {$/;"	f	class:options::DocPrinter
~EnforcedHillClimbingSearch	search_engines/enforced_hill_climbing_search.cc	/^EnforcedHillClimbingSearch::~EnforcedHillClimbingSearch() {$/;"	f	class:enforced_hill_climbing_search::EnforcedHillClimbingSearch
~EquivalenceRelation	algorithms/equivalence_relation.cc	/^EquivalenceRelation::~EquivalenceRelation() {$/;"	f	class:equivalence_relation::EquivalenceRelation
~ErrorCatchingCoinMessageHandler	lp/lp_internals.cc	/^    ~ErrorCatchingCoinMessageHandler() {$/;"	f	class:lp::ErrorCatchingCoinMessageHandler
~FFHeuristic	heuristics/ff_heuristic.cc	/^FFHeuristic::~FFHeuristic() {$/;"	f	class:ff_heuristic::FFHeuristic
~FTSFactory	merge_and_shrink/fts_factory.cc	/^FTSFactory::~FTSFactory() {$/;"	f	class:merge_and_shrink::FTSFactory
~FactoredTransitionSystem	merge_and_shrink/factored_transition_system.cc	/^FactoredTransitionSystem::~FactoredTransitionSystem() {$/;"	f	class:merge_and_shrink::FactoredTransitionSystem
~GeneratorSwitch	successor_generator.cc	/^GeneratorSwitch::~GeneratorSwitch() {$/;"	f	class:GeneratorSwitch
~GoalCountHeuristic	heuristics/goal_count_heuristic.cc	/^GoalCountHeuristic::~GoalCountHeuristic() {$/;"	f	class:goal_count_heuristic::GoalCountHeuristic
~Graph	bliss/graph.cc	/^Graph::~Graph()$/;"	f	class:bliss::Graph
~GraphCreator	structural_symmetries/graph_creator.cc	/^GraphCreator::~GraphCreator() {$/;"	f	class:GraphCreator
~Group	structural_symmetries/group.cc	/^Group::~Group() {$/;"	f	class:Group
~HSPMaxHeuristic	heuristics/max_heuristic.cc	/^HSPMaxHeuristic::~HSPMaxHeuristic() {$/;"	f	class:max_heuristic::HSPMaxHeuristic
~Heap	bliss/heap.cc	/^Heap::~Heap()$/;"	f	class:bliss::Heap
~HeapQueue	algorithms/priority_queues.h	/^    virtual ~HeapQueue() {$/;"	f	class:priority_queues::HeapQueue
~Heuristic	heuristic.cc	/^Heuristic::~Heuristic() {$/;"	f	class:Heuristic
~IntPacker	algorithms/int_packer.cc	/^IntPacker::~IntPacker() {$/;"	f	class:int_packer::IntPacker
~IntRelationBuilder	causal_graph.cc	/^IntRelationBuilder::~IntRelationBuilder() {$/;"	f	class:IntRelationBuilder
~KQueue	bliss/kqueue.h	/^KQueue<Type>::~KQueue()$/;"	f	class:bliss::KQueue
~KStack	bliss/kstack.h	/^KStack<Type>::~KStack()$/;"	f	class:bliss::KStack
~LPSolver	lp/lp_solver.cc	/^LPSolver::~LPSolver() {$/;"	f	class:lp::LPSolver
~Label	merge_and_shrink/labels.h	/^    ~Label() {}$/;"	f	class:merge_and_shrink::Label
~LandmarkCountHeuristic	landmarks/landmark_count_heuristic.cc	/^LandmarkCountHeuristic::~LandmarkCountHeuristic() {$/;"	f	class:landmarks::LandmarkCountHeuristic
~LandmarkCutHeuristic	heuristics/lm_cut_heuristic.cc	/^LandmarkCutHeuristic::~LandmarkCutHeuristic() {$/;"	f	class:lm_cut_heuristic::LandmarkCutHeuristic
~LandmarkCutLandmarks	heuristics/lm_cut_landmarks.cc	/^LandmarkCutLandmarks::~LandmarkCutLandmarks() {$/;"	f	class:lm_cut_heuristic::LandmarkCutLandmarks
~LocalProblem	heuristics/cea_heuristic.cc	/^    ~LocalProblem() {$/;"	f	struct:cea_heuristic::LocalProblem
~LocalProblemNode	heuristics/cea_heuristic.cc	/^    ~LocalProblemNode() {$/;"	f	struct:cea_heuristic::LocalProblemNode
~LocalTransition	heuristics/cea_heuristic.cc	/^    ~LocalTransition() {$/;"	f	struct:cea_heuristic::LocalTransition
~MatchTree	pdbs/match_tree.cc	/^MatchTree::~MatchTree() {$/;"	f	class:pdbs::MatchTree
~MaxEvaluator	evaluators/max_evaluator.cc	/^MaxEvaluator::~MaxEvaluator() {$/;"	f	class:max_evaluator::MaxEvaluator
~MemoryTracer	utils/logging.cc	/^MemoryTracer::~MemoryTracer() {$/;"	f	class:utils::MemoryTracer
~MergeAndShrinkRepresentation	merge_and_shrink/merge_and_shrink_representation.cc	/^MergeAndShrinkRepresentation::~MergeAndShrinkRepresentation() {$/;"	f	class:merge_and_shrink::MergeAndShrinkRepresentation
~MergeTree	merge_and_shrink/merge_tree.cc	/^MergeTree::~MergeTree() {$/;"	f	class:merge_and_shrink::MergeTree
~MergeTreeNode	merge_and_shrink/merge_tree.cc	/^MergeTreeNode::~MergeTreeNode() {$/;"	f	class:merge_and_shrink::MergeTreeNode
~Node	cegar/refinement_hierarchy.cc	/^Node::~Node() {$/;"	f	class:cegar::Node
~Node	pdbs/match_tree.cc	/^MatchTree::Node::~Node() {$/;"	f	class:pdbs::MatchTree::Node
~OperatorCountingHeuristic	operator_counting/operator_counting_heuristic.cc	/^OperatorCountingHeuristic::~OperatorCountingHeuristic() {$/;"	f	class:operator_counting::OperatorCountingHeuristic
~OperatorPermutation	structural_symmetries/operator_permutation.cc	/^OperatorPermutation::~OperatorPermutation(){$/;"	f	class:OperatorPermutation
~Orbit	bliss/orbit.cc	/^Orbit::~Orbit()$/;"	f	class:bliss::Orbit
~Partition	bliss/partition.cc	/^Partition::~Partition()$/;"	f	class:bliss::Partition
~PerStateInformation	per_state_information.h	/^    ~PerStateInformation() {$/;"	f	class:PerStateInformation
~PerStateInformationBase	per_state_information.h	/^    virtual ~PerStateInformationBase() {}$/;"	f	class:PerStateInformationBase
~Permutation	structural_symmetries/permutation.cc	/^Permutation::~Permutation(){$/;"	f	class:Permutation
~Placeholder	options/any.h	/^        virtual ~Placeholder() {}$/;"	f	class:options::Any::Placeholder
~PlainPrinter	options/doc_printer.cc	/^PlainPrinter::~PlainPrinter() {$/;"	f	class:options::PlainPrinter
~PluginTypeInfo	options/registries.h	/^    ~PluginTypeInfo() {$/;"	f	class:options::PluginTypeInfo
~PotentialHeuristic	potentials/potential_heuristic.cc	/^PotentialHeuristic::~PotentialHeuristic() {$/;"	f	class:potentials::PotentialHeuristic
~PrefEvaluator	evaluators/pref_evaluator.cc	/^PrefEvaluator::~PrefEvaluator() {$/;"	f	class:pref_evaluator::PrefEvaluator
~RandomNumberGenerator	utils/rng.cc	/^RandomNumberGenerator::~RandomNumberGenerator() {$/;"	f	class:utils::RandomNumberGenerator
~RelaxationHeuristic	heuristics/relaxation_heuristic.cc	/^RelaxationHeuristic::~RelaxationHeuristic() {$/;"	f	class:relaxation_heuristic::RelaxationHeuristic
~SearchEngine	search_engine.cc	/^SearchEngine::~SearchEngine() {$/;"	f	class:SearchEngine
~SegmentedArrayVector	algorithms/segmented_vector.h	/^    ~SegmentedArrayVector() {$/;"	f	class:segmented_vector::SegmentedArrayVector
~SegmentedVector	algorithms/segmented_vector.h	/^    ~SegmentedVector() {$/;"	f	class:segmented_vector::SegmentedVector
~SplitSelector	cegar/split_selector.cc	/^SplitSelector::~SplitSelector() {$/;"	f	class:cegar::SplitSelector
~StateID	state_id.h	/^    ~StateID() {$/;"	f	class:StateID
~StateRegistry	state_registry.cc	/^StateRegistry::~StateRegistry() {$/;"	f	class:StateRegistry
~SuccessorGenerator	successor_generator.cc	/^SuccessorGenerator::~SuccessorGenerator() {$/;"	f	class:SuccessorGenerator
~SumEvaluator	evaluators/sum_evaluator.cc	/^SumEvaluator::~SumEvaluator() {$/;"	f	class:sum_evaluator::SumEvaluator
~TraceBlock	utils/logging.cc	/^TraceBlock::~TraceBlock() {$/;"	f	class:utils::TraceBlock
~TransitionSystem	merge_and_shrink/transition_system.cc	/^TransitionSystem::~TransitionSystem() {$/;"	f	class:merge_and_shrink::TransitionSystem
~Txt2TagsPrinter	options/doc_printer.cc	/^Txt2TagsPrinter::~Txt2TagsPrinter() {$/;"	f	class:options::Txt2TagsPrinter
~VariableInfo	algorithms/int_packer.cc	/^    ~VariableInfo() {$/;"	f	class:int_packer::IntPacker::VariableInfo
~Vertex	bliss/graph.cc	/^Digraph::Vertex::~Vertex()$/;"	f	class:bliss::Digraph::Vertex
~Vertex	bliss/graph.cc	/^Graph::Vertex::~Vertex()$/;"	f	class:bliss::Graph::Vertex
~WeightedEvaluator	evaluators/weighted_evaluator.cc	/^WeightedEvaluator::~WeightedEvaluator() {$/;"	f	class:weighted_evaluator::WeightedEvaluator
~const_iterator	per_state_information.h	/^        ~const_iterator() {}$/;"	f	class:PerStateInformation::const_iterator
~tree	ext/tree.hh	/^tree<T, tree_node_allocator>::~tree()$/;"	f	class:tree
